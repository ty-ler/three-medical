import {
  init_esm
} from "./chunk-YGSKJKHH.js";
import "./chunk-QOVRSCHT.js";

// node_modules/@cornerstonejs/core/dist/esm/eventTarget.js
var CornerstoneEventTarget = class {
  constructor() {
    this.listeners = {};
  }
  reset() {
    this.listeners = {};
  }
  addEventListener(type, callback) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(callback);
  }
  removeEventListener(type, callback) {
    if (!this.listeners[type]) {
      return;
    }
    const stack = this.listeners[type];
    const stackLength = stack.length;
    for (let i = 0; i < stackLength; i++) {
      if (stack[i] === callback) {
        stack.splice(i, 1);
        return;
      }
    }
  }
  dispatchEvent(event) {
    if (!this.listeners[event.type]) {
      return;
    }
    const stack = this.listeners[event.type].slice();
    const stackLength = stack.length;
    for (let i = 0; i < stackLength; i++) {
      stack[i].call(this, event);
    }
    return !event.defaultPrevented;
  }
};
var eventTarget = new CornerstoneEventTarget();
var eventTarget_default = eventTarget;

// node_modules/@cornerstonejs/core/dist/esm/utilities/triggerEvent.js
function triggerEvent(el = eventTarget_default, type, detail = null) {
  if (!type) {
    throw new Error("Event type was not defined");
  }
  const event = new CustomEvent(type, {
    detail,
    cancelable: true
  });
  return el.dispatchEvent(event);
}

// node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js
var LAST_RUNTIME_ID = Symbol("LastRuntimeId");

// node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js
function imageIdToURI(imageId) {
  const colonIndex = imageId.indexOf(":");
  return imageId.substring(colonIndex + 1);
}

// node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js
init_esm();

// node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js
init_esm();

// node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js
init_esm();

// node_modules/@cornerstonejs/core/dist/esm/enums/Events.js
var Events;
(function(Events2) {
  Events2["CACHE_SIZE_EXCEEDED"] = "CACHE_SIZE_EXCEEDED";
  Events2["IMAGE_LOAD_ERROR"] = "IMAGE_LOAD_ERROR";
  Events2["CAMERA_MODIFIED"] = "CORNERSTONE_CAMERA_MODIFIED";
  Events2["VOI_MODIFIED"] = "CORNERSTONE_VOI_MODIFIED";
  Events2["ELEMENT_DISABLED"] = "CORNERSTONE_ELEMENT_DISABLED";
  Events2["ELEMENT_ENABLED"] = "CORNERSTONE_ELEMENT_ENABLED";
  Events2["IMAGE_RENDERED"] = "CORNERSTONE_IMAGE_RENDERED";
  Events2["IMAGE_VOLUME_MODIFIED"] = "CORNERSTONE_IMAGE_VOLUME_MODIFIED";
  Events2["IMAGE_LOADED"] = "CORNERSTONE_IMAGE_LOADED";
  Events2["IMAGE_LOAD_FAILED"] = "CORNERSTONE_IMAGE_LOAD_FAILED";
  Events2["VOLUME_LOADED"] = "CORNERSTONE_VOLUME_LOADED";
  Events2["VOLUME_LOADED_FAILED"] = "CORNERSTONE_VOLUME_LOADED_FAILED";
  Events2["IMAGE_CACHE_IMAGE_ADDED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED";
  Events2["IMAGE_CACHE_IMAGE_REMOVED"] = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED";
  Events2["VOLUME_CACHE_VOLUME_ADDED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED";
  Events2["VOLUME_CACHE_VOLUME_REMOVED"] = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED";
  Events2["STACK_NEW_IMAGE"] = "CORNERSTONE_STACK_NEW_IMAGE";
  Events2["IMAGE_SPACING_CALIBRATED"] = "CORNERSTONE_IMAGE_SPACING_CALIBRATED";
  Events2["IMAGE_LOAD_PROGRESS"] = "CORNERSTONE_IMAGE_LOAD_PROGRESS";
})(Events || (Events = {}));
var Events_default = Events;

// node_modules/@cornerstonejs/core/dist/esm/cache/cache.js
var MAX_CACHE_SIZE_1GB = 1073741824;
var Cache = class {
  constructor() {
    this.setMaxCacheSize = (newMaxCacheSize) => {
      if (!newMaxCacheSize || typeof newMaxCacheSize !== "number") {
        const errorMessage = `New max cacheSize ${this._maxCacheSize} should be defined and should be a number.`;
        throw new Error(errorMessage);
      }
      this._maxCacheSize = newMaxCacheSize;
    };
    this.isCacheable = (byteLength) => {
      const unallocatedSpace = this.getBytesAvailable();
      const imageCacheSize = this._imageCacheSize;
      const availableSpace = unallocatedSpace + imageCacheSize;
      return availableSpace > byteLength;
    };
    this.getMaxCacheSize = () => this._maxCacheSize;
    this.getCacheSize = () => this._imageCacheSize + this._volumeCacheSize;
    this._decacheImage = (imageId) => {
      const { imageLoadObject } = this._imageCache.get(imageId);
      if (imageLoadObject.cancel) {
        imageLoadObject.cancel();
      }
      if (imageLoadObject.decache) {
        imageLoadObject.decache();
      }
      this._imageCache.delete(imageId);
    };
    this._decacheVolume = (volumeId) => {
      const cachedVolume = this._volumeCache.get(volumeId);
      const { volumeLoadObject } = cachedVolume;
      if (volumeLoadObject.cancel) {
        volumeLoadObject.cancel();
      }
      if (volumeLoadObject.decache) {
        volumeLoadObject.decache();
      }
      this._volumeCache.delete(volumeId);
    };
    this.purgeCache = () => {
      const imageIterator = this._imageCache.keys();
      while (true) {
        const { value: imageId, done } = imageIterator.next();
        if (done) {
          break;
        }
        this.removeImageLoadObject(imageId);
        triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      }
      const volumeIterator = this._volumeCache.keys();
      while (true) {
        const { value: volumeId, done } = volumeIterator.next();
        if (done) {
          break;
        }
        this.removeVolumeLoadObject(volumeId);
        triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_REMOVED, {
          volumeId
        });
      }
    };
    this.getVolumeLoadObject = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("getVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        return;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volumeLoadObject;
    };
    this.getVolume = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("getVolume: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        return;
      }
      cachedVolume.timeStamp = Date.now();
      return cachedVolume.volume;
    };
    this.removeImageLoadObject = (imageId) => {
      if (imageId === void 0) {
        throw new Error("removeImageLoadObject: imageId must not be undefined");
      }
      const cachedImage = this._imageCache.get(imageId);
      if (cachedImage === void 0) {
        throw new Error("removeImageLoadObject: imageId was not present in imageCache");
      }
      this._incrementImageCacheSize(-cachedImage.sizeInBytes);
      const eventDetails = {
        imageId
      };
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, eventDetails);
      this._decacheImage(imageId);
    };
    this.removeVolumeLoadObject = (volumeId) => {
      if (volumeId === void 0) {
        throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
      }
      const cachedVolume = this._volumeCache.get(volumeId);
      if (cachedVolume === void 0) {
        throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
      }
      this._incrementVolumeCacheSize(-cachedVolume.sizeInBytes);
      const eventDetails = {
        volume: cachedVolume,
        volumeId
      };
      triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_REMOVED, eventDetails);
      this._decacheVolume(volumeId);
    };
    this._incrementImageCacheSize = (increment) => {
      this._imageCacheSize += increment;
    };
    this._incrementVolumeCacheSize = (increment) => {
      this._volumeCacheSize += increment;
    };
    this._imageCache = /* @__PURE__ */ new Map();
    this._volumeCache = /* @__PURE__ */ new Map();
    this._imageCacheSize = 0;
    this._volumeCacheSize = 0;
    this._maxCacheSize = MAX_CACHE_SIZE_1GB;
  }
  getBytesAvailable() {
    return this.getMaxCacheSize() - this.getCacheSize();
  }
  decacheIfNecessaryUntilBytesAvailable(numBytes, volumeImageIds) {
    let bytesAvailable = this.getBytesAvailable();
    if (bytesAvailable >= numBytes) {
      return bytesAvailable;
    }
    let cachedImages = Array.from(this._imageCache.values());
    function compare(a, b) {
      if (a.timeStamp > b.timeStamp) {
        return 1;
      }
      if (a.timeStamp < b.timeStamp) {
        return -1;
      }
      return 0;
    }
    cachedImages.sort(compare);
    let cachedImageIds = cachedImages.map((im) => im.imageId);
    let imageIdsToPurge = cachedImageIds;
    if (volumeImageIds) {
      imageIdsToPurge = cachedImageIds.filter((id) => !volumeImageIds.includes(id));
    }
    for (const imageId of imageIdsToPurge) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
    cachedImages = Array.from(this._imageCache.values());
    cachedImageIds = cachedImages.map((im) => im.imageId);
    for (const imageId of cachedImageIds) {
      this.removeImageLoadObject(imageId);
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_REMOVED, { imageId });
      bytesAvailable = this.getBytesAvailable();
      if (bytesAvailable >= numBytes) {
        return bytesAvailable;
      }
    }
  }
  putImageLoadObject(imageId, imageLoadObject) {
    if (imageId === void 0) {
      throw new Error("putImageLoadObject: imageId must not be undefined");
    }
    if (imageLoadObject.promise === void 0) {
      throw new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
    }
    if (this._imageCache.has(imageId)) {
      throw new Error("putImageLoadObject: imageId already in cache");
    }
    if (imageLoadObject.cancel && typeof imageLoadObject.cancel !== "function") {
      throw new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
    }
    const cachedImage = {
      loaded: false,
      imageId,
      sharedCacheKey: void 0,
      imageLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._imageCache.set(imageId, cachedImage);
    return imageLoadObject.promise.then((image) => {
      if (!this._imageCache.get(imageId)) {
        console.warn("The image was purged from the cache before it completed loading.");
        return;
      }
      if (image.sizeInBytes === void 0) {
        throw new Error("putImageLoadObject: image.sizeInBytes must not be undefined");
      }
      if (image.sizeInBytes.toFixed === void 0) {
        throw new Error("putImageLoadObject: image.sizeInBytes is not a number");
      }
      if (!this.isCacheable(image.sizeInBytes)) {
        throw new Error(Events_default.CACHE_SIZE_EXCEEDED);
      }
      this.decacheIfNecessaryUntilBytesAvailable(image.sizeInBytes);
      cachedImage.loaded = true;
      cachedImage.image = image;
      cachedImage.sizeInBytes = image.sizeInBytes;
      this._incrementImageCacheSize(cachedImage.sizeInBytes);
      const eventDetails = {
        image: cachedImage
      };
      triggerEvent(eventTarget_default, Events_default.IMAGE_CACHE_IMAGE_ADDED, eventDetails);
      cachedImage.sharedCacheKey = image.sharedCacheKey;
    }).catch((error) => {
      this._imageCache.delete(imageId);
      throw error;
    });
  }
  getImageLoadObject(imageId) {
    if (imageId === void 0) {
      throw new Error("getImageLoadObject: imageId must not be undefined");
    }
    const cachedImage = this._imageCache.get(imageId);
    if (cachedImage === void 0) {
      return;
    }
    cachedImage.timeStamp = Date.now();
    return cachedImage.imageLoadObject;
  }
  getVolumeContainingImageId(imageId) {
    const volumeIds = Array.from(this._volumeCache.keys());
    const imageIdToUse = imageIdToURI(imageId);
    for (const volumeId of volumeIds) {
      const cachedVolume = this._volumeCache.get(volumeId);
      if (!cachedVolume.volume) {
        return;
      }
      let { imageIds } = cachedVolume.volume;
      if (!imageIds || imageIds.length === 0) {
        continue;
      }
      imageIds = imageIds.map((id) => imageIdToURI(id));
      const imageIdIndex = imageIds.indexOf(imageIdToUse);
      if (imageIdIndex > -1) {
        return { volume: cachedVolume.volume, imageIdIndex };
      }
    }
  }
  getCachedImageBasedOnImageURI(imageId) {
    const imageIdToUse = imageIdToURI(imageId);
    const imageIdsInCache = Array.from(this._imageCache.keys());
    const foundImageId = imageIdsInCache.find((id) => id.indexOf(imageIdToUse) !== -1);
    return this._imageCache.get(foundImageId);
  }
  putVolumeLoadObject(volumeId, volumeLoadObject) {
    if (volumeId === void 0) {
      throw new Error("putVolumeLoadObject: volumeId must not be undefined");
    }
    if (volumeLoadObject.promise === void 0) {
      throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
    }
    if (this._volumeCache.has(volumeId)) {
      throw new Error(`putVolumeLoadObject: volumeId:${volumeId} already in cache`);
    }
    if (volumeLoadObject.cancel && typeof volumeLoadObject.cancel !== "function") {
      throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
    }
    const cachedVolume = {
      loaded: false,
      volumeId,
      volumeLoadObject,
      timeStamp: Date.now(),
      sizeInBytes: 0
    };
    this._volumeCache.set(volumeId, cachedVolume);
    return volumeLoadObject.promise.then((volume) => {
      if (!this._volumeCache.get(volumeId)) {
        console.warn("The image was purged from the cache before it completed loading.");
        return;
      }
      if (volume.sizeInBytes === void 0) {
        throw new Error("putVolumeLoadObject: volume.sizeInBytes must not be undefined");
      }
      if (volume.sizeInBytes.toFixed === void 0) {
        throw new Error("putVolumeLoadObject: volume.sizeInBytes is not a number");
      }
      this.decacheIfNecessaryUntilBytesAvailable(volume.sizeInBytes, volume.imageIds);
      cachedVolume.volume = volume;
      cachedVolume.sizeInBytes = volume.sizeInBytes;
      this._incrementVolumeCacheSize(cachedVolume.sizeInBytes);
      const eventDetails = {
        volume: cachedVolume
      };
      triggerEvent(eventTarget_default, Events_default.VOLUME_CACHE_VOLUME_ADDED, eventDetails);
    }).catch((error) => {
      this._volumeCache.delete(volumeId);
      throw error;
    });
  }
};
var cache = new Cache();
var cache_default = cache;

// node_modules/@cornerstonejs/core/dist/esm/requestPool/requestPoolManager.js
var RequestPoolManager = class {
  constructor() {
    this.numRequests = {
      interaction: 0,
      thumbnail: 0,
      prefetch: 0
    };
    this.requestPool = {
      interaction: { 0: [] },
      thumbnail: { 0: [] },
      prefetch: { 0: [] }
    };
    this.awake = false;
    this.grabDelay = 5;
    this.numRequests = {
      interaction: 0,
      thumbnail: 0,
      prefetch: 0
    };
    this.maxNumRequests = {
      interaction: 6,
      thumbnail: 6,
      prefetch: 5
    };
  }
  destroy() {
    if (this.timeoutHandle) {
      window.clearTimeout(this.timeoutHandle);
    }
  }
  addRequest(requestFn, type, additionalDetails, priority = 0) {
    const requestDetails = {
      requestFn,
      type,
      additionalDetails
    };
    if (this.requestPool[type][priority] === void 0) {
      this.requestPool[type][priority] = [];
    }
    this.requestPool[type][priority].push(requestDetails);
    if (!this.awake) {
      this.awake = true;
      this.startGrabbing();
    }
  }
  filterRequests(filterFunction) {
    Object.keys(this.requestPool).forEach((type) => {
      const requestType = this.requestPool[type];
      Object.keys(requestType).forEach((priority) => {
        requestType[priority] = requestType[priority].filter((requestDetails) => {
          return filterFunction(requestDetails);
        });
      });
    });
  }
  clearRequestStack(type) {
    if (!this.requestPool[type]) {
      throw new Error(`No category for the type ${type} found`);
    }
    this.requestPool[type] = { 0: [] };
  }
  sendRequest({ requestFn, type }) {
    this.numRequests[type]++;
    this.awake = true;
    requestFn().finally(() => {
      this.numRequests[type]--;
      this.startAgain();
    });
  }
  startGrabbing() {
    const maxRequests = this.maxNumRequests.interaction + this.maxNumRequests.thumbnail + this.maxNumRequests.prefetch;
    const currentRequests = this.numRequests.interaction + this.numRequests.thumbnail + this.numRequests.prefetch;
    const requestsToSend = maxRequests - currentRequests;
    for (let i = 0; i < requestsToSend; i++) {
      const requestDetails = this.getNextRequest();
      if (requestDetails === false) {
        break;
      } else if (requestDetails) {
        this.sendRequest(requestDetails);
      }
    }
  }
  startAgain() {
    if (!this.awake) {
      return;
    }
    if (this.grabDelay !== void 0) {
      this.timeoutHandle = window.setTimeout(() => {
        this.startGrabbing();
      }, this.grabDelay);
    } else {
      this.startGrabbing();
    }
  }
  getSortedPriorityGroups(type) {
    const priorities = Object.keys(this.requestPool[type]).map(Number).filter((priority) => this.requestPool[type][priority].length).sort();
    return priorities;
  }
  getNextRequest() {
    const interactionPriorities = this.getSortedPriorityGroups("interaction");
    for (const priority of interactionPriorities) {
      if (this.requestPool.interaction[priority].length && this.numRequests.interaction < this.maxNumRequests.interaction) {
        return this.requestPool.interaction[priority].shift();
      }
    }
    const thumbnailPriorities = this.getSortedPriorityGroups("thumbnail");
    for (const priority of thumbnailPriorities) {
      if (this.requestPool.thumbnail[priority].length && this.numRequests.thumbnail < this.maxNumRequests.thumbnail) {
        return this.requestPool.thumbnail[priority].shift();
      }
    }
    const prefetchPriorities = this.getSortedPriorityGroups("prefetch");
    for (const priority of prefetchPriorities) {
      if (this.requestPool.prefetch[priority].length && this.numRequests.prefetch < this.maxNumRequests.prefetch) {
        return this.requestPool.prefetch[priority].shift();
      }
    }
    if (!interactionPriorities.length && !thumbnailPriorities.length && !prefetchPriorities.length) {
      this.awake = false;
    }
    return false;
  }
  getRequestPool() {
    return this.requestPool;
  }
};
var requestPoolManager = new RequestPoolManager();

// node_modules/@cornerstonejs/core/dist/esm/requestPool/imageLoadPoolManager.js
var imageLoadPoolManager = new RequestPoolManager();
imageLoadPoolManager.maxNumRequests = {
  interaction: 1e3,
  thumbnail: 1e3,
  prefetch: 1e3
};
imageLoadPoolManager.grabDelay = 0;
var imageLoadPoolManager_default = imageLoadPoolManager;

// node_modules/@cornerstonejs/core/dist/esm/imageLoader.js
var imageLoaders = {};
var unknownImageLoader;
function loadImageFromImageLoader(imageId, options) {
  const colonIndex = imageId.indexOf(":");
  const scheme = imageId.substring(0, colonIndex);
  const loader = imageLoaders[scheme];
  if (loader === void 0 || loader === null) {
    if (unknownImageLoader !== void 0) {
      return unknownImageLoader(imageId);
    }
    throw new Error("loadImageFromImageLoader: no image loader for imageId");
  }
  const imageLoadObject = loader(imageId, options);
  imageLoadObject.promise.then(function(image) {
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOADED, { image });
  }, function(error) {
    const errorObject = {
      imageId,
      error
    };
    triggerEvent(eventTarget_default, Events_default.IMAGE_LOAD_FAILED, errorObject);
  });
  return imageLoadObject;
}
function loadImageFromCacheOrVolume(imageId, options) {
  let imageLoadObject = cache_default.getImageLoadObject(imageId);
  if (imageLoadObject !== void 0) {
    return imageLoadObject;
  }
  const cachedVolumeInfo = cache_default.getVolumeContainingImageId(imageId);
  if (cachedVolumeInfo && cachedVolumeInfo.volume.loadStatus.loaded) {
    const { volume, imageIdIndex } = cachedVolumeInfo;
    imageLoadObject = volume.convertToCornerstoneImage(imageId, imageIdIndex);
    return imageLoadObject;
  }
  const cachedImage = cache_default.getCachedImageBasedOnImageURI(imageId);
  if (cachedImage) {
    imageLoadObject = cachedImage.imageLoadObject;
    return imageLoadObject;
  }
  imageLoadObject = loadImageFromImageLoader(imageId, options);
  return imageLoadObject;
}
function loadImage(imageId, options = { priority: 0, requestType: "prefetch" }) {
  if (imageId === void 0) {
    throw new Error("loadImage: parameter imageId must not be undefined");
  }
  return loadImageFromCacheOrVolume(imageId, options).promise;
}
function loadAndCacheImage(imageId, options = { priority: 0, requestType: "prefetch" }) {
  if (imageId === void 0) {
    throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
  }
  const imageLoadObject = loadImageFromCacheOrVolume(imageId, options);
  if (!cache_default.getImageLoadObject(imageId)) {
    cache_default.putImageLoadObject(imageId, imageLoadObject).catch((err) => {
      console.warn(err);
    });
  }
  return imageLoadObject.promise;
}
function loadAndCacheImages(imageIds, options = { priority: 0, requestType: "prefetch" }) {
  if (!imageIds || imageIds.length === 0) {
    throw new Error("loadAndCacheImages: parameter imageIds must be list of image Ids");
  }
  const allPromises = imageIds.map((imageId) => {
    return loadAndCacheImage(imageId, options);
  });
  return allPromises;
}
function cancelLoadImage(imageId) {
  const filterFunction = ({ additionalDetails }) => {
    if (additionalDetails.imageId) {
      return additionalDetails.imageId !== imageId;
    }
    return true;
  };
  imageLoadPoolManager_default.filterRequests(filterFunction);
  const imageLoadObject = cache_default.getImageLoadObject(imageId);
  if (imageLoadObject) {
    imageLoadObject.cancel();
  }
}
function cancelLoadImages(imageIds) {
  imageIds.forEach((imageId) => cancelLoadImage(imageId));
}
function cancelLoadAll() {
  const requestPool = imageLoadPoolManager_default.getRequestPool();
  Object.keys(requestPool).forEach((type) => {
    const requests = requestPool[type];
    Object.keys(requests).forEach((priority) => {
      const requestDetails = requests[priority].pop();
      const { imageId, volumeId } = requestDetails.additionalDetails;
      let loadObject;
      if (imageId) {
        loadObject = cache_default.getImageLoadObject(imageId);
      } else if (volumeId) {
        loadObject = cache_default.getVolumeLoadObject(volumeId);
      }
      if (loadObject) {
        loadObject.cancel();
      }
    });
    imageLoadPoolManager_default.clearRequestStack(type);
  });
}
function registerImageLoader(scheme, imageLoader) {
  imageLoaders[scheme] = imageLoader;
}
function registerUnknownImageLoader(imageLoader) {
  const oldImageLoader = unknownImageLoader;
  unknownImageLoader = imageLoader;
  return oldImageLoader;
}
function unregisterAllImageLoaders() {
  Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);
  unknownImageLoader = void 0;
}
export {
  cancelLoadAll,
  cancelLoadImage,
  cancelLoadImages,
  loadAndCacheImage,
  loadAndCacheImages,
  loadImage,
  registerImageLoader,
  registerUnknownImageLoader,
  unregisterAllImageLoaders
};
//# sourceMappingURL=@cornerstonejs_core_dist_esm_imageLoader.js.map
