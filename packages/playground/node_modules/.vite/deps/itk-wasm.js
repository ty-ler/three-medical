import {
  __commonJS,
  __toESM
} from "./chunk-5CYG367S.js";

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "node_modules/axios/lib/core/enhanceError.js"(exports, module) {
    "use strict";
    module.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      };
      return error;
    };
  }
});

// node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "node_modules/axios/lib/core/createError.js"(exports, module) {
    "use strict";
    var enhanceError = require_enhanceError();
    module.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var createError = require_createError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "node_modules/axios/lib/cancel/Cancel.js"(exports, module) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module.exports = Cancel;
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || defaults.transitional;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel && cancel.type ? new Cancel("canceled") : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder2) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder2 || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var Cancel = require_Cancel();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new Cancel("canceled");
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.23.0"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version2, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")));
        }
        if (version2 && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version2 + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i;
        var l = token._listeners.length;
        for (i = 0; i < l; i++) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    module.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios4 = createInstance(defaults);
    axios4.Axios = Axios;
    axios4.Cancel = require_Cancel();
    axios4.CancelToken = require_CancelToken();
    axios4.isCancel = require_isCancel();
    axios4.VERSION = require_data().version;
    axios4.all = function all(promises) {
      return Promise.all(promises);
    };
    axios4.spread = require_spread();
    axios4.isAxiosError = require_isAxiosError();
    module.exports = axios4;
    module.exports.default = axios4;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/webworker-promise/src/tiny-emitter.js
var require_tiny_emitter = __commonJS({
  "node_modules/webworker-promise/src/tiny-emitter.js"(exports, module) {
    var TinyEmitter = class {
      constructor() {
        Object.defineProperty(this, "__listeners", {
          value: {},
          enumerable: false,
          writable: false
        });
      }
      emit(eventName, ...args) {
        if (!this.__listeners[eventName])
          return this;
        for (const handler of this.__listeners[eventName]) {
          handler(...args);
        }
        return this;
      }
      once(eventName, handler) {
        const once = (...args) => {
          this.off(eventName, once);
          handler(...args);
        };
        return this.on(eventName, once);
      }
      on(eventName, handler) {
        if (!this.__listeners[eventName])
          this.__listeners[eventName] = [];
        this.__listeners[eventName].push(handler);
        return this;
      }
      off(eventName, handler) {
        if (handler)
          this.__listeners[eventName] = this.__listeners[eventName].filter((h) => h !== handler);
        else
          this.__listeners[eventName] = [];
        return this;
      }
    };
    module.exports = TinyEmitter;
  }
});

// node_modules/webworker-promise/src/index.js
var require_src = __commonJS({
  "node_modules/webworker-promise/src/index.js"(exports, module) {
    var TinyEmitter = require_tiny_emitter();
    var MESSAGE_RESULT = 0;
    var MESSAGE_EVENT = 1;
    var RESULT_SUCCESS = 1;
    var Worker2 = class extends TinyEmitter {
      constructor(worker) {
        super();
        this._messageId = 1;
        this._messages = /* @__PURE__ */ new Map();
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._id = Math.ceil(Math.random() * 1e7);
      }
      terminate() {
        this._worker.terminate();
      }
      isFree() {
        return this._messages.size === 0;
      }
      jobsLength() {
        return this._messages.size;
      }
      exec(operationName, data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data, operationName], transferable || []);
        });
      }
      postMessage(data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data], transferable || []);
        });
      }
      emit(eventName, ...args) {
        this._worker.postMessage({ eventName, args });
      }
      _onMessage(e) {
        if (!Array.isArray(e.data) && e.data.eventName) {
          return super.emit(e.data.eventName, ...e.data.args);
        }
        const [type, ...args] = e.data;
        if (type === MESSAGE_EVENT)
          this._onEvent(...args);
        else if (type === MESSAGE_RESULT)
          this._onResult(...args);
        else
          throw new Error(`Wrong message type '${type}'`);
      }
      _onResult(messageId, success, payload) {
        const [res, rej] = this._messages.get(messageId);
        this._messages.delete(messageId);
        return success === RESULT_SUCCESS ? res(payload) : rej(payload);
      }
      _onEvent(messageId, eventName, data) {
        const [, , onEvent] = this._messages.get(messageId);
        if (onEvent) {
          onEvent(eventName, data);
        }
      }
    };
    module.exports = Worker2;
  }
});

// node_modules/promise-file-reader/PromiseFileReader.js
var require_PromiseFileReader = __commonJS({
  "node_modules/promise-file-reader/PromiseFileReader.js"(exports, module) {
    function readAs(file, as) {
      if (!(file instanceof Blob)) {
        throw new TypeError("Must be a File or Blob");
      }
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.onerror = function(e) {
          reject(new Error("Error reading" + file.name + ": " + e.target.result));
        };
        reader["readAs" + as](file);
      });
    }
    function readAsDataURL(file) {
      return readAs(file, "DataURL");
    }
    function readAsText(file) {
      return readAs(file, "Text");
    }
    function readAsArrayBuffer8(file) {
      return readAs(file, "ArrayBuffer");
    }
    module.exports = {
      readAsDataURL,
      readAsText,
      readAsArrayBuffer: readAsArrayBuffer8
    };
  }
});

// node_modules/itk-wasm/dist/core/InterfaceTypes.js
var InterfaceTypes = {
  TextFile: "InterfaceTextFile",
  BinaryFile: "InterfaceBinaryFile",
  TextStream: "InterfaceTextStream",
  BinaryStream: "InterfaceBinaryStream",
  Image: "InterfaceImage",
  Mesh: "InterfaceMesh",
  PolyData: "InterfacePolyData"
};
var InterfaceTypes_default = InterfaceTypes;

// node_modules/itk-wasm/dist/core/IntTypes.js
var IntTypes = {
  Int8: "int8",
  UInt8: "uint8",
  Int16: "int16",
  UInt16: "uint16",
  Int32: "int32",
  UInt32: "uint32",
  Int64: "int64",
  UInt64: "uint64",
  SizeValueType: "uint64",
  IdentifierType: "uint64",
  IndexValueType: "int64",
  OffsetValueType: "int64"
};
var IntTypes_default = IntTypes;

// node_modules/itk-wasm/dist/core/FloatTypes.js
var FloatTypes = {
  Float32: "float32",
  Float64: "float64",
  SpacePrecisionType: "float64"
};
var FloatTypes_default = FloatTypes;

// node_modules/itk-wasm/dist/core/IOTypes.js
var IOTypes = {
  Text: "Text",
  Binary: "Binary",
  Image: "Image",
  Mesh: "Mesh"
};
var IOTypes_default = IOTypes;

// node_modules/itk-wasm/dist/core/PixelTypes.js
var PixelTypes = {
  Unknown: "Unknown",
  Scalar: "Scalar",
  RGB: "RGB",
  RGBA: "RGBA",
  Offset: "Offset",
  Vector: "Vector",
  Point: "Point",
  CovariantVector: "CovariantVector",
  SymmetricSecondRankTensor: "SymmetricSecondRankTensor",
  DiffusionTensor3D: "DiffusionTensor3D",
  Complex: "Complex",
  FixedArray: "FixedArray",
  Array: "Array",
  Matrix: "Matrix",
  VariableLengthVector: "VariableLengthVector",
  VariableSizeMatrix: "VariableSizeMatrix"
};
var PixelTypes_default = PixelTypes;

// node_modules/itk-wasm/dist/core/getMatrixElement.js
function getMatrixElement(matrixData, columns, row, column) {
  return matrixData[column + row * columns];
}
var getMatrixElement_default = getMatrixElement;

// node_modules/itk-wasm/dist/core/setMatrixElement.js
function setMatrixElement(matrixData, columns, row, column, value) {
  matrixData[column + row * columns] = value;
}
var setMatrixElement_default = setMatrixElement;

// node_modules/itk-wasm/dist/core/ImageType.js
var ImageType = class {
  constructor(dimension = 2, componentType = IntTypes_default.UInt8, pixelType = PixelTypes_default.Scalar, components = 1) {
    this.dimension = dimension;
    this.componentType = componentType;
    this.pixelType = pixelType;
    this.components = components;
  }
};
var ImageType_default = ImageType;

// node_modules/itk-wasm/dist/core/Image.js
var Image = class {
  constructor(imageType = new ImageType_default()) {
    this.imageType = imageType;
    this.name = "image";
    const dimension = imageType.dimension;
    this.origin = new Array(dimension);
    this.origin.fill(0);
    this.spacing = new Array(dimension);
    this.spacing.fill(1);
    this.direction = new Float64Array(dimension * dimension);
    this.direction.fill(0);
    for (let ii = 0; ii < dimension; ii++) {
      setMatrixElement_default(this.direction, dimension, ii, ii, 1);
    }
    this.size = new Array(dimension);
    this.size.fill(0);
    this.metadata = {};
    this.data = null;
  }
};
var Image_default = Image;

// node_modules/itk-wasm/dist/core/MeshType.js
var MeshType = class {
  constructor(dimension = 2, pointComponentType = FloatTypes_default.Float32, pointPixelComponentType = FloatTypes_default.Float32, pointPixelType = PixelTypes_default.Scalar, pointPixelComponents = 1, cellComponentType = IntTypes_default.Int32, cellPixelComponentType = FloatTypes_default.Float32, cellPixelType = PixelTypes_default.Scalar, cellPixelComponents = 1) {
    this.dimension = dimension;
    this.pointComponentType = pointComponentType;
    this.pointPixelComponentType = pointPixelComponentType;
    this.pointPixelType = pointPixelType;
    this.pointPixelComponents = pointPixelComponents;
    this.cellComponentType = cellComponentType;
    this.cellPixelComponentType = cellPixelComponentType;
    this.cellPixelType = cellPixelType;
    this.cellPixelComponents = cellPixelComponents;
  }
};
var MeshType_default = MeshType;

// node_modules/itk-wasm/dist/core/Mesh.js
var Mesh = class {
  constructor(mt = new MeshType_default()) {
    this.mt = mt;
    this.name = "Mesh";
    this.meshType = mt;
    this.name = "mesh";
    this.numberOfPoints = 0;
    this.points = null;
    this.numberOfPointPixels = 0;
    this.pointData = null;
    this.numberOfCells = 0;
    this.cellBufferSize = 0;
    this.cells = null;
    this.numberOfCellPixels = 0;
    this.cellData = null;
  }
};
var Mesh_default = Mesh;

// node_modules/itk-wasm/dist/core/PolyDataType.js
var PolyDataType = class {
  constructor(pointPixelComponentType = FloatTypes_default.Float32, pointPixelType = PixelTypes_default.Scalar, pointPixelComponents = 1, cellPixelComponentType = FloatTypes_default.Float32, cellPixelType = PixelTypes_default.Scalar, cellPixelComponents = 1) {
    this.pointPixelComponentType = pointPixelComponentType;
    this.pointPixelType = pointPixelType;
    this.pointPixelComponents = pointPixelComponents;
    this.cellPixelComponentType = cellPixelComponentType;
    this.cellPixelType = cellPixelType;
    this.cellPixelComponents = cellPixelComponents;
  }
};
var PolyDataType_default = PolyDataType;

// node_modules/itk-wasm/dist/core/PolyData.js
var PolyData = class {
  constructor(polyDataType = new PolyDataType_default()) {
    this.polyDataType = polyDataType;
    this.name = "PolyData";
    this.polyDataType = polyDataType;
    this.name = "PolyData";
    this.numberOfPoints = 0;
    this.points = new Float32Array();
    this.verticesBufferSize = 0;
    this.vertices = null;
    this.linesBufferSize = 0;
    this.lines = null;
    this.polygonsBufferSize = 0;
    this.polygons = null;
    this.triangleStripsBufferSize = 0;
    this.triangleStrips = null;
    this.numberOfPointPixels = 0;
    this.pointData = null;
    this.numberOfCellPixels = 0;
    this.cellData = null;
  }
};
var PolyData_default = PolyData;

// node_modules/itk-wasm/dist/core/bufferToTypedArray.js
function bufferToTypedArray(wasmType, buffer) {
  let typedArray = null;
  switch (wasmType) {
    case IntTypes_default.UInt8: {
      typedArray = new Uint8Array(buffer);
      break;
    }
    case IntTypes_default.Int8: {
      typedArray = new Int8Array(buffer);
      break;
    }
    case IntTypes_default.UInt16: {
      typedArray = new Uint16Array(buffer);
      break;
    }
    case IntTypes_default.Int16: {
      typedArray = new Int16Array(buffer);
      break;
    }
    case IntTypes_default.UInt32: {
      typedArray = new Uint32Array(buffer);
      break;
    }
    case IntTypes_default.Int32: {
      typedArray = new Int32Array(buffer);
      break;
    }
    case IntTypes_default.UInt64: {
      if (typeof globalThis.BigUint64Array === "function") {
        typedArray = new BigUint64Array(buffer);
      } else {
        typedArray = new Uint8Array(buffer);
      }
      break;
    }
    case IntTypes_default.Int64: {
      if (typeof globalThis.BigInt64Array === "function") {
        typedArray = new BigInt64Array(buffer);
      } else {
        typedArray = new Uint8Array(buffer);
      }
      break;
    }
    case FloatTypes_default.Float32: {
      typedArray = new Float32Array(buffer);
      break;
    }
    case FloatTypes_default.Float64: {
      typedArray = new Float64Array(buffer);
      break;
    }
    case "null": {
      typedArray = null;
      break;
    }
    case null: {
      typedArray = null;
      break;
    }
    default:
      throw new Error("Type is not supported as a TypedArray");
  }
  return typedArray;
}
var bufferToTypedArray_default = bufferToTypedArray;

// node_modules/itk-wasm/dist/core/copyImage.js
function copyImage(image) {
  const copy = new Image_default(image.imageType);
  copy.name = image.name;
  copy.origin = Array.from(image.origin);
  copy.spacing = Array.from(image.spacing);
  copy.direction = image.direction.slice();
  copy.size = Array.from(image.size);
  if (image.data !== null) {
    const CTor = image.data.constructor;
    copy.data = new CTor(image.data.length);
    if (copy.data != null) {
      copy.data.set(image.data, 0);
    }
  }
  return copy;
}
var copyImage_default = copyImage;

// node_modules/itk-wasm/dist/core/stackImages.js
function stackImages(images) {
  if (images.length < 1) {
    throw Error("At least one images is required.");
  }
  const firstImage = images[0];
  if (firstImage.data === null) {
    throw Error("Image data is null.");
  }
  const result = new Image_default(firstImage.imageType);
  result.origin = Array.from(firstImage.origin);
  result.spacing = Array.from(firstImage.spacing);
  const dimension = result.imageType.dimension;
  result.direction = firstImage.direction.slice();
  const stackOn = dimension - 1;
  result.size = Array.from(firstImage.size);
  const stackedSize = images.reduce((accumulator, currentValue) => {
    return accumulator + currentValue.size[stackOn];
  }, 0);
  result.size[stackOn] = stackedSize;
  const dataSize = result.size.reduce((accumulator, currentValue) => {
    return accumulator * currentValue;
  }, 1) * result.imageType.components;
  const CTor = firstImage.data.constructor;
  result.data = new CTor(dataSize);
  let offsetBase = result.imageType.components;
  for (let subIndex = 0; subIndex < result.size.length - 1; subIndex++) {
    offsetBase *= result.size[subIndex];
  }
  let stackIndex = 0;
  if (result.data != null) {
    for (let index = 0; index < images.length; index++) {
      result.data.set(images[index].data, offsetBase * stackIndex);
      stackIndex += images[index].size[stackOn];
    }
  } else {
    throw Error("Could not create result image data.");
  }
  return result;
}
var stackImages_default = stackImages;

// node_modules/itk-wasm/dist/core/imageSharedBufferOrCopy.js
var haveSharedArrayBuffer = typeof globalThis.SharedArrayBuffer === "function";
function imageSharedBufferOrCopy(image) {
  if (image.data === null) {
    return image;
  }
  if (haveSharedArrayBuffer) {
    if (image.data.buffer instanceof SharedArrayBuffer) {
      return image;
    }
    const sharedBuffer = new SharedArrayBuffer(image.data.buffer.byteLength);
    const CTor = image.data.constructor;
    const sharedTypedArray = new CTor(sharedBuffer);
    if (sharedTypedArray !== null) {
      sharedTypedArray.set(image.data, 0);
    }
    image.data = sharedTypedArray;
    return image;
  } else {
    return copyImage_default(image);
  }
}
var imageSharedBufferOrCopy_default = imageSharedBufferOrCopy;

// node_modules/itk-wasm/dist/core/WorkerPool.js
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var WorkerPool = class {
  constructor(poolSize, fcn) {
    this.fcn = fcn;
    this.workerQueue = new Array(poolSize);
    this.workerQueue.fill(null);
    this.runInfo = [];
  }
  runTasks(taskArgsArray, progressCallback = null) {
    const info = {
      taskQueue: [],
      results: [],
      addingTasks: false,
      postponed: false,
      runningWorkers: 0,
      index: 0,
      completedTasks: 0,
      progressCallback,
      canceled: false
    };
    this.runInfo.push(info);
    info.index = this.runInfo.length - 1;
    return {
      promise: new Promise((resolve, reject) => {
        info.resolve = resolve;
        info.reject = reject;
        info.results = new Array(taskArgsArray.length);
        info.completedTasks = 0;
        info.addingTasks = true;
        taskArgsArray.forEach((taskArg, index) => {
          this.addTask(info.index, index, taskArg);
        });
        info.addingTasks = false;
      }),
      runId: info.index
    };
  }
  terminateWorkers() {
    for (let index = 0; index < this.workerQueue.length; index++) {
      const worker = this.workerQueue[index];
      if (worker != null) {
        worker.terminate();
      }
      this.workerQueue[index] = null;
    }
  }
  cancel(runId) {
    const info = this.runInfo[runId];
    if (info !== null && info !== void 0) {
      info.canceled = true;
    }
  }
  addTask(infoIndex, resultIndex, taskArgs) {
    const info = this.runInfo[infoIndex];
    if ((info === null || info === void 0 ? void 0 : info.canceled) === true) {
      info.reject("Remaining tasks canceled");
      this.clearTask(info.index);
      return;
    }
    if (this.workerQueue.length > 0) {
      const worker = this.workerQueue.pop();
      info.runningWorkers++;
      this.fcn(worker, ...taskArgs).then((_a3) => {
        var { webWorker } = _a3, result = __rest(_a3, ["webWorker"]);
        this.workerQueue.push(webWorker);
        if (this.runInfo[infoIndex] !== null) {
          info.runningWorkers--;
          info.results[resultIndex] = result;
          info.completedTasks++;
          if (info.progressCallback != null) {
            info.progressCallback(info.completedTasks, info.results.length);
          }
          if (info.taskQueue.length > 0) {
            const reTask = info.taskQueue.shift();
            this.addTask(infoIndex, reTask[0], reTask[1]);
          } else if (!info.addingTasks && info.runningWorkers === 0) {
            const results = info.results;
            info.resolve(results);
            this.clearTask(info.index);
          }
        }
      }).catch((error) => {
        info.reject(error);
        this.clearTask(info.index);
      });
    } else {
      if (info.runningWorkers !== 0 || info.postponed) {
        info.taskQueue.push([resultIndex, taskArgs]);
      } else {
        info.postponed = true;
        setTimeout(() => {
          info.postponed = false;
          this.addTask(info.index, resultIndex, taskArgs);
        }, 50);
      }
    }
  }
  clearTask(clearIndex) {
    this.runInfo[clearIndex].results = [];
    this.runInfo[clearIndex].taskQueue = [];
    this.runInfo[clearIndex].progressCallback = null;
    this.runInfo[clearIndex].canceled = null;
    this.runInfo[clearIndex].reject = () => {
    };
    this.runInfo[clearIndex].resolve = () => {
    };
  }
};
var WorkerPool_default = WorkerPool;

// node_modules/itk-wasm/dist/io/getFileExtension.js
function getFileExtension(filePath) {
  let extension = filePath.slice((filePath.lastIndexOf(".") - 1 >>> 0) + 2);
  if (extension.toLowerCase() === "gz") {
    const index = filePath.slice(0, -3).lastIndexOf(".");
    extension = filePath.slice((index - 1 >>> 0) + 2);
  } else if (extension.toLowerCase() === "cbor") {
    const index = filePath.slice(0, -5).lastIndexOf(".");
    extension = filePath.slice((index - 1 >>> 0) + 2);
  } else if (extension.toLowerCase() === "zstd") {
    const index = filePath.slice(0, -10).lastIndexOf(".");
    extension = filePath.slice((index - 1 >>> 0) + 2);
  } else if (extension.toLowerCase() === "zip") {
    const index = filePath.slice(0, -4).lastIndexOf(".");
    extension = filePath.slice((index - 1 >>> 0) + 2);
  }
  return extension;
}
var getFileExtension_default = getFileExtension;

// node_modules/itk-wasm/dist/io/extensionToImageIO.js
var extensionToIO = /* @__PURE__ */ new Map([
  ["bmp", "BMPImageIO"],
  ["BMP", "BMPImageIO"],
  ["dcm", "GDCMImageIO"],
  ["DCM", "GDCMImageIO"],
  ["gipl", "GiplImageIO"],
  ["gipl.gz", "GiplImageIO"],
  ["hdf5", "HDF5ImageIO"],
  ["jpg", "JPEGImageIO"],
  ["JPG", "JPEGImageIO"],
  ["jpeg", "JPEGImageIO"],
  ["JPEG", "JPEGImageIO"],
  ["iwi", "WASMImageIO"],
  ["iwi.cbor", "WASMImageIO"],
  ["iwi.cbor.zstd", "WASMZstdImageIO"],
  ["lsm", "LSMImageIO"],
  ["mnc", "MINCImageIO"],
  ["MNC", "MINCImageIO"],
  ["mnc.gz", "MINCImageIO"],
  ["MNC.GZ", "MINCImageIO"],
  ["mnc2", "MINCImageIO"],
  ["MNC2", "MINCImageIO"],
  ["mgh", "MGHImageIO"],
  ["mgz", "MGHImageIO"],
  ["mgh.gz", "MGHImageIO"],
  ["mha", "MetaImageIO"],
  ["mhd", "MetaImageIO"],
  ["mrc", "MRCImageIO"],
  ["nia", "NiftiImageIO"],
  ["nii", "NiftiImageIO"],
  ["nii.gz", "NiftiImageIO"],
  ["hdr", "NiftiImageIO"],
  ["nrrd", "NrrdImageIO"],
  ["NRRD", "NrrdImageIO"],
  ["nhdr", "NrrdImageIO"],
  ["NHDR", "NrrdImageIO"],
  ["png", "PNGImageIO"],
  ["PNG", "PNGImageIO"],
  ["pic", "BioRadImageIO"],
  ["PIC", "BioRadImageIO"],
  ["tif", "TIFFImageIO"],
  ["TIF", "TIFFImageIO"],
  ["tiff", "TIFFImageIO"],
  ["TIFF", "TIFFImageIO"],
  ["vtk", "VTKImageIO"],
  ["VTK", "VTKImageIO"],
  ["isq", "ScancoImageIO"],
  ["ISQ", "ScancoImageIO"],
  ["fdf", "FDFImageIO"],
  ["FDF", "FDFImageIO"]
]);
var extensionToImageIO_default = extensionToIO;

// node_modules/itk-wasm/dist/io/extensionToMeshIO.js
var extensionToIO2 = /* @__PURE__ */ new Map([
  ["vtk", "VTKPolyDataMeshIO"],
  ["VTK", "VTKPolyDataMeshIO"],
  ["byu", "BYUMeshIO"],
  ["BYU", "BYUMeshIO"],
  ["fsa", "FreeSurferAsciiMeshIO"],
  ["FSA", "FreeSurferAsciiMeshIO"],
  ["fsb", "FreeSurferBinaryMeshIO"],
  ["FSB", "FreeSurferBinaryMeshIO"],
  ["obj", "OBJMeshIO"],
  ["OBJ", "OBJMeshIO"],
  ["off", "OFFMeshIO"],
  ["OFF", "OFFMeshIO"],
  ["stl", "STLMeshIO"],
  ["STL", "STLMeshIO"],
  ["swc", "SWCMeshIO"],
  ["SWC", "SWCMeshIO"],
  ["iwm", "WASMMeshIO"],
  ["iwm.cbor", "WASMMeshIO"],
  ["iwm.cbor.zstd", "WASMZstdMeshIO"]
]);
var extensionToMeshIO_default = extensionToIO2;

// node_modules/itk-wasm/dist/core/internal/createWebWorkerPromise.js
var import_axios = __toESM(require_axios2(), 1);
var import_webworker_promise = __toESM(require_src(), 1);

// node_modules/itk-wasm/dist/itkConfig.js
var version = "1.0.0-b.18";
var itkConfig = {
  webWorkersUrl: void 0,
  pipelineWorkerUrl: `https://cdn.jsdelivr.net/npm/itk-wasm@${version}/dist/web-workers/min-bundles/pipeline.worker.js`,
  imageIOUrl: `https://cdn.jsdelivr.net/npm/itk-image-io@${version}`,
  meshIOUrl: `https://cdn.jsdelivr.net/npm/itk-mesh-io@${version}`,
  pipelinesUrl: `https://cdn.jsdelivr.net/npm/itk-wasm@${version}/dist/pipeline`
};
var itkConfig_default = itkConfig;

// node_modules/itk-wasm/dist/core/internal/createWebWorkerPromise.js
async function createWebWorkerPromise(existingWorker) {
  if (existingWorker != null) {
    const webworkerPromise2 = new import_webworker_promise.default(existingWorker);
    return await Promise.resolve({ webworkerPromise: webworkerPromise2, worker: existingWorker });
  }
  let worker = null;
  const webWorkersUrl = itkConfig_default.webWorkersUrl;
  if (typeof webWorkersUrl !== "undefined") {
    console.warn("itkConfig webWorkersUrl is deprecated. Please use pipelineWorkerUrl with the full path to the pipeline worker.");
    const min = "min-";
    const webWorkerString = webWorkersUrl;
    if (webWorkerString.startsWith("http")) {
      const response = await import_axios.default.get(`${webWorkerString}/${min}bundles/pipeline.worker.js`, { responseType: "blob" });
      worker = new Worker(URL.createObjectURL(response.data));
    } else {
      worker = new Worker(`${webWorkerString}/${min}bundles/pipeline.worker.js`);
    }
  } else if (itkConfig_default.pipelineWorkerUrl === null) {
    worker = new Worker(new URL("../../web-workers/pipeline.worker.js", import.meta.url));
  } else {
    const pipelineWorkerUrl = itkConfig_default.pipelineWorkerUrl;
    if (pipelineWorkerUrl.startsWith("http")) {
      const response = await import_axios.default.get(pipelineWorkerUrl, { responseType: "blob" });
      worker = new Worker(URL.createObjectURL(response.data));
    } else {
      worker = new Worker(pipelineWorkerUrl);
    }
  }
  const webworkerPromise = new import_webworker_promise.default(worker);
  return { webworkerPromise, worker };
}
var createWebWorkerPromise_default = createWebWorkerPromise;

// node_modules/itk-wasm/dist/io/readImageArrayBuffer.js
async function readImageArrayBuffer(webWorker, arrayBuffer, fileName, mimeType) {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const filePath = `./${fileName}`;
  const args = [filePath, "0", "--memory-io", "--quiet"];
  const outputs = [
    { type: InterfaceTypes_default.Image }
  ];
  const inputs = [
    { type: InterfaceTypes_default.BinaryFile, data: { path: filePath, data: new Uint8Array(arrayBuffer) } }
  ];
  const transferables = [arrayBuffer];
  const result = await webworkerPromise.postMessage({
    operation: "readImage",
    config: itkConfig_default,
    mimeType,
    fileName,
    pipelinePath: "ReadImage",
    args,
    outputs,
    inputs
  }, transferables);
  return { image: result.outputs[0].data, webWorker: worker };
}
var readImageArrayBuffer_default = readImageArrayBuffer;

// node_modules/itk-wasm/dist/io/readMeshArrayBuffer.js
async function readMeshArrayBuffer(webWorker, arrayBuffer, fileName, mimeType) {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const filePath = `./${fileName}`;
  const args = [filePath, "0", "--memory-io", "--quiet"];
  const outputs = [
    { type: InterfaceTypes_default.Mesh }
  ];
  const inputs = [
    { type: InterfaceTypes_default.BinaryFile, data: { path: filePath, data: new Uint8Array(arrayBuffer) } }
  ];
  const transferables = [arrayBuffer];
  const result = await webworkerPromise.postMessage({
    operation: "readMesh",
    config: itkConfig_default,
    mimeType,
    fileName,
    pipelinePath: "ReadMesh",
    args,
    outputs,
    inputs
  }, transferables);
  return { mesh: result.outputs[0].data, webWorker: worker };
}
var readMeshArrayBuffer_default = readMeshArrayBuffer;

// node_modules/itk-wasm/dist/io/internal/MimeToMeshIO.js
var mimeToIO = /* @__PURE__ */ new Map([]);
var MimeToMeshIO_default = mimeToIO;

// node_modules/itk-wasm/dist/io/readArrayBuffer.js
async function readArrayBuffer(webWorker, arrayBuffer, fileName, mimeType) {
  const extension = getFileExtension_default(fileName);
  const isMesh = !!extensionToMeshIO_default.has(extension) || !!MimeToMeshIO_default.has(mimeType);
  if (isMesh) {
    return await readMeshArrayBuffer_default(webWorker, arrayBuffer, fileName, mimeType).catch(async function() {
      if (webWorker !== null) {
        webWorker.terminate();
      }
      return await readImageArrayBuffer_default(null, arrayBuffer, fileName, mimeType);
    });
  } else {
    return await readImageArrayBuffer_default(webWorker, arrayBuffer, fileName, mimeType);
  }
}
var readArrayBuffer_default = readArrayBuffer;

// node_modules/itk-wasm/dist/io/readImageBlob.js
var import_promise_file_reader = __toESM(require_PromiseFileReader(), 1);
async function readImageBlob(webWorker, blob, fileName, mimeType) {
  const arrayBuffer = await (0, import_promise_file_reader.readAsArrayBuffer)(blob);
  return await readImageArrayBuffer_default(webWorker, arrayBuffer, fileName, mimeType);
}
var readImageBlob_default = readImageBlob;

// node_modules/itk-wasm/dist/io/readMeshBlob.js
var import_promise_file_reader2 = __toESM(require_PromiseFileReader(), 1);
async function readMeshBlob(webWorker, blob, fileName, mimeType) {
  const arrayBuffer = await (0, import_promise_file_reader2.readAsArrayBuffer)(blob);
  return await readMeshArrayBuffer_default(webWorker, arrayBuffer, fileName, mimeType);
}
var readMeshBlob_default = readMeshBlob;

// node_modules/itk-wasm/dist/io/readBlob.js
async function readBlob(webWorker, blob, fileName, mimeType) {
  const extension = getFileExtension_default(fileName);
  const isMesh = !!extensionToMeshIO_default.has(extension) || !!MimeToMeshIO_default.has(mimeType);
  if (isMesh) {
    return await readMeshBlob_default(webWorker, blob, fileName, mimeType).catch(async function() {
      if (webWorker !== null) {
        webWorker.terminate();
      }
      return await readImageBlob_default(null, blob, fileName, mimeType);
    });
  } else {
    return await readImageBlob_default(webWorker, blob, fileName, mimeType);
  }
}
var readBlob_default = readBlob;

// node_modules/itk-wasm/dist/io/readImageFile.js
var import_promise_file_reader3 = __toESM(require_PromiseFileReader(), 1);
async function readImageFile(webWorker, file) {
  const arrayBuffer = await (0, import_promise_file_reader3.readAsArrayBuffer)(file);
  return await readImageArrayBuffer_default(webWorker, arrayBuffer, file.name, file.type);
}
var readImageFile_default = readImageFile;

// node_modules/itk-wasm/dist/io/readMeshFile.js
var import_promise_file_reader4 = __toESM(require_PromiseFileReader(), 1);
async function readMeshFile(webWorker, file) {
  const arrayBuffer = await (0, import_promise_file_reader4.readAsArrayBuffer)(file);
  return await readMeshArrayBuffer_default(webWorker, arrayBuffer, file.name, file.type);
}
var readMeshFile_default = readMeshFile;

// node_modules/itk-wasm/dist/io/readImageFileSeries.js
var import_promise_file_reader5 = __toESM(require_PromiseFileReader(), 1);
var _a;
var numberOfWorkers = typeof ((_a = globalThis.navigator) === null || _a === void 0 ? void 0 : _a.hardwareConcurrency) === "number" ? globalThis.navigator.hardwareConcurrency : 6;
var workerPool = new WorkerPool_default(numberOfWorkers, readImageArrayBuffer_default);
async function readImageFileSeries(fileList, zSpacing = 1, zOrigin = 0, sortedSeries = false) {
  const fetchFileDescriptions = Array.from(fileList, async function(file) {
    return await (0, import_promise_file_reader5.readAsArrayBuffer)(file).then(function(arrayBuffer) {
      const fileDescription = {
        name: file.name,
        type: file.type,
        data: arrayBuffer
      };
      return fileDescription;
    });
  });
  const fileDescriptions = await Promise.all(fetchFileDescriptions);
  if (!sortedSeries) {
    fileDescriptions.sort((a, b) => {
      if (a.name < b.name) {
        return -1;
      }
      if (a.name > b.name) {
        return 1;
      }
      return 0;
    });
  }
  const taskArgsArray = [];
  for (let index = 0; index < fileDescriptions.length; index++) {
    taskArgsArray.push([fileDescriptions[index].data, fileDescriptions[index].name]);
  }
  const results = await workerPool.runTasks(taskArgsArray).promise;
  const images = results.map((result) => {
    const image = result.image;
    image.imageType.dimension = 3;
    image.size.push(1);
    image.spacing.push(zSpacing);
    image.origin.push(zOrigin);
    image.direction = new Float64Array(9);
    image.direction.fill(0);
    image.direction[0] = 1;
    image.direction[4] = 1;
    image.direction[8] = 1;
    return image;
  });
  const stacked = stackImages_default(images);
  return { image: stacked, webWorkerPool: workerPool };
}
var readImageFileSeries_default = readImageFileSeries;

// node_modules/itk-wasm/dist/io/readFile.js
async function readFile(webWorker, file) {
  const extension = getFileExtension_default(file.name);
  const isMesh = extensionToMeshIO_default.has(extension);
  if (isMesh) {
    try {
      const result = await readMeshFile_default(webWorker, file);
      return result;
    } catch (unused) {
      if (webWorker != null) {
        webWorker.terminate();
      }
      return await readImageFile_default(null, file);
    }
  } else {
    return await readImageFile_default(webWorker, file);
  }
}
var readFile_default = readFile;

// node_modules/itk-wasm/dist/io/readImageHTTP.js
var import_axios2 = __toESM(require_axios2(), 1);
async function readImageHTTP(url) {
  const imageResponse = await import_axios2.default.get(`${url}/index.json`, { responseType: "json" });
  const image = imageResponse.data;
  const dataResponse = await import_axios2.default.get(`${url}/data/data.raw`, { responseType: "arraybuffer" });
  image.data = bufferToTypedArray_default(image.imageType.componentType, dataResponse.data);
  const directionResponse = await import_axios2.default.get(`${url}/data/direction.raw`, { responseType: "arraybuffer" });
  image.direction = bufferToTypedArray_default(FloatTypes_default.Float64, directionResponse.data);
  return image;
}
var readImageHTTP_default = readImageHTTP;

// node_modules/itk-wasm/dist/io/readDICOMTags.js
var import_promise_file_reader6 = __toESM(require_PromiseFileReader(), 1);

// node_modules/itk-wasm/dist/io/readDICOMTagsArrayBuffer.js
async function readDICOMTagsArrayBuffer(webWorker, arrayBuffer, tags = null) {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const dataArray = new Uint8Array(arrayBuffer);
  const path = "./file.dcm";
  const args = [path, "0", "--memory-io"];
  const inputs = [
    { type: InterfaceTypes_default.BinaryFile, data: { data: dataArray, path } }
  ];
  if (tags != null) {
    args.push("--tags-to-read");
    args.push("1");
    inputs.push({ type: InterfaceTypes_default.TextStream, data: { data: JSON.stringify({ tags }) } });
  }
  const outputs = [
    { type: InterfaceTypes_default.TextStream }
  ];
  const result = await webworkerPromise.postMessage({
    operation: "readDICOMTags",
    config: itkConfig_default,
    pipelinePath: "ReadDICOMTags",
    args,
    outputs,
    inputs
  }, [arrayBuffer]);
  const tagsJSON = result.outputs[0].data.data;
  const tagsResult = JSON.parse(tagsJSON);
  const tagsMap = new Map(tagsResult.tags);
  return { tags: tagsMap, webWorker: worker };
}
var readDICOMTagsArrayBuffer_default = readDICOMTagsArrayBuffer;

// node_modules/itk-wasm/dist/io/readDICOMTags.js
async function readDICOMTags(webWorker, file, tags = null) {
  const arrayBuffer = await (0, import_promise_file_reader6.readAsArrayBuffer)(file);
  return await readDICOMTagsArrayBuffer_default(webWorker, arrayBuffer, tags);
}
var readDICOMTags_default = readDICOMTags;

// node_modules/itk-wasm/dist/io/readImageDICOMFileSeries.js
var import_promise_file_reader7 = __toESM(require_PromiseFileReader(), 1);

// node_modules/itk-wasm/dist/io/readImageDICOMArrayBufferSeries.js
var _a2;
var workerFunction = async (webWorker, fileDescriptions, singleSortedSeries = false) => {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const args = ["--memory-io", "--output-image", "0", "--output-filenames", "1", "--input-images"];
  fileDescriptions.forEach((desc) => {
    args.push(`./${desc.path}`);
  });
  if (singleSortedSeries) {
    args.push("--single-sorted-series");
  }
  const outputs = [
    { type: InterfaceTypes_default.Image },
    { type: InterfaceTypes_default.TextStream }
  ];
  const inputs = fileDescriptions.map((fd) => {
    return { type: InterfaceTypes_default.BinaryFile, data: fd };
  });
  const transferables = fileDescriptions.map((description) => {
    return description.data.buffer;
  });
  const message = {
    operation: "readDICOMImageSeries",
    config: itkConfig_default,
    fileDescriptions,
    singleSortedSeries,
    pipelinePath: "ReadDICOMImageFileSeries",
    args,
    outputs,
    inputs
  };
  const result = await webworkerPromise.postMessage(message, transferables);
  const image = result.outputs[0].data;
  const filenames = result.outputs[1].data.data.split("\0");
  filenames === null || filenames === void 0 ? void 0 : filenames.pop();
  if (image.metadata === void 0) {
    const metadata = {};
    metadata.orderedFileNames = filenames;
    image.metadata = metadata;
  } else {
    image.metadata.orderedFileNames = filenames;
  }
  return { image: result.outputs[0].data, webWorker: worker };
};
var numberOfWorkers2 = typeof ((_a2 = globalThis.navigator) === null || _a2 === void 0 ? void 0 : _a2.hardwareConcurrency) === "number" ? globalThis.navigator.hardwareConcurrency : 4;
var workerPool2 = new WorkerPool_default(numberOfWorkers2, workerFunction);
var seriesBlockSize = 8;
var readImageDICOMArrayBufferSeries = async (arrayBuffers, singleSortedSeries = false, fileNames) => {
  const validFileNames = fileNames != null && fileNames.length === arrayBuffers.length;
  const fileDescriptions = arrayBuffers.map((ab, index) => {
    return { path: validFileNames ? fileNames[index] : `${index}.dcm`, data: new Uint8Array(ab) };
  });
  if (singleSortedSeries) {
    const taskArgsArray = [];
    for (let index = 0; index < fileDescriptions.length; index += seriesBlockSize) {
      const block = fileDescriptions.slice(index, index + seriesBlockSize);
      taskArgsArray.push([block, singleSortedSeries]);
    }
    const results = await workerPool2.runTasks(taskArgsArray).promise;
    const images = results.map((result) => result.image);
    const stacked = stackImages_default(images);
    return { image: stacked, webWorkerPool: workerPool2 };
  } else {
    const taskArgsArray = [[fileDescriptions, singleSortedSeries]];
    const results = await workerPool2.runTasks(taskArgsArray).promise;
    return { image: results[0].image, webWorkerPool: workerPool2 };
  }
};
var readImageDICOMArrayBufferSeries_default = readImageDICOMArrayBufferSeries;

// node_modules/itk-wasm/dist/io/readImageDICOMFileSeries.js
var readImageDICOMFileSeries = async (fileList, singleSortedSeries = false) => {
  const fetchFileContents = Array.from(fileList, async function(file) {
    return await (0, import_promise_file_reader7.readAsArrayBuffer)(file);
  });
  const fileContents = await Promise.all(fetchFileContents);
  const fileNames = Array.from(fileList, (file) => file.name);
  return await readImageDICOMArrayBufferSeries_default(fileContents, singleSortedSeries, fileNames);
};
var readImageDICOMFileSeries_default = readImageDICOMFileSeries;

// node_modules/itk-wasm/dist/core/getTransferable.js
var haveSharedArrayBuffer2 = typeof globalThis.SharedArrayBuffer === "function";
function getTransferable(data) {
  let result = null;
  if (data.buffer !== void 0) {
    result = data.buffer;
  } else if (data.byteLength !== void 0) {
    result = data;
  }
  if (!!result && haveSharedArrayBuffer2 && result instanceof SharedArrayBuffer) {
    return null;
  }
  return result;
}
var getTransferable_default = getTransferable;

// node_modules/itk-wasm/dist/io/writeImageArrayBuffer.js
async function writeImageArrayBuffer(webWorker, image, fileName, mimeType = "", useCompression = false) {
  if (typeof image === "boolean") {
    throw new Error("useCompression is now at the last argument position in itk-wasm");
  }
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const filePath = `./${fileName}`;
  const args = ["0", filePath, "--memory-io", "--quiet"];
  if (useCompression) {
    args.push("--use-compression");
  }
  const outputs = [
    { data: { path: filePath }, type: InterfaceTypes_default.BinaryFile }
  ];
  const inputs = [
    { type: InterfaceTypes_default.Image, data: image }
  ];
  const transferables = [];
  let transferable = getTransferable_default(image.data);
  if (transferable != null) {
    transferables.push(transferable);
  }
  transferable = getTransferable_default(image.direction);
  if (transferable != null) {
    transferables.push(transferable);
  }
  const result = await webworkerPromise.postMessage({
    operation: "writeImage",
    config: itkConfig_default,
    mimeType,
    fileName,
    pipelinePath: "WriteImage",
    args,
    outputs,
    inputs
  }, transferables);
  return { arrayBuffer: result.outputs[0].data.data.buffer, webWorker: worker };
}
var writeImageArrayBuffer_default = writeImageArrayBuffer;

// node_modules/itk-wasm/dist/core/internal/meshTransferables.js
function meshTransferables(mesh) {
  const transferables = [];
  if (mesh.points != null) {
    transferables.push(mesh.points.buffer);
  }
  if (mesh.pointData != null) {
    transferables.push(mesh.pointData.buffer);
  }
  if (mesh.cells != null) {
    transferables.push(mesh.cells.buffer);
  }
  if (mesh.cellData != null) {
    transferables.push(mesh.cellData.buffer);
  }
  return transferables;
}
var meshTransferables_default = meshTransferables;

// node_modules/itk-wasm/dist/io/writeMeshArrayBuffer.js
async function writeMeshArrayBuffer(webWorker, mesh, fileName, mimeType, options) {
  if ("useCompression" in mesh || "binaryFileType" in mesh) {
    throw new Error("options are now in the last argument position in itk-wasm");
  }
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const filePath = `./${fileName}`;
  const args = ["0", filePath, "--memory-io", "--quiet"];
  if ((options === null || options === void 0 ? void 0 : options.useCompression) === true) {
    args.push("--use-compression");
  }
  if ((options === null || options === void 0 ? void 0 : options.binaryFileType) === true) {
    args.push("--binary-file-type");
  }
  const outputs = [
    { data: { path: filePath }, type: InterfaceTypes_default.BinaryFile }
  ];
  const inputs = [
    { type: InterfaceTypes_default.Mesh, data: mesh }
  ];
  const transferables = meshTransferables_default(mesh);
  const result = await webworkerPromise.postMessage({
    operation: "writeMesh",
    config: itkConfig_default,
    mimeType,
    fileName,
    pipelinePath: "WriteMesh",
    args,
    outputs,
    inputs
  }, transferables);
  return { arrayBuffer: result.outputs[0].data.data.buffer, webWorker: worker };
}
var writeMeshArrayBuffer_default = writeMeshArrayBuffer;

// node_modules/itk-wasm/dist/io/writeArrayBuffer.js
async function writeArrayBuffer(webWorker, imageOrMesh, fileName, mimeType = "", useCompression = false) {
  if (typeof imageOrMesh === "boolean") {
    throw new Error("useCompression is now the argument position in itk-wasm");
  }
  const extension = getFileExtension_default(fileName);
  const isMesh = !!extensionToMeshIO_default.has(extension) || !!MimeToMeshIO_default.has(mimeType);
  if (isMesh) {
    return await writeMeshArrayBuffer_default(webWorker, imageOrMesh, fileName, mimeType, { useCompression }).catch(async function() {
      if (webWorker != null) {
        webWorker.terminate();
      }
      return await writeImageArrayBuffer_default(null, imageOrMesh, fileName, mimeType, useCompression);
    });
  } else {
    return await writeImageArrayBuffer_default(webWorker, imageOrMesh, fileName, mimeType, useCompression);
  }
}
var writeArrayBuffer_default = writeArrayBuffer;

// node_modules/itk-wasm/dist/io/meshToPolyData.js
async function meshToPolyData(webWorker, mesh) {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const args = ["0", "0", "--memory-io"];
  const outputs = [
    { type: InterfaceTypes_default.PolyData }
  ];
  const inputs = [
    { type: InterfaceTypes_default.Mesh, data: mesh }
  ];
  const transferables = meshTransferables_default(mesh);
  const result = await webworkerPromise.postMessage({
    operation: "meshToPolyData",
    config: itkConfig_default,
    pipelinePath: "MeshToPolyData",
    args,
    outputs,
    inputs
  }, transferables);
  return { polyData: result.outputs[0].data, webWorker: worker };
}
var meshToPolyData_default = meshToPolyData;

// node_modules/itk-wasm/dist/core/internal/polyDataTransferables.js
function polyDataTransferables(polyData) {
  const transferables = [];
  if (polyData.points != null) {
    transferables.push(polyData.points.buffer);
  }
  if (polyData.vertices != null) {
    transferables.push(polyData.vertices.buffer);
  }
  if (polyData.lines != null) {
    transferables.push(polyData.lines.buffer);
  }
  if (polyData.polygons != null) {
    transferables.push(polyData.polygons.buffer);
  }
  if (polyData.triangleStrips != null) {
    transferables.push(polyData.triangleStrips.buffer);
  }
  if (polyData.pointData != null) {
    transferables.push(polyData.pointData.buffer);
  }
  if (polyData.cellData != null) {
    transferables.push(polyData.cellData.buffer);
  }
  return transferables;
}
var polyDataTransferables_default = polyDataTransferables;

// node_modules/itk-wasm/dist/io/polyDataToMesh.js
async function polyDataToMesh(webWorker, polyData) {
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const args = ["0", "0", "--memory-io"];
  const outputs = [
    { type: InterfaceTypes_default.Mesh }
  ];
  const inputs = [
    { type: InterfaceTypes_default.PolyData, data: polyData }
  ];
  const transferables = polyDataTransferables_default(polyData);
  const result = await webworkerPromise.postMessage({
    operation: "polyDataToMesh",
    config: itkConfig_default,
    pipelinePath: "PolyDataToMesh",
    args,
    outputs,
    inputs
  }, transferables);
  return { mesh: result.outputs[0].data, webWorker: worker };
}
var polyDataToMesh_default = polyDataToMesh;

// node_modules/itk-wasm/dist/core/internal/loadEmscriptenModuleMainThread.js
var import_axios3 = __toESM(require_axios2(), 1);
async function loadEmscriptenModuleMainThread(moduleRelativePathOrURL, baseUrl) {
  let modulePrefix = "unknown";
  if (typeof moduleRelativePathOrURL !== "string") {
    modulePrefix = moduleRelativePathOrURL.href;
  } else if (moduleRelativePathOrURL.startsWith("http")) {
    modulePrefix = moduleRelativePathOrURL;
  } else {
    modulePrefix = `${baseUrl}/${moduleRelativePathOrURL}`;
  }
  if (modulePrefix.endsWith(".js")) {
    modulePrefix = modulePrefix.substring(0, modulePrefix.length - 3);
  }
  if (modulePrefix.endsWith(".wasm")) {
    modulePrefix = modulePrefix.substring(0, modulePrefix.length - 5);
  }
  const wasmBinaryPath = `${modulePrefix}.wasm`;
  const response = await import_axios3.default.get(wasmBinaryPath, { responseType: "arraybuffer" });
  const wasmBinary = response.data;
  const fullModulePath = `${modulePrefix}.js`;
  const result = await import(
    /* webpackIgnore: true */
    fullModulePath
  );
  const instantiated = result.default({ wasmBinary });
  return instantiated;
}
var loadEmscriptenModuleMainThread_default = loadEmscriptenModuleMainThread;

// node_modules/itk-wasm/dist/pipeline/internal/runPipelineEmscripten.js
var haveSharedArrayBuffer3 = typeof globalThis.SharedArrayBuffer === "function";
var encoder = new TextEncoder();
var decoder = new TextDecoder("utf-8");
function readFileSharedArray(emscriptenModule, path) {
  const opts = { flags: "r", encoding: "binary" };
  const stream = emscriptenModule.fs_open(path, opts.flags);
  const stat = emscriptenModule.fs_stat(path);
  const length = stat.size;
  let arrayBufferData = null;
  if (haveSharedArrayBuffer3) {
    arrayBufferData = new SharedArrayBuffer(length);
  } else {
    arrayBufferData = new ArrayBuffer(length);
  }
  const array = new Uint8Array(arrayBufferData);
  emscriptenModule.fs_read(stream, array, 0, length, 0);
  emscriptenModule.fs_close(stream);
  return array;
}
function memoryUint8SharedArray(emscriptenModule, byteOffset, length) {
  let arrayBufferData = null;
  if (haveSharedArrayBuffer3) {
    arrayBufferData = new SharedArrayBuffer(length);
  } else {
    arrayBufferData = new ArrayBuffer(length);
  }
  const array = new Uint8Array(arrayBufferData);
  const dataArrayView = new Uint8Array(emscriptenModule.HEAPU8.buffer, byteOffset, length);
  array.set(dataArrayView);
  return array;
}
function setPipelineModuleInputArray(emscriptenModule, dataArray, inputIndex, subIndex) {
  let dataPtr = 0;
  if (dataArray !== null) {
    dataPtr = emscriptenModule.ccall("itk_wasm_input_array_alloc", "number", ["number", "number", "number", "number"], [0, inputIndex, subIndex, dataArray.buffer.byteLength]);
    emscriptenModule.HEAPU8.set(new Uint8Array(dataArray.buffer), dataPtr);
  }
  return dataPtr;
}
function setPipelineModuleInputJSON(emscriptenModule, dataObject, inputIndex) {
  const dataJSON = JSON.stringify(dataObject);
  const jsonPtr = emscriptenModule.ccall("itk_wasm_input_json_alloc", "number", ["number", "number", "number"], [0, inputIndex, dataJSON.length]);
  emscriptenModule.writeAsciiToMemory(dataJSON, jsonPtr, false);
}
function getPipelineModuleOutputArray(emscriptenModule, outputIndex, subIndex, componentType) {
  const dataPtr = emscriptenModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, outputIndex, subIndex]);
  const dataSize = emscriptenModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, outputIndex, subIndex]);
  const dataUint8 = memoryUint8SharedArray(emscriptenModule, dataPtr, dataSize);
  const data = bufferToTypedArray_default(componentType, dataUint8.buffer);
  return data;
}
function getPipelineModuleOutputJSON(emscriptenModule, outputIndex) {
  const jsonPtr = emscriptenModule.ccall("itk_wasm_output_json_address", "number", ["number", "number"], [0, outputIndex]);
  const dataJSON = emscriptenModule.AsciiToString(jsonPtr);
  const dataObject = JSON.parse(dataJSON);
  return dataObject;
}
function runPipelineEmscripten(pipelineModule, args, outputs, inputs) {
  if (!(inputs == null) && inputs.length > 0) {
    inputs.forEach(function(input, index) {
      switch (input.type) {
        case InterfaceTypes_default.TextStream: {
          const dataArray = encoder.encode(input.data.data);
          const arrayPtr = setPipelineModuleInputArray(pipelineModule, dataArray, index, 0);
          const dataJSON = { size: dataArray.buffer.byteLength, data: `data:application/vnd.itk.address,0:${arrayPtr}` };
          setPipelineModuleInputJSON(pipelineModule, dataJSON, index);
          break;
        }
        case InterfaceTypes_default.BinaryStream: {
          const dataArray = input.data.data;
          const arrayPtr = setPipelineModuleInputArray(pipelineModule, dataArray, index, 0);
          const dataJSON = { size: dataArray.buffer.byteLength, data: `data:application/vnd.itk.address,0:${arrayPtr}` };
          setPipelineModuleInputJSON(pipelineModule, dataJSON, index);
          break;
        }
        case InterfaceTypes_default.TextFile: {
          pipelineModule.fs_writeFile(input.data.path, input.data.data);
          break;
        }
        case InterfaceTypes_default.BinaryFile: {
          pipelineModule.fs_writeFile(input.data.path, input.data.data);
          break;
        }
        case InterfaceTypes_default.Image: {
          const image = input.data;
          const dataPtr = setPipelineModuleInputArray(pipelineModule, image.data, index, 0);
          const directionPtr = setPipelineModuleInputArray(pipelineModule, image.direction, index, 1);
          const imageJSON = {
            imageType: image.imageType,
            name: image.name,
            origin: image.origin,
            spacing: image.spacing,
            direction: `data:application/vnd.itk.address,0:${directionPtr}`,
            size: image.size,
            data: `data:application/vnd.itk.address,0:${dataPtr}`
          };
          setPipelineModuleInputJSON(pipelineModule, imageJSON, index);
          break;
        }
        case InterfaceTypes_default.Mesh: {
          const mesh = input.data;
          const pointsPtr = setPipelineModuleInputArray(pipelineModule, mesh.points, index, 0);
          const cellsPtr = setPipelineModuleInputArray(pipelineModule, mesh.cells, index, 1);
          const pointDataPtr = setPipelineModuleInputArray(pipelineModule, mesh.pointData, index, 2);
          const cellDataPtr = setPipelineModuleInputArray(pipelineModule, mesh.pointData, index, 3);
          const meshJSON = {
            meshType: mesh.meshType,
            name: mesh.name,
            numberOfPoints: mesh.numberOfPoints,
            points: `data:application/vnd.itk.address,0:${pointsPtr}`,
            numberOfCells: mesh.numberOfCells,
            cells: `data:application/vnd.itk.address,0:${cellsPtr}`,
            cellBufferSize: mesh.cellBufferSize,
            numberOfPointPixels: mesh.numberOfPointPixels,
            pointData: `data:application/vnd.itk.address,0:${pointDataPtr}`,
            numberOfCellPixels: mesh.numberOfCellPixels,
            cellData: `data:application/vnd.itk.address,0:${cellDataPtr}`
          };
          setPipelineModuleInputJSON(pipelineModule, meshJSON, index);
          break;
        }
        case InterfaceTypes_default.PolyData: {
          const polyData = input.data;
          const pointsPtr = setPipelineModuleInputArray(pipelineModule, polyData.points, index, 0);
          const verticesPtr = setPipelineModuleInputArray(pipelineModule, polyData.vertices, index, 1);
          const linesPtr = setPipelineModuleInputArray(pipelineModule, polyData.lines, index, 2);
          const polygonsPtr = setPipelineModuleInputArray(pipelineModule, polyData.polygons, index, 3);
          const triangleStripsPtr = setPipelineModuleInputArray(pipelineModule, polyData.triangleStrips, index, 4);
          const pointDataPtr = setPipelineModuleInputArray(pipelineModule, polyData.pointData, index, 5);
          const cellDataPtr = setPipelineModuleInputArray(pipelineModule, polyData.pointData, index, 6);
          const polyDataJSON = {
            polyDataType: polyData.polyDataType,
            name: polyData.name,
            numberOfPoints: polyData.numberOfPoints,
            points: `data:application/vnd.itk.address,0:${pointsPtr}`,
            verticesBufferSize: polyData.verticesBufferSize,
            vertices: `data:application/vnd.itk.address,0:${verticesPtr}`,
            linesBufferSize: polyData.linesBufferSize,
            lines: `data:application/vnd.itk.address,0:${linesPtr}`,
            polygonsBufferSize: polyData.polygonsBufferSize,
            polygons: `data:application/vnd.itk.address,0:${polygonsPtr}`,
            triangleStripsBufferSize: polyData.triangleStripsBufferSize,
            triangleStrips: `data:application/vnd.itk.address,0:${triangleStripsPtr}`,
            numberOfPointPixels: polyData.numberOfPointPixels,
            pointData: `data:application/vnd.itk.address,0:${pointDataPtr}`,
            numberOfCellPixels: polyData.numberOfCellPixels,
            cellData: `data:application/vnd.itk.address,0:${cellDataPtr}`
          };
          setPipelineModuleInputJSON(pipelineModule, polyDataJSON, index);
          break;
        }
        case IOTypes_default.Text: {
          pipelineModule.fs_writeFile(input.path, input.data);
          break;
        }
        case IOTypes_default.Binary: {
          pipelineModule.fs_writeFile(input.path, input.data);
          break;
        }
        case IOTypes_default.Image: {
          const image = input.data;
          const imageJSON = {
            imageType: image.imageType,
            name: image.name,
            origin: image.origin,
            spacing: image.spacing,
            direction: "data:application/vnd.itk.path,data/direction.raw",
            size: image.size,
            data: "data:application/vnd.itk.path,data/data.raw"
          };
          pipelineModule.fs_mkdirs(`${input.path}/data`);
          pipelineModule.fs_writeFile(`${input.path}/index.json`, JSON.stringify(imageJSON));
          if (image.data === null) {
            throw Error("image.data is null");
          }
          pipelineModule.fs_writeFile(`${input.path}/data/data.raw`, new Uint8Array(image.data.buffer));
          pipelineModule.fs_writeFile(`${input.path}/data/direction.raw`, new Uint8Array(image.direction.buffer));
          break;
        }
        case IOTypes_default.Mesh: {
          const mesh = input.data;
          const meshJSON = {
            meshType: mesh.meshType,
            name: mesh.name,
            numberOfPoints: mesh.numberOfPoints,
            points: "data:application/vnd.itk.path,data/points.raw",
            numberOfPointPixels: mesh.numberOfPointPixels,
            pointData: "data:application/vnd.itk.path,data/pointData.raw",
            numberOfCells: mesh.numberOfCells,
            cells: "data:application/vnd.itk.path,data/cells.raw",
            numberOfCellPixels: mesh.numberOfCellPixels,
            cellData: "data:application/vnd.itk.path,data/cellData.raw",
            cellBufferSize: mesh.cellBufferSize
          };
          pipelineModule.fs_mkdirs(`${input.path}/data`);
          pipelineModule.fs_writeFile(`${input.path}/index.json`, JSON.stringify(meshJSON));
          if (meshJSON.numberOfPoints > 0) {
            if (mesh.points === null) {
              throw Error("mesh.points is null");
            }
            pipelineModule.fs_writeFile(`${input.path}/data/points.raw`, new Uint8Array(mesh.points.buffer));
          }
          if (meshJSON.numberOfPointPixels > 0) {
            if (mesh.pointData === null) {
              throw Error("mesh.pointData is null");
            }
            pipelineModule.fs_writeFile(`${input.path}/data/pointData.raw`, new Uint8Array(mesh.pointData.buffer));
          }
          if (meshJSON.numberOfCells > 0) {
            if (mesh.cells === null) {
              throw Error("mesh.cells is null");
            }
            pipelineModule.fs_writeFile(`${input.path}/data/cells.raw`, new Uint8Array(mesh.cells.buffer));
          }
          if (meshJSON.numberOfCellPixels > 0) {
            if (mesh.cellData === null) {
              throw Error("mesh.cellData is null");
            }
            pipelineModule.fs_writeFile(`${input.path}/data/cellData.raw`, new Uint8Array(mesh.cellData.buffer));
          }
          break;
        }
        default:
          throw Error("Unsupported input InterfaceType");
      }
    });
  }
  pipelineModule.resetModuleStdout();
  pipelineModule.resetModuleStderr();
  let returnValue = 0;
  try {
    returnValue = pipelineModule.callMain(args);
  } catch (exception) {
    if (typeof exception === "number") {
      console.log("Exception while running pipeline:");
      console.log("stdout:", pipelineModule.getModuleStdout());
      console.error("stderr:", pipelineModule.getModuleStderr());
      if (typeof pipelineModule.getExceptionMessage !== "undefined") {
        console.error("exception:", pipelineModule.getExceptionMessage(exception));
      } else {
        console.error("Build module in Debug mode for exception message information.");
      }
    }
    throw exception;
  }
  const stdout = pipelineModule.getModuleStdout();
  const stderr = pipelineModule.getModuleStderr();
  const populatedOutputs = [];
  if (!(outputs == null) && outputs.length > 0 && returnValue === 0) {
    outputs.forEach(function(output, index) {
      let outputData = null;
      switch (output.type) {
        case InterfaceTypes_default.TextStream: {
          const dataPtr = pipelineModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, index, 0]);
          const dataSize = pipelineModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, index, 0]);
          const dataArrayView = new Uint8Array(pipelineModule.HEAPU8.buffer, dataPtr, dataSize);
          outputData = { data: decoder.decode(dataArrayView) };
          break;
        }
        case InterfaceTypes_default.BinaryStream: {
          const dataPtr = pipelineModule.ccall("itk_wasm_output_array_address", "number", ["number", "number", "number"], [0, index, 0]);
          const dataSize = pipelineModule.ccall("itk_wasm_output_array_size", "number", ["number", "number", "number"], [0, index, 0]);
          outputData = { data: memoryUint8SharedArray(pipelineModule, dataPtr, dataSize) };
          break;
        }
        case InterfaceTypes_default.TextFile: {
          outputData = { path: output.data.path, data: pipelineModule.fs_readFile(output.data.path, { encoding: "utf8" }) };
          break;
        }
        case InterfaceTypes_default.BinaryFile: {
          outputData = { path: output.data.path, data: readFileSharedArray(pipelineModule, output.data.path) };
          break;
        }
        case InterfaceTypes_default.Image: {
          const image = getPipelineModuleOutputJSON(pipelineModule, index);
          image.data = getPipelineModuleOutputArray(pipelineModule, index, 0, image.imageType.componentType);
          image.direction = getPipelineModuleOutputArray(pipelineModule, index, 1, FloatTypes_default.Float64);
          outputData = image;
          break;
        }
        case InterfaceTypes_default.Mesh: {
          const mesh = getPipelineModuleOutputJSON(pipelineModule, index);
          if (mesh.numberOfPoints > 0) {
            mesh.points = getPipelineModuleOutputArray(pipelineModule, index, 0, mesh.meshType.pointComponentType);
          } else {
            mesh.points = bufferToTypedArray_default(mesh.meshType.pointComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCells > 0) {
            mesh.cells = getPipelineModuleOutputArray(pipelineModule, index, 1, mesh.meshType.cellComponentType);
          } else {
            mesh.cells = bufferToTypedArray_default(mesh.meshType.cellComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfPointPixels > 0) {
            mesh.pointData = getPipelineModuleOutputArray(pipelineModule, index, 2, mesh.meshType.pointPixelComponentType);
          } else {
            mesh.pointData = bufferToTypedArray_default(mesh.meshType.pointPixelComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCellPixels > 0) {
            mesh.cellData = getPipelineModuleOutputArray(pipelineModule, index, 3, mesh.meshType.cellPixelComponentType);
          } else {
            mesh.cellData = bufferToTypedArray_default(mesh.meshType.cellPixelComponentType, new ArrayBuffer(0));
          }
          outputData = mesh;
          break;
        }
        case InterfaceTypes_default.PolyData: {
          const polyData = getPipelineModuleOutputJSON(pipelineModule, index);
          if (polyData.numberOfPoints > 0) {
            polyData.points = getPipelineModuleOutputArray(pipelineModule, index, 0, FloatTypes_default.Float32);
          } else {
            polyData.points = new Float32Array();
          }
          if (polyData.verticesBufferSize > 0) {
            polyData.vertices = getPipelineModuleOutputArray(pipelineModule, index, 1, IntTypes_default.UInt32);
          } else {
            polyData.vertices = new Uint32Array();
          }
          if (polyData.linesBufferSize > 0) {
            polyData.lines = getPipelineModuleOutputArray(pipelineModule, index, 2, IntTypes_default.UInt32);
          } else {
            polyData.lines = new Uint32Array();
          }
          if (polyData.polygonsBufferSize > 0) {
            polyData.polygons = getPipelineModuleOutputArray(pipelineModule, index, 3, IntTypes_default.UInt32);
          } else {
            polyData.polygons = new Uint32Array();
          }
          if (polyData.triangleStripsBufferSize > 0) {
            polyData.triangleStrips = getPipelineModuleOutputArray(pipelineModule, index, 4, IntTypes_default.UInt32);
          } else {
            polyData.triangleStrips = new Uint32Array();
          }
          if (polyData.numberOfPointPixels > 0) {
            polyData.pointData = getPipelineModuleOutputArray(pipelineModule, index, 5, polyData.polyDataType.pointPixelComponentType);
          } else {
            polyData.pointData = bufferToTypedArray_default(polyData.polyDataType.pointPixelComponentType, new ArrayBuffer(0));
          }
          if (polyData.numberOfCellPixels > 0) {
            polyData.cellData = getPipelineModuleOutputArray(pipelineModule, index, 6, polyData.polyDataType.cellPixelComponentType);
          } else {
            polyData.cellData = bufferToTypedArray_default(polyData.polyDataType.cellPixelComponentType, new ArrayBuffer(0));
          }
          outputData = polyData;
          break;
        }
        case IOTypes_default.Text: {
          if (typeof output.path === "undefined") {
            throw new Error("output.path not defined");
          }
          outputData = pipelineModule.fs_readFile(output.path, { encoding: "utf8" });
          break;
        }
        case IOTypes_default.Binary: {
          if (typeof output.path === "undefined") {
            throw new Error("output.path not defined");
          }
          outputData = readFileSharedArray(pipelineModule, output.path);
          break;
        }
        case IOTypes_default.Image: {
          if (typeof output.path === "undefined") {
            throw new Error("output.path not defined");
          }
          const imageJSON = pipelineModule.fs_readFile(`${output.path}/index.json`, { encoding: "utf8" });
          const image = JSON.parse(imageJSON);
          const dataUint8 = readFileSharedArray(pipelineModule, `${output.path}/data/data.raw`);
          image.data = bufferToTypedArray_default(image.imageType.componentType, dataUint8.buffer);
          const directionUint8 = readFileSharedArray(pipelineModule, `${output.path}/data/direction.raw`);
          image.direction = bufferToTypedArray_default(FloatTypes_default.Float64, directionUint8.buffer);
          outputData = image;
          break;
        }
        case IOTypes_default.Mesh: {
          if (typeof output.path === "undefined") {
            throw new Error("output.path not defined");
          }
          const meshJSON = pipelineModule.fs_readFile(`${output.path}/index.json`, { encoding: "utf8" });
          const mesh = JSON.parse(meshJSON);
          if (mesh.numberOfPoints > 0) {
            const dataUint8Points = readFileSharedArray(pipelineModule, `${output.path}/data/points.raw`);
            mesh.points = bufferToTypedArray_default(mesh.meshType.pointComponentType, dataUint8Points.buffer);
          } else {
            mesh.points = bufferToTypedArray_default(mesh.meshType.pointComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfPointPixels > 0) {
            const dataUint8PointData = readFileSharedArray(pipelineModule, `${output.path}/data/pointData.raw`);
            mesh.pointData = bufferToTypedArray_default(mesh.meshType.pointPixelComponentType, dataUint8PointData.buffer);
          } else {
            mesh.pointData = bufferToTypedArray_default(mesh.meshType.pointPixelComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCells > 0) {
            const dataUint8Cells = readFileSharedArray(pipelineModule, `${output.path}/data/cells.raw`);
            mesh.cells = bufferToTypedArray_default(mesh.meshType.cellComponentType, dataUint8Cells.buffer);
          } else {
            mesh.cells = bufferToTypedArray_default(mesh.meshType.cellComponentType, new ArrayBuffer(0));
          }
          if (mesh.numberOfCellPixels > 0) {
            const dataUint8CellData = readFileSharedArray(pipelineModule, `${output.path}/data/cellData.raw`);
            mesh.cellData = bufferToTypedArray_default(mesh.meshType.cellPixelComponentType, dataUint8CellData.buffer);
          } else {
            mesh.cellData = bufferToTypedArray_default(mesh.meshType.cellPixelComponentType, new ArrayBuffer(0));
          }
          outputData = mesh;
          break;
        }
        default:
          throw Error("Unsupported output InterfaceType");
      }
      const populatedOutput = {
        type: output.type,
        data: outputData
      };
      populatedOutputs.push(populatedOutput);
    });
  }
  return { returnValue, stdout, stderr, outputs: populatedOutputs };
}
var runPipelineEmscripten_default = runPipelineEmscripten;

// node_modules/itk-wasm/dist/pipeline/runPipeline.js
var pipelineToModule = /* @__PURE__ */ new Map();
async function loadPipelineModule(pipelinePath) {
  let moduleRelativePathOrURL = pipelinePath;
  let pipeline = pipelinePath;
  if (typeof pipelinePath !== "string") {
    moduleRelativePathOrURL = new URL(pipelinePath.href);
    pipeline = moduleRelativePathOrURL.href;
  }
  if (pipelineToModule.has(pipeline)) {
    return pipelineToModule.get(pipeline);
  } else {
    const pipelineModule = await loadEmscriptenModuleMainThread_default(pipelinePath, itkConfig_default.pipelinesUrl);
    pipelineToModule.set(pipeline, pipelineModule);
    return pipelineModule;
  }
}
async function runPipeline(webWorker, pipelinePath, args, outputs, inputs) {
  if (webWorker === false) {
    const pipelineModule = await loadPipelineModule(pipelinePath.toString());
    const result2 = runPipelineEmscripten_default(pipelineModule, args, outputs, inputs);
    return result2;
  }
  let worker = webWorker;
  const { webworkerPromise, worker: usedWorker } = await createWebWorkerPromise_default(worker);
  worker = usedWorker;
  const transferables = [];
  if (!(inputs == null) && inputs.length > 0) {
    inputs.forEach(function(input) {
      if (input.type === InterfaceTypes_default.BinaryStream) {
        const dataArray = input.data.data;
        const transferable = getTransferable_default(dataArray);
        if (transferable != null) {
          transferables.push(transferable);
        }
      } else if (input.type === InterfaceTypes_default.BinaryFile) {
        const dataArray = input.data.data;
        const transferable = getTransferable_default(dataArray);
        if (transferable != null) {
          transferables.push(transferable);
        }
      } else if (input.type === InterfaceTypes_default.Image) {
        const image = input.data;
        if (image.data === null) {
          throw Error("image data cannot be null");
        }
        let transferable = getTransferable_default(image.data);
        if (transferable != null) {
          transferables.push(transferable);
        }
        transferable = getTransferable_default(image.direction);
        if (transferable != null) {
          transferables.push(transferable);
        }
      } else if (input.type === IOTypes_default.Binary) {
        const transferable = getTransferable_default(input.data);
        if (transferable != null) {
          transferables.push(transferable);
        }
      } else if (input.type === IOTypes_default.Image) {
        const image = input.data;
        if (image.data === null) {
          throw Error("image data cannot be null");
        }
        let transferable = getTransferable_default(image.data);
        if (transferable != null) {
          transferables.push(transferable);
        }
        transferable = getTransferable_default(image.direction);
        if (transferable != null) {
          transferables.push(transferable);
        }
      } else if (input.type === IOTypes_default.Mesh) {
        const mesh = input.data;
        if (mesh.points != null) {
          const transferable = getTransferable_default(mesh.points);
          if (transferable != null) {
            transferables.push(transferable);
          }
        }
        if (mesh.pointData != null) {
          const transferable = getTransferable_default(mesh.pointData);
          if (transferable != null) {
            transferables.push(transferable);
          }
        }
        if (mesh.cells != null) {
          const transferable = getTransferable_default(mesh.cells);
          if (transferable != null) {
            transferables.push(transferable);
          }
        }
        if (mesh.cellData != null) {
          const transferable = getTransferable_default(mesh.cellData);
          if (transferable != null) {
            transferables.push(transferable);
          }
        }
      }
    });
  }
  const result = await webworkerPromise.postMessage({
    operation: "runPipeline",
    config: itkConfig_default,
    pipelinePath: pipelinePath.toString(),
    args,
    outputs,
    inputs
  }, transferables);
  return { returnValue: result.returnValue, stdout: result.stdout, stderr: result.stderr, outputs: result.outputs, webWorker: worker };
}
var runPipeline_default = runPipeline;
export {
  FloatTypes_default as FloatTypes,
  IOTypes_default as IOTypes,
  Image_default as Image,
  ImageType_default as ImageType,
  IntTypes_default as IntTypes,
  InterfaceTypes_default as InterfaceTypes,
  Mesh_default as Mesh,
  MeshType_default as MeshType,
  PixelTypes_default as PixelTypes,
  PolyData_default as PolyData,
  PolyDataType_default as PolyDataType,
  WorkerPool_default as WorkerPool,
  bufferToTypedArray_default as bufferToTypedArray,
  copyImage_default as copyImage,
  extensionToImageIO_default as extensionToImageIO,
  extensionToMeshIO_default as extensionToMeshIO,
  getFileExtension_default as getFileExtension,
  getMatrixElement_default as getMatrixElement,
  imageSharedBufferOrCopy_default as imageSharedBufferOrCopy,
  meshToPolyData_default as meshToPolyData,
  polyDataToMesh_default as polyDataToMesh,
  readArrayBuffer_default as readArrayBuffer,
  readBlob_default as readBlob,
  readDICOMTags_default as readDICOMTags,
  readDICOMTagsArrayBuffer_default as readDICOMTagsArrayBuffer,
  readFile_default as readFile,
  readImageArrayBuffer_default as readImageArrayBuffer,
  readImageBlob_default as readImageBlob,
  readImageDICOMArrayBufferSeries_default as readImageDICOMArrayBufferSeries,
  readImageDICOMFileSeries_default as readImageDICOMFileSeries,
  readImageFile_default as readImageFile,
  readImageFileSeries_default as readImageFileSeries,
  readImageHTTP_default as readImageHTTP,
  readMeshArrayBuffer_default as readMeshArrayBuffer,
  readMeshBlob_default as readMeshBlob,
  readMeshFile_default as readMeshFile,
  runPipeline_default as runPipeline,
  runPipeline_default as runPipelineBrowser,
  setMatrixElement_default as setMatrixElement,
  stackImages_default as stackImages,
  writeArrayBuffer_default as writeArrayBuffer,
  writeImageArrayBuffer_default as writeImageArrayBuffer,
  writeMeshArrayBuffer_default as writeMeshArrayBuffer
};
//# sourceMappingURL=itk-wasm.js.map
