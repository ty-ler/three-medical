import {
  common_exports,
  esm_exports,
  init_esm,
  mat3_exports,
  mat4_exports,
  quat_exports,
  vec3_exports,
  vec4_exports
} from "./chunk-YGSKJKHH.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-QOVRSCHT.js";

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js
var Constants_exports = {};
__export(Constants_exports, {
  BlendMode: () => BlendMode,
  FilterMode: () => FilterMode,
  default: () => Constants
});
var BlendMode, FilterMode, Constants;
var init_Constants = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants.js"() {
    BlendMode = {
      COMPOSITE_BLEND: 0,
      MAXIMUM_INTENSITY_BLEND: 1,
      MINIMUM_INTENSITY_BLEND: 2,
      AVERAGE_INTENSITY_BLEND: 3,
      ADDITIVE_INTENSITY_BLEND: 4
    };
    FilterMode = {
      OFF: 0,
      NORMALIZED: 1,
      RAW: 2
    };
    Constants = {
      BlendMode,
      FilterMode
    };
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var init_arrayWithHoles = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
var init_iterableToArrayLimit = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var init_arrayLikeToArray = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
var init_unsupportedIterableToArray = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableRest = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/slicedToArray.js
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
var init_slicedToArray = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/slicedToArray.js"() {
    init_arrayWithHoles();
    init_iterableToArrayLimit();
    init_unsupportedIterableToArray();
    init_nonIterableRest();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj2) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj3) {
    return typeof obj3;
  } : function(obj3) {
    return obj3 && typeof Symbol == "function" && obj3.constructor === Symbol && obj3 !== Symbol.prototype ? "symbol" : typeof obj3;
  }, _typeof(obj2);
}
var init_typeof = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj2, key, value) {
  if (key in obj2) {
    Object.defineProperty(obj2, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj2[key] = value;
  }
  return obj2;
}
var init_defineProperty = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
var init_arrayWithoutHoles = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js"() {
    init_arrayLikeToArray();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
var init_iterableToArray = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/iterableToArray.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var init_nonIterableSpread = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
var init_toConsumableArray = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js"() {
    init_arrayWithoutHoles();
    init_iterableToArray();
    init_unsupportedIterableToArray();
    init_nonIterableSpread();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
var init_setPrototypeOf = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var init_isNativeReflectConstruct = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/construct.js
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
var init_construct = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/construct.js"() {
    init_setPrototypeOf();
    init_isNativeReflectConstruct();
  }
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/object-keys/isArguments.js"(exports, module) {
    "use strict";
    var toStr = Object.prototype.toString;
    module.exports = function isArguments(value) {
      var str = toStr.call(value);
      var isArgs = str === "[object Arguments]";
      if (!isArgs) {
        isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
      }
      return isArgs;
    };
  }
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS({
  "node_modules/object-keys/implementation.js"(exports, module) {
    "use strict";
    var keysShim;
    if (!Object.keys) {
      has = Object.prototype.hasOwnProperty;
      toStr = Object.prototype.toString;
      isArgs = require_isArguments();
      isEnumerable = Object.prototype.propertyIsEnumerable;
      hasDontEnumBug = !isEnumerable.call({ toString: null }, "toString");
      hasProtoEnumBug = isEnumerable.call(function() {
      }, "prototype");
      dontEnums = [
        "toString",
        "toLocaleString",
        "valueOf",
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable",
        "constructor"
      ];
      equalsConstructorPrototype = function(o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
      };
      excludedKeys = {
        $applicationCache: true,
        $console: true,
        $external: true,
        $frame: true,
        $frameElement: true,
        $frames: true,
        $innerHeight: true,
        $innerWidth: true,
        $onmozfullscreenchange: true,
        $onmozfullscreenerror: true,
        $outerHeight: true,
        $outerWidth: true,
        $pageXOffset: true,
        $pageYOffset: true,
        $parent: true,
        $scrollLeft: true,
        $scrollTop: true,
        $scrollX: true,
        $scrollY: true,
        $self: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $window: true
      };
      hasAutomationEqualityBug = function() {
        if (typeof window === "undefined") {
          return false;
        }
        for (var k in window) {
          try {
            if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
              try {
                equalsConstructorPrototype(window[k]);
              } catch (e) {
                return true;
              }
            }
          } catch (e) {
            return true;
          }
        }
        return false;
      }();
      equalsConstructorPrototypeIfNotBuggy = function(o) {
        if (typeof window === "undefined" || !hasAutomationEqualityBug) {
          return equalsConstructorPrototype(o);
        }
        try {
          return equalsConstructorPrototype(o);
        } catch (e) {
          return false;
        }
      };
      keysShim = function keys(object) {
        var isObject = object !== null && typeof object === "object";
        var isFunction = toStr.call(object) === "[object Function]";
        var isArguments = isArgs(object);
        var isString = isObject && toStr.call(object) === "[object String]";
        var theKeys = [];
        if (!isObject && !isFunction && !isArguments) {
          throw new TypeError("Object.keys called on a non-object");
        }
        var skipProto = hasProtoEnumBug && isFunction;
        if (isString && object.length > 0 && !has.call(object, 0)) {
          for (var i = 0; i < object.length; ++i) {
            theKeys.push(String(i));
          }
        }
        if (isArguments && object.length > 0) {
          for (var j = 0; j < object.length; ++j) {
            theKeys.push(String(j));
          }
        } else {
          for (var name in object) {
            if (!(skipProto && name === "prototype") && has.call(object, name)) {
              theKeys.push(String(name));
            }
          }
        }
        if (hasDontEnumBug) {
          var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
          for (var k = 0; k < dontEnums.length; ++k) {
            if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
              theKeys.push(dontEnums[k]);
            }
          }
        }
        return theKeys;
      };
    }
    var has;
    var toStr;
    var isArgs;
    var isEnumerable;
    var hasDontEnumBug;
    var hasProtoEnumBug;
    var dontEnums;
    var equalsConstructorPrototype;
    var excludedKeys;
    var hasAutomationEqualityBug;
    var equalsConstructorPrototypeIfNotBuggy;
    module.exports = keysShim;
  }
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS({
  "node_modules/object-keys/index.js"(exports, module) {
    "use strict";
    var slice = Array.prototype.slice;
    var isArgs = require_isArguments();
    var origKeys = Object.keys;
    var keysShim = origKeys ? function keys(o) {
      return origKeys(o);
    } : require_implementation();
    var originalKeys = Object.keys;
    keysShim.shim = function shimObjectKeys() {
      if (Object.keys) {
        var keysWorksWithArguments = function() {
          var args = Object.keys(arguments);
          return args && args.length === arguments.length;
        }(1, 2);
        if (!keysWorksWithArguments) {
          Object.keys = function keys(object) {
            if (isArgs(object)) {
              return originalKeys(slice.call(object));
            }
            return originalKeys(object);
          };
        }
      } else {
        Object.keys = keysShim;
      }
      return Object.keys || keysShim;
    };
    module.exports = keysShim;
  }
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS({
  "node_modules/define-properties/index.js"(exports, module) {
    "use strict";
    var keys = require_object_keys();
    var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
    var toStr = Object.prototype.toString;
    var concat = Array.prototype.concat;
    var origDefineProperty = Object.defineProperty;
    var isFunction = function(fn) {
      return typeof fn === "function" && toStr.call(fn) === "[object Function]";
    };
    var arePropertyDescriptorsSupported = function() {
      var obj2 = {};
      try {
        origDefineProperty(obj2, "x", { enumerable: false, value: obj2 });
        for (var _ in obj2) {
          return false;
        }
        return obj2.x === obj2;
      } catch (e) {
        return false;
      }
    };
    var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
    var defineProperty = function(object, name, value, predicate) {
      if (name in object && (!isFunction(predicate) || !predicate())) {
        return;
      }
      if (supportsDescriptors) {
        origDefineProperty(object, name, {
          configurable: true,
          enumerable: false,
          value,
          writable: true
        });
      } else {
        object[name] = value;
      }
    };
    var defineProperties = function(object, map) {
      var predicates = arguments.length > 2 ? arguments[2] : {};
      var props = keys(map);
      if (hasSymbols) {
        props = concat.call(props, Object.getOwnPropertySymbols(map));
      }
      for (var i = 0; i < props.length; i += 1) {
        defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
      }
    };
    defineProperties.supportsDescriptors = !!supportsDescriptors;
    module.exports = defineProperties;
  }
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS({
  "node_modules/globalthis/implementation.browser.js"(exports, module) {
    "use strict";
    if (typeof self !== "undefined") {
      module.exports = self;
    } else if (typeof window !== "undefined") {
      module.exports = window;
    } else {
      module.exports = Function("return this")();
    }
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/globalthis/polyfill.js"(exports, module) {
    "use strict";
    var implementation = require_implementation_browser();
    module.exports = function getPolyfill() {
      if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
        return implementation;
      }
      return global;
    };
  }
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS({
  "node_modules/globalthis/shim.js"(exports, module) {
    "use strict";
    var define2 = require_define_properties();
    var getPolyfill = require_polyfill();
    module.exports = function shimGlobal() {
      var polyfill = getPolyfill();
      if (define2.supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
        if (!descriptor || descriptor.configurable && (descriptor.enumerable || descriptor.writable || globalThis !== polyfill)) {
          Object.defineProperty(polyfill, "globalThis", {
            configurable: true,
            enumerable: false,
            value: polyfill,
            writable: false
          });
        }
      } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
        polyfill.globalThis = polyfill;
      }
      return polyfill;
    };
  }
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS({
  "node_modules/globalthis/index.js"(exports, module) {
    "use strict";
    var defineProperties = require_define_properties();
    var implementation = require_implementation_browser();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var polyfill = getPolyfill();
    var getGlobal = function() {
      return polyfill;
    };
    defineProperties(getGlobal, {
      getPolyfill,
      implementation,
      shim
    });
    module.exports = getGlobal;
  }
});

// node_modules/@kitware/vtk.js/vtk.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtk(obj2) {
  if (obj2 === null || obj2 === void 0) {
    return obj2;
  }
  if (obj2.isA) {
    return obj2;
  }
  if (!obj2.vtkClass) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("Invalid VTK object");
    }
    return null;
  }
  var constructor = factoryMapping[obj2.vtkClass];
  if (!constructor) {
    if (vtkGlobal.console && vtkGlobal.console.error) {
      vtkGlobal.console.error("No vtk class found for Object of type ".concat(obj2.vtkClass));
    }
    return null;
  }
  var model = _objectSpread({}, obj2);
  Object.keys(model).forEach(function(keyName) {
    if (model[keyName] && _typeof(model[keyName]) === "object" && model[keyName].vtkClass) {
      model[keyName] = vtk(model[keyName]);
    }
  });
  var newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}
function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}
var import_globalthis, vtkGlobal, factoryMapping;
var init_vtk = __esm({
  "node_modules/@kitware/vtk.js/vtk.js"() {
    init_typeof();
    init_defineProperty();
    import_globalthis = __toESM(require_globalthis());
    vtkGlobal = (0, import_globalthis.default)();
    factoryMapping = {
      vtkObject: function vtkObject() {
        return null;
      }
    };
    vtk.register = register;
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var init_classCallCheck = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/classCallCheck.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var init_createClass = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/createClass.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
var init_getPrototypeOf = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/superPropBase.js
function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null)
      break;
  }
  return object;
}
var init_superPropBase = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/superPropBase.js"() {
    init_getPrototypeOf();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/get.js
function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get2(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base)
        return;
      var desc = Object.getOwnPropertyDescriptor(base, property);
      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }
      return desc.value;
    };
  }
  return _get.apply(this, arguments);
}
var init_get = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/get.js"() {
    init_superPropBase();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
var init_inherits = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/inherits.js"() {
    init_setPrototypeOf();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
var init_assertThisInitialized = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
var init_possibleConstructorReturn = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"() {
    init_typeof();
    init_assertThisInitialized();
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
var init_isNativeFunction = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js"() {
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var init_wrapNativeSuper = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js"() {
    init_getPrototypeOf();
    init_setPrototypeOf();
    init_isNativeFunction();
    init_construct();
  }
});

// node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
var ClassHierarchy;
var init_ClassHierarchy = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/ClassHierarchy.js"() {
    init_toConsumableArray();
    init_classCallCheck();
    init_createClass();
    init_get();
    init_inherits();
    init_possibleConstructorReturn();
    init_getPrototypeOf();
    init_wrapNativeSuper();
    ClassHierarchy = function(_Array) {
      _inherits(ClassHierarchy2, _Array);
      var _super = _createSuper(ClassHierarchy2);
      function ClassHierarchy2() {
        _classCallCheck(this, ClassHierarchy2);
        return _super.apply(this, arguments);
      }
      _createClass(ClassHierarchy2, [{
        key: "push",
        value: function push() {
          var _this = this, _get2;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var newArgs = args.filter(function(arg) {
            return !_this.includes(arg);
          });
          return (_get2 = _get(_getPrototypeOf(ClassHierarchy2.prototype), "push", this)).call.apply(_get2, [this].concat(_toConsumableArray(newArgs)));
        }
      }]);
      return ClassHierarchy2;
    }(_wrapNativeSuper(Array));
  }
});

// node_modules/@kitware/vtk.js/macros.js
var macros_exports = {};
__export(macros_exports, {
  EVENT_ABORT: () => EVENT_ABORT,
  TYPED_ARRAYS: () => TYPED_ARRAYS,
  VOID: () => VOID,
  _capitalize: () => _capitalize,
  algo: () => algo,
  capitalize: () => capitalize,
  chain: () => chain,
  debounce: () => debounce,
  default: () => macro,
  event: () => event,
  formatBytesToProperUnit: () => formatBytesToProperUnit,
  formatNumbersWithThousandSeparator: () => formatNumbersWithThousandSeparator,
  get: () => get,
  getArray: () => getArray,
  isVtkObject: () => isVtkObject,
  keystore: () => keystore,
  moveToProtected: () => moveToProtected,
  newInstance: () => newInstance,
  newTypedArray: () => newTypedArray,
  newTypedArrayFrom: () => newTypedArrayFrom,
  normalizeWheel: () => normalizeWheel,
  obj: () => obj,
  proxy: () => proxy,
  proxyPropertyMapping: () => proxyPropertyMapping,
  proxyPropertyState: () => proxyPropertyState,
  set: () => set,
  setArray: () => setArray,
  setGet: () => setGet,
  setGetArray: () => setGetArray,
  setImmediateVTK: () => setImmediateVTK,
  setLoggerFunction: () => setLoggerFunction,
  throttle: () => throttle,
  traverseInstanceTree: () => traverseInstanceTree,
  uncapitalize: () => uncapitalize,
  vtkDebugMacro: () => vtkDebugMacro,
  vtkErrorMacro: () => vtkErrorMacro,
  vtkInfoMacro: () => vtkInfoMacro,
  vtkLogMacro: () => vtkLogMacro,
  vtkOnceErrorMacro: () => vtkOnceErrorMacro,
  vtkWarningMacro: () => vtkWarningMacro
});
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getCurrentGlobalMTime() {
  return globalMTime;
}
function noOp() {
}
function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}
function vtkLogMacro() {
  loggerFunctions.log.apply(loggerFunctions, arguments);
}
function vtkInfoMacro() {
  loggerFunctions.info.apply(loggerFunctions, arguments);
}
function vtkDebugMacro() {
  loggerFunctions.debug.apply(loggerFunctions, arguments);
}
function vtkErrorMacro() {
  loggerFunctions.error.apply(loggerFunctions, arguments);
}
function vtkWarningMacro() {
  loggerFunctions.warn.apply(loggerFunctions, arguments);
}
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
}
function newTypedArray(type) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return _construct(TYPED_ARRAYS[type] || Float64Array, args);
}
function newTypedArrayFrom(type) {
  var _ref;
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return (_ref = TYPED_ARRAYS[type] || Float64Array).from.apply(_ref, args);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function _capitalize(str) {
  return capitalize(str[0] === "_" ? str.slice(1) : str);
}
function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}
function formatBytesToProperUnit(size) {
  var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var chunkSize = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e3;
  var units = ["TB", "GB", "MB", "KB"];
  var value = Number(size);
  var currentUnit = "B";
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return "".concat(value.toFixed(precision), " ").concat(currentUnit);
}
function formatNumbersWithThousandSeparator(n) {
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : " ";
  var sections = [];
  var size = n;
  while (size > 1e3) {
    sections.push("000".concat(size % 1e3).slice(-3));
    size = Math.floor(size / 1e3);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join(separator);
}
function safeArrays(model) {
  Object.keys(model).forEach(function(key) {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}
function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}
function enumToString(e, value) {
  return Object.keys(e).find(function(key) {
    return e[key] === value;
  });
}
function getStateArrayMapFunc(item) {
  if (item && item.isA) {
    return item.getState();
  }
  return item;
}
function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}
function obj() {
  var publicAPI = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  safeArrays(model);
  var callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  if (!("classHierarchy" in model)) {
    model.classHierarchy = new ClassHierarchy("vtkObject");
  } else if (!(model.classHierarchy instanceof ClassHierarchy)) {
    model.classHierarchy = ClassHierarchy.from(model.classHierarchy);
  }
  function off(index) {
    callbacks[index] = null;
  }
  function on(index) {
    function unsubscribe() {
      off(index);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  publicAPI.isDeleted = function() {
    return !!model.deleted;
  };
  publicAPI.modified = function(otherMTime) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }
    model.mtime = ++globalMTime;
    callbacks.forEach(function(callback) {
      return callback && callback(publicAPI);
    });
  };
  publicAPI.onModified = function(callback) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    var index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };
  publicAPI.getMTime = function() {
    return model.mtime;
  };
  publicAPI.isA = function(className) {
    var count = model.classHierarchy.length;
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getClassName = function() {
    var depth = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.classHierarchy[model.classHierarchy.length - 1 - depth];
  };
  publicAPI.set = function() {
    var map = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var noWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var noFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var ret = false;
    Object.keys(map).forEach(function(name) {
      var fn = noFunction ? null : publicAPI["set".concat(capitalize(name))];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn.apply(void 0, _toConsumableArray(map[name])) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        if (["mtime"].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro("Warning: Set value to model directly ".concat(name, ", ").concat(map[name]));
        }
        ret = model[name] !== map[name] || ret;
        model[name] = map[name];
      }
    });
    return ret;
  };
  publicAPI.get = function() {
    for (var _len3 = arguments.length, list = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      list[_key3] = arguments[_key3];
    }
    if (!list.length) {
      return model;
    }
    var subset = {};
    list.forEach(function(name) {
      subset[name] = model[name];
    });
    return subset;
  };
  publicAPI.getReferenceByName = function(val) {
    return model[val];
  };
  publicAPI.delete = function() {
    Object.keys(model).forEach(function(field) {
      return delete model[field];
    });
    callbacks.forEach(function(el, index) {
      return off(index);
    });
    model.deleted = true;
  };
  publicAPI.getState = function() {
    if (model.deleted) {
      return null;
    }
    var jsonArchive = _objectSpread2(_objectSpread2({}, model), {}, {
      vtkClass: publicAPI.getClassName()
    });
    Object.keys(jsonArchive).forEach(function(keyName) {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === void 0 || keyName[0] === "_") {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      }
    });
    var sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(function(name) {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error("Cannot ShallowCopy ".concat(other.getClassName(), " into ").concat(publicAPI.getClassName()));
    }
    var otherModel = other.get();
    var keyList = Object.keys(model).sort();
    var otherKeyList = Object.keys(otherModel).sort();
    otherKeyList.forEach(function(key) {
      var keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro("add ".concat(key, " in shallowCopy"));
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro("Untouched keys: ".concat(keyList.join(", ")));
    }
    publicAPI.modified();
  };
  publicAPI.toJSON = function vtkObjToJSON() {
    return publicAPI.getState();
  };
  return publicAPI;
}
function get(publicAPI, model, fieldNames) {
  fieldNames.forEach(function(field) {
    if (_typeof(field) === "object") {
      publicAPI["get".concat(_capitalize(field.name))] = function() {
        return model[field.name];
      };
    } else {
      publicAPI["get".concat(_capitalize(field))] = function() {
        return model[field];
      };
    }
  });
}
function findSetter(field) {
  if (_typeof(field) === "object") {
    var fn = objectSetterMap[field.type];
    if (fn) {
      return function(publicAPI, model) {
        return fn(publicAPI, model, field);
      };
    }
    vtkErrorMacro("No setter for field ".concat(field));
    throw new TypeError("No setter for field");
  }
  return function getSetter(publicAPI, model) {
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro("instance deleted - cannot call any method");
        return false;
      }
      if (model[field] !== value) {
        model[field] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}
function set(publicAPI, model, fields) {
  fields.forEach(function(field) {
    if (_typeof(field) === "object") {
      publicAPI["set".concat(_capitalize(field.name))] = findSetter(field)(publicAPI, model);
    } else {
      publicAPI["set".concat(_capitalize(field))] = findSetter(field)(publicAPI, model);
    }
  });
}
function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}
function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach(function(field) {
    publicAPI["get".concat(_capitalize(field))] = function() {
      return model[field] ? [].concat(model[field]) : model[field];
    };
    publicAPI["get".concat(_capitalize(field), "ByReference")] = function() {
      return model[field];
    };
  });
}
function setArray(publicAPI, model, fieldNames, size) {
  var defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  fieldNames.forEach(function(field) {
    if (model[field] && size && model[field].length !== size) {
      throw new RangeError("Invalid initial number of values for array (".concat(field, ")"));
    }
    publicAPI["set".concat(_capitalize(field))] = function() {
      if (model.deleted) {
        vtkErrorMacro("instance deleted - cannot call any method");
        return false;
      }
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      var array = args;
      var changeDetected;
      var needCopy = false;
      if (array.length === 1 && (array[0] == null || array[0].length >= 0)) {
        array = array[0];
        needCopy = true;
      }
      if (array == null) {
        changeDetected = model[field] !== array;
      } else {
        if (size && array.length !== size) {
          if (array.length < size && defaultVal !== void 0) {
            array = Array.from(array);
            needCopy = false;
            while (array.length < size) {
              array.push(defaultVal);
            }
          } else {
            throw new RangeError("Invalid number of values for array setter (".concat(field, ")"));
          }
        }
        changeDetected = model[field] == null || model[field].some(function(item, index) {
          return item !== array[index];
        }) || model[field].length !== array.length;
        if (changeDetected && needCopy) {
          array = Array.from(array);
        }
      }
      if (changeDetected) {
        model[field] = array;
        publicAPI.modified();
      }
      return changeDetected;
    };
    publicAPI["set".concat(_capitalize(field), "From")] = function(otherArray) {
      var target = model[field];
      otherArray.forEach(function(v, i) {
        target[i] = v;
      });
    };
  });
}
function setGetArray(publicAPI, model, fieldNames, size) {
  var defaultVal = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : void 0;
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}
function moveToProtected(publicAPI, model, fieldNames) {
  for (var i = 0; i < fieldNames.length; i++) {
    var fieldName = fieldNames[i];
    if (model[fieldName] !== void 0) {
      model["_".concat(fieldName)] = model[fieldName];
      delete model[fieldName];
    }
  }
}
function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(vtk);
  } else {
    model.inputData = [];
  }
  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(vtk);
  } else {
    model.inputConnection = [];
  }
  if (model.output) {
    model.output = model.output.map(vtk);
  } else {
    model.output = [];
  }
  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(vtk);
  } else {
    model.inputArrayToProcess = [];
  }
  model.numberOfInputs = numberOfInputs;
  function setInputData(dataset) {
    var port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro("algorithm ".concat(publicAPI.getClassName(), " only has ").concat(model.numberOfInputs, " input ports. To add more input ports, use addInputData()"));
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }
  function getInputData() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }
  function setInputConnection(outputPort) {
    var port = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    if (port >= model.numberOfInputs) {
      var msg = "algorithm ".concat(publicAPI.getClassName(), " only has ");
      msg += "".concat(model.numberOfInputs);
      msg += " input ports. To add more input ports, use addInputConnection()";
      vtkErrorMacro(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }
  function getInputConnection() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return model.inputConnection[port];
  }
  function getPortToFill() {
    var portToFill = model.numberOfInputs;
    while (portToFill && !model.inputData[portToFill - 1] && !model.inputConnection[portToFill - 1]) {
      portToFill--;
    }
    if (portToFill === model.numberOfInputs) {
      model.numberOfInputs++;
    }
    return portToFill;
  }
  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    setInputConnection(outputPort, getPortToFill());
  }
  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    setInputData(dataset, getPortToFill());
  }
  function getOutputData() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }
  publicAPI.shouldUpdate = function() {
    var localMTime = publicAPI.getMTime();
    var minOutputMTime = Infinity;
    var count2 = numberOfOutputs;
    while (count2--) {
      if (!model.output[count2] || model.output[count2].isDeleted()) {
        return true;
      }
      var mt = model.output[count2].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }
    count2 = model.numberOfInputs;
    while (count2--) {
      var _model$inputConnectio, _publicAPI$getInputDa;
      if ((_model$inputConnectio = model.inputConnection[count2]) !== null && _model$inputConnectio !== void 0 && _model$inputConnectio.filter.shouldUpdate() || ((_publicAPI$getInputDa = publicAPI.getInputData(count2)) === null || _publicAPI$getInputDa === void 0 ? void 0 : _publicAPI$getInputDa.getMTime()) > minOutputMTime) {
        return true;
      }
    }
    return false;
  };
  function getOutputPort() {
    var port = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var outputPortAccess = function outputPortAccess2() {
      return getOutputData(port);
    };
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }
  if (model.numberOfInputs) {
    var count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }
  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }
  publicAPI.update = function() {
    var ins = [];
    if (model.numberOfInputs) {
      var _count = 0;
      while (_count < model.numberOfInputs) {
        ins[_count] = publicAPI.getInputData(_count);
        _count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };
  publicAPI.getNumberOfInputPorts = function() {
    return model.numberOfInputs;
  };
  publicAPI.getNumberOfOutputPorts = function() {
    return numberOfOutputs || model.output.length;
  };
  publicAPI.getInputArrayToProcess = function(inputPort) {
    var arrayDesc = model.inputArrayToProcess[inputPort];
    var ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds["get".concat(arrayDesc.fieldAssociation)]().getArray(arrayDesc.arrayName);
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = function(inputPort, arrayName, fieldAssociation) {
    var attributeType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "Scalars";
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType
    };
  };
}
function event(publicAPI, model, eventName) {
  var callbacks = [];
  var previousDelete = publicAPI.delete;
  var curCallbackID = 1;
  function off(callbackID) {
    for (var i = 0; i < callbacks.length; ++i) {
      var _callbacks$i = _slicedToArray(callbacks[i], 1), cbID = _callbacks$i[0];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }
  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe
    });
  }
  function invoke() {
    var _arguments = arguments;
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return;
    }
    var currentCallbacks = callbacks.slice();
    var _loop = function _loop2(index2) {
      var _currentCallbacks$ind = _slicedToArray(currentCallbacks[index2], 3), cb = _currentCallbacks$ind[1], priority = _currentCallbacks$ind[2];
      if (!cb) {
        return "continue";
      }
      if (priority < 0) {
        setTimeout(function() {
          return cb.apply(publicAPI, _arguments);
        }, 1 - priority);
      } else {
        var continueNext = cb.apply(publicAPI, _arguments);
        if (continueNext === EVENT_ABORT) {
          return "break";
        }
      }
    };
    for (var index = 0; index < currentCallbacks.length; ++index) {
      var _ret = _loop(index);
      if (_ret === "continue")
        continue;
      if (_ret === "break")
        break;
    }
  }
  publicAPI["invoke".concat(_capitalize(eventName))] = invoke;
  publicAPI["on".concat(_capitalize(eventName))] = function(callback) {
    var priority = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!callback.apply) {
      console.error("Invalid callback for event ".concat(eventName));
      return null;
    }
    if (model.deleted) {
      vtkErrorMacro("instance deleted - cannot call any method");
      return null;
    }
    var callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort(function(cb1, cb2) {
      return cb2[2] - cb1[2];
    });
    return on(callbackID);
  };
  publicAPI.delete = function() {
    previousDelete();
    callbacks.forEach(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 1), cbID = _ref3[0];
      return off(cbID);
    });
  };
}
function newInstance(extend91, className) {
  var constructor = function constructor2() {
    var initialValues = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var model = {};
    var publicAPI = {};
    extend91(publicAPI, model, initialValues);
    return Object.freeze(publicAPI);
  };
  if (className) {
    vtk.register(className, constructor);
  }
  return constructor;
}
function chain() {
  for (var _len5 = arguments.length, fn = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    fn[_key5] = arguments[_key5];
  }
  return function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return fn.filter(function(i) {
      return !!i;
    }).map(function(i) {
      return i.apply(void 0, args);
    });
  };
}
function isVtkObject(instance) {
  return instance && instance.isA && instance.isA("vtkObject");
}
function traverseInstanceTree(instance, extractFunction) {
  var accumulator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  var visitedInstances = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      return accumulator;
    }
    visitedInstances.push(instance);
    var result = extractFunction(instance);
    if (result !== void 0) {
      accumulator.push(result);
    }
    var model = instance.get();
    Object.keys(model).forEach(function(key) {
      var modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach(function(subObj) {
          traverseInstanceTree(subObj, extractFunction, accumulator, visitedInstances);
        });
      } else {
        traverseInstanceTree(modelObj, extractFunction, accumulator, visitedInstances);
      }
    });
  }
  return accumulator;
}
function debounce(func, wait, immediate) {
  var _this = this;
  var timeout;
  var debounced = function debounced2() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    var context = _this;
    var later = function later2() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
  debounced.cancel = function() {
    return clearTimeout(timeout);
  };
  return debounced;
}
function throttle(callback, delay) {
  var isThrottled = false;
  var argsToUse = null;
  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper.apply(void 0, _toConsumableArray(argsToUse));
      argsToUse = null;
    }
  }
  function wrapper() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback.apply(void 0, args);
    setTimeout(next, delay);
  }
  return wrapper;
}
function keystore(publicAPI, model) {
  var initialKeystore = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);
  publicAPI.setKey = function(key, value) {
    model.keystore[key] = value;
  };
  publicAPI.getKey = function(key) {
    return model.keystore[key];
  };
  publicAPI.getAllKeys = function() {
    return Object.keys(model.keystore);
  };
  publicAPI.deleteKey = function(key) {
    return delete model.keystore[key];
  };
  publicAPI.clearKeystore = function() {
    return publicAPI.getAllKeys().forEach(function(key) {
      return delete model.keystore[key];
    });
  };
}
function proxy(publicAPI, model) {
  keystore(publicAPI, model);
  var parentDelete = publicAPI.delete;
  model.proxyId = "".concat(nextProxyId++);
  model.ui = JSON.parse(JSON.stringify(model.ui || []));
  get(publicAPI, model, ["proxyId", "proxyGroup", "proxyName"]);
  setGet(publicAPI, model, ["proxyManager"]);
  var propertyMap = {};
  var groupChildrenNames = {};
  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    var childrenNames = groupChildrenNames[currentGroupName];
    for (var i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(descriptionList[i].children, descriptionList[i].name);
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);
  publicAPI.updateUI = function(ui) {
    model.ui = JSON.parse(JSON.stringify(ui || []));
    Object.keys(propertyMap).forEach(function(k) {
      return delete propertyMap[k];
    });
    Object.keys(groupChildrenNames).forEach(function(k) {
      return delete groupChildrenNames[k];
    });
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };
  function listProxyProperties() {
    var gName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    return groupChildrenNames[gName];
  }
  publicAPI.updateProxyProperty = function(propertyName, propUI) {
    var prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = _objectSpread2({}, propUI);
    }
  };
  publicAPI.activate = function() {
    if (model.proxyManager) {
      var setActiveMethod = "setActive".concat(_capitalize(publicAPI.getProxyGroup().slice(0, -1)));
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = function(otherLink, type) {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };
  publicAPI.gcPropertyLinks = function(type) {
    var subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };
  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = function(id) {
    var persistent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    var value = null;
    var links = [];
    var count = 0;
    var updateInProgress = false;
    function update(source) {
      var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (updateInProgress) {
        return null;
      }
      var needUpdate = [];
      var sourceLink = null;
      count = links.length;
      while (count--) {
        var link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }
      if (!sourceLink) {
        return null;
      }
      var newValue = sourceLink.instance["get".concat(_capitalize(sourceLink.propertyName))]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          var linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set(_defineProperty({}, linkToUpdate.propertyName, value));
        }
        updateInProgress = false;
      }
      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }
      return newValue;
    }
    function unbind(instance, propertyName) {
      var indexToDelete = [];
      count = links.length;
      while (count--) {
        var link = links[count];
        if (link.instance === instance && (link.propertyName === propertyName || propertyName === void 0)) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }
    function bind(instance, propertyName) {
      var updateMe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var subscription = instance.onModified(update);
      var other = links[0];
      links.push({
        instance,
        propertyName,
        subscription
      });
      if (updateMe) {
        if (model.propertyLinkMap[id].persistent && model.propertyLinkMap[id].value !== void 0) {
          instance.set(_defineProperty({}, propertyName, model.propertyLinkMap[id].value));
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: function unsubscribe2() {
          return unbind(instance, propertyName);
        }
      };
    }
    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }
    var linkHandler = {
      bind,
      unbind,
      unsubscribe,
      persistent
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };
  function getProperties() {
    var groupName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ROOT_GROUP_NAME;
    var values = [];
    var id = model.proxyId;
    var propertyNames = listProxyProperties(groupName) || [];
    for (var i = 0; i < propertyNames.length; i++) {
      var name = propertyNames[i];
      var method = publicAPI["get".concat(_capitalize(name))];
      var value = method ? method() : void 0;
      var prop = {
        id,
        name,
        value
      };
      var children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }
  publicAPI.listPropertyNames = function() {
    return getProperties().map(function(p) {
      return p.name;
    });
  };
  publicAPI.getPropertyByName = function(name) {
    return getProperties().find(function(p) {
      return p.name === name;
    });
  };
  publicAPI.getPropertyDomainByName = function(name) {
    return (propertyMap[name] || {}).domain;
  };
  publicAPI.getProxySection = function() {
    return {
      id: model.proxyId,
      name: model.proxyGroup,
      ui: model.ui,
      properties: getProperties()
    };
  };
  publicAPI.delete = function() {
    var list = Object.keys(model.propertyLinkMap);
    var count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(publicAPI.gcPropertyLinks);
    parentDelete();
  };
  publicAPI.getState = function() {
    return null;
  };
  function registerLinks() {
    if (model.links) {
      for (var i = 0; i < model.links.length; i++) {
        var _model$links$i = model.links[i], link = _model$links$i.link, property = _model$links$i.property, persistent = _model$links$i.persistent, updateOnBind = _model$links$i.updateOnBind, type = _model$links$i.type;
        if (type === "application") {
          var sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, "application");
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}
function proxyPropertyMapping(publicAPI, model, map) {
  var parentDelete = publicAPI.delete;
  var subscriptions = [];
  var propertyNames = Object.keys(map);
  var count = propertyNames.length;
  while (count--) {
    var propertyName = propertyNames[count];
    var _map$propertyName = map[propertyName], modelKey = _map$propertyName.modelKey, property = _map$propertyName.property, _map$propertyName$mod = _map$propertyName.modified, modified = _map$propertyName$mod === void 0 ? true : _map$propertyName$mod;
    var methodSrc = _capitalize(property);
    var methodDst = _capitalize(propertyName);
    publicAPI["get".concat(methodDst)] = model[modelKey]["get".concat(methodSrc)];
    publicAPI["set".concat(methodDst)] = model[modelKey]["set".concat(methodSrc)];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }
  publicAPI.delete = function() {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}
function proxyPropertyState(publicAPI, model) {
  var state = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var defaults = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  model.this = publicAPI;
  function applyState(map) {
    var modelKeys2 = Object.keys(map);
    var count2 = modelKeys2.length;
    while (count2--) {
      var modelKey = modelKeys2[count2];
      model[modelKey].set(map[modelKey]);
    }
  }
  var modelKeys = Object.keys(defaults);
  var count = modelKeys.length;
  var _loop2 = function _loop22() {
    var key = modelKeys[count];
    model[key] = defaults[key];
    var mapping = state[key];
    publicAPI["set".concat(_capitalize(key))] = function(value) {
      if (value !== model[key]) {
        model[key] = value;
        var propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  };
  while (count--) {
    _loop2();
  }
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}
function normalizeWheel(wheelEvent) {
  var sX = 0;
  var sY = 0;
  var pX = 0;
  var pY = 0;
  if ("detail" in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ("wheelDelta" in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ("wheelDeltaY" in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ("wheelDeltaX" in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }
  if ("axis" in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }
  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;
  if ("deltaY" in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ("deltaX" in wheelEvent) {
    pX = wheelEvent.deltaX;
  }
  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }
  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}
var globalMTime, VOID, fakeConsole, consoleMethods, loggerFunctions, ERROR_ONCE_MAP, TYPED_ARRAYS, objectSetterMap, EVENT_ABORT, nextProxyId, ROOT_GROUP_NAME, PIXEL_STEP, LINE_HEIGHT, PAGE_HEIGHT, macro;
var init_macros = __esm({
  "node_modules/@kitware/vtk.js/macros.js"() {
    init_slicedToArray();
    init_typeof();
    init_defineProperty();
    init_toConsumableArray();
    init_construct();
    init_vtk();
    init_ClassHierarchy();
    globalMTime = 0;
    VOID = Symbol("void");
    fakeConsole = {};
    consoleMethods = ["log", "debug", "info", "warn", "error", "time", "timeEnd", "group", "groupEnd"];
    consoleMethods.forEach(function(methodName) {
      fakeConsole[methodName] = noOp;
    });
    vtkGlobal.console = console.hasOwnProperty("log") ? console : fakeConsole;
    loggerFunctions = {
      debug: noOp,
      error: vtkGlobal.console.error || noOp,
      info: vtkGlobal.console.info || noOp,
      log: vtkGlobal.console.log || noOp,
      warn: vtkGlobal.console.warn || noOp
    };
    ERROR_ONCE_MAP = {};
    TYPED_ARRAYS = /* @__PURE__ */ Object.create(null);
    TYPED_ARRAYS.Float32Array = Float32Array;
    TYPED_ARRAYS.Float64Array = Float64Array;
    TYPED_ARRAYS.Uint8Array = Uint8Array;
    TYPED_ARRAYS.Int8Array = Int8Array;
    TYPED_ARRAYS.Uint16Array = Uint16Array;
    TYPED_ARRAYS.Int16Array = Int16Array;
    TYPED_ARRAYS.Uint32Array = Uint32Array;
    TYPED_ARRAYS.Int32Array = Int32Array;
    TYPED_ARRAYS.Uint8ClampedArray = Uint8ClampedArray;
    objectSetterMap = {
      enum: function _enum(publicAPI, model, field) {
        return function(value) {
          if (typeof value === "string") {
            if (field.enum[value] !== void 0) {
              if (model[field.name] !== field.enum[value]) {
                model[field.name] = field.enum[value];
                publicAPI.modified();
                return true;
              }
              return false;
            }
            vtkErrorMacro("Set Enum with invalid argument ".concat(field, ", ").concat(value));
            throw new RangeError("Set Enum with invalid string argument");
          }
          if (typeof value === "number") {
            if (model[field.name] !== value) {
              if (Object.keys(field.enum).map(function(key) {
                return field.enum[key];
              }).indexOf(value) !== -1) {
                model[field.name] = value;
                publicAPI.modified();
                return true;
              }
              vtkErrorMacro("Set Enum outside numeric range ".concat(field, ", ").concat(value));
              throw new RangeError("Set Enum outside numeric range");
            }
            return false;
          }
          vtkErrorMacro("Set Enum with invalid argument (String/Number) ".concat(field, ", ").concat(value));
          throw new TypeError("Set Enum with invalid argument (String/Number)");
        };
      }
    };
    EVENT_ABORT = Symbol("Event abort");
    nextProxyId = 1;
    ROOT_GROUP_NAME = "__root__";
    PIXEL_STEP = 10;
    LINE_HEIGHT = 40;
    PAGE_HEIGHT = 800;
    macro = {
      algo,
      capitalize,
      chain,
      debounce,
      enumToString,
      event,
      EVENT_ABORT,
      formatBytesToProperUnit,
      formatNumbersWithThousandSeparator,
      get,
      getArray,
      getCurrentGlobalMTime,
      getStateArrayMapFunc,
      isVtkObject,
      keystore,
      moveToProtected,
      newInstance,
      newTypedArray,
      newTypedArrayFrom,
      normalizeWheel,
      obj,
      proxy,
      proxyPropertyMapping,
      proxyPropertyState,
      safeArrays,
      set,
      setArray,
      setGet,
      setGetArray,
      setImmediate: setImmediateVTK,
      setLoggerFunction,
      throttle,
      traverseInstanceTree,
      TYPED_ARRAYS,
      uncapitalize,
      VOID,
      vtkDebugMacro,
      vtkErrorMacro,
      vtkInfoMacro,
      vtkLogMacro,
      vtkOnceErrorMacro,
      vtkWarningMacro
    };
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports, module) {
    (function(global2, module2, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8)
            X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j)
            ;
          if (j == 8)
            w = X[7] = -1;
          else
            w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2)
              v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0)
              w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = t == 0 ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null)
          seed = +new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X)
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports, module) {
    (function(global2, module2, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object")
            copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module2 && module2.exports) {
        module2.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(exports, typeof module == "object" && module, typeof define == "function" && define);
  }
});

// browser-external:crypto
var crypto_exports = {};
__export(crypto_exports, {
  default: () => crypto_default
});
var crypto_default;
var init_crypto = __esm({
  "browser-external:crypto"() {
    crypto_default = new Proxy({}, {
      get() {
        throw new Error('Module "crypto" has been externalized for browser compatibility and cannot be accessed in client code.');
      }
    });
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports, module) {
    (function(global2, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom2(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed, 3), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n = arc4.g(chunks), d = startdenom, x = 0;
          while (n < significance) {
            n = (n + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n >= overflow) {
            n /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else
            return prng2;
        })(prng, shortseed, "global" in options ? options.global : this == math, options.state);
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten(obj2, depth) {
        var result = [], typ = typeof obj2, prop;
        if (depth && typ == "object") {
          for (prop in obj2) {
            try {
              result.push(flatten(obj2[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj2 : obj2 + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global2.crypto || global2.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser = global2.navigator, plugins = browser && browser.plugins;
          return [+new Date(), global2, plugins, global2.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool);
      if (typeof module == "object" && module.exports) {
        module.exports = seedrandom2;
        try {
          nodecrypto = (init_crypto(), __toCommonJS(crypto_exports));
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom2;
        });
      } else {
        math["seed" + rngname] = seedrandom2;
      }
    })(typeof self !== "undefined" ? self : exports, [], Math);
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports, module) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module.exports = sr;
  }
});

// node_modules/@kitware/vtk.js/Common/Core/Math/index.js
function notImplemented(method) {
  return function() {
    return vtkErrorMacro2("vtkMath::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkSwapVectors3(v1, v2) {
  for (var i = 0; i < 3; i++) {
    var tmp = v1[i];
    v1[i] = v2[i];
    v2[i] = tmp;
  }
}
function createArray() {
  var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3;
  var array = [];
  while (array.length < size) {
    array.push(0);
  }
  return array;
}
function radiansFromDegrees(deg) {
  return deg / 180 * Math.PI;
}
function degreesFromRadians(rad) {
  return rad * 180 / Math.PI;
}
function arrayMin(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var minValue = Infinity;
  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }
  return minValue;
}
function arrayMax(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var maxValue = -Infinity;
  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return maxValue;
}
function arrayRange(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var stride = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var minValue = Infinity;
  var maxValue = -Infinity;
  for (var i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }
  return [minValue, maxValue];
}
function nearestPowerOfTwo(xi) {
  var v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}
function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}
function binomial(m, n) {
  var r = 1;
  for (var i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}
function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }
  var r = createArray(n);
  for (var i = 0; i < n; ++i) {
    r[i] = i;
  }
  return r;
}
function nextCombination(m, n, r) {
  var status = 0;
  for (var i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      var j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}
function randomSeed(seed) {
  (0, import_seedrandom.default)("".concat(seed), {
    global: true
  });
  randomSeedValue = seed;
}
function getSeed() {
  return randomSeedValue;
}
function random() {
  var minValue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var maxValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var delta = maxValue - minValue;
  return minValue + delta * Math.random();
}
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}
function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}
function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}
function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}
function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}
function outer(x, y, out_3x3) {
  for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 3; j++) {
      out_3x3[i][j] = x[i] * y[j];
    }
  }
}
function cross(x, y, out) {
  var Zx = x[1] * y[2] - x[2] * y[1];
  var Zy = x[2] * y[0] - x[0] * y[2];
  var Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}
function norm(x) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default: {
      var sum = 0;
      for (var i = 0; i < n; i++) {
        sum += x[i] * x[i];
      }
      return Math.sqrt(sum);
    }
  }
}
function normalize(x) {
  var den = norm(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}
function perpendiculars(x, y, z, theta) {
  var x2 = x[0] * x[0];
  var y2 = x[1] * x[1];
  var z2 = x[2] * x[2];
  var r = Math.sqrt(x2 + y2 + z2);
  var dx;
  var dy;
  var dz;
  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }
  var a = x[dx] / r;
  var b = x[dy] / r;
  var c = x[dz] / r;
  var tmp = Math.sqrt(a * a + c * c);
  if (theta !== 0) {
    var sintheta = Math.sin(theta);
    var costheta = Math.cos(theta);
    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }
    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }
    if (z) {
      z[dx] = -a * b / tmp;
      z[dy] = tmp;
      z[dz] = -b * c / tmp;
    }
  }
}
function projectVector(a, b, projection) {
  var bSquared = dot(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }
  var scale = dot(a, b) / bSquared;
  for (var i = 0; i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale);
  return true;
}
function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}
function projectVector2D(a, b, projection) {
  var bSquared = dot2D(b, b);
  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }
  var scale = dot2D(a, b) / bSquared;
  for (var i = 0; i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale);
  return true;
}
function distance2BetweenPoints(x, y) {
  return (x[0] - y[0]) * (x[0] - y[0]) + (x[1] - y[1]) * (x[1] - y[1]) + (x[2] - y[2]) * (x[2] - y[2]);
}
function angleBetweenVectors(v1, v2) {
  var crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}
function signedAngleBetweenVectors(v1, v2, vN) {
  var crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  var angle = Math.atan2(norm(crossVect), dot(v1, v2));
  return dot(crossVect, vN) >= 0 ? angle : -angle;
}
function gaussianAmplitude(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return 1 / Math.sqrt(2 * Math.PI * variance) * Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function gaussianWeight(mean, variance, position) {
  var distanceFromMean = Math.abs(mean - position);
  return Math.exp(-Math.pow(distanceFromMean, 2) / (2 * variance));
}
function outer2D(x, y, out_2x2) {
  for (var i = 0; i < 2; i++) {
    for (var j = 0; j < 2; j++) {
      out_2x2[i][j] = x[i] * y[j];
    }
  }
}
function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}
function normalize2D(x) {
  var den = norm2D(x);
  if (den !== 0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}
function determinant2x2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}
function LUFactor3x3(mat_3x3, index_3) {
  var maxI;
  var tmp;
  var largest;
  var scale = [0, 0, 0];
  for (var i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i][0]);
    if ((tmp = Math.abs(mat_3x3[i][1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i][2])) > largest) {
      largest = tmp;
    }
    scale[i] = 1 / largest;
  }
  largest = scale[0] * Math.abs(mat_3x3[0][0]);
  maxI = 0;
  if ((tmp = scale[1] * Math.abs(mat_3x3[1][0])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale[2] * Math.abs(mat_3x3[2][0])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    vtkSwapVectors3(mat_3x3[maxI], mat_3x3[0]);
    scale[maxI] = scale[0];
  }
  index_3[0] = maxI;
  mat_3x3[1][0] /= mat_3x3[0][0];
  mat_3x3[2][0] /= mat_3x3[0][0];
  mat_3x3[1][1] -= mat_3x3[1][0] * mat_3x3[0][1];
  mat_3x3[2][1] -= mat_3x3[2][0] * mat_3x3[0][1];
  largest = scale[1] * Math.abs(mat_3x3[1][1]);
  maxI = 1;
  if ((tmp = scale[2] * Math.abs(mat_3x3[2][1])) >= largest) {
    maxI = 2;
    vtkSwapVectors3(mat_3x3[2], mat_3x3[1]);
    scale[2] = scale[1];
  }
  index_3[1] = maxI;
  mat_3x3[2][1] /= mat_3x3[1][1];
  mat_3x3[1][2] -= mat_3x3[1][0] * mat_3x3[0][2];
  mat_3x3[2][2] -= mat_3x3[2][0] * mat_3x3[0][2] + mat_3x3[2][1] * mat_3x3[1][2];
  index_3[2] = 2;
}
function LUSolve3x3(mat_3x3, index_3, x_3) {
  var sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;
  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[1][0] * x_3[0];
  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[2][0] * x_3[0] - mat_3x3[2][1] * x_3[1];
  x_3[2] /= mat_3x3[2][2];
  x_3[1] = (x_3[1] - mat_3x3[1][2] * x_3[2]) / mat_3x3[1][1];
  x_3[0] = (x_3[0] - mat_3x3[0][1] * x_3[1] - mat_3x3[0][2] * x_3[2]) / mat_3x3[0][0];
}
function linearSolve3x3(mat_3x3, x_3, y_3) {
  var a1 = mat_3x3[0][0];
  var b1 = mat_3x3[0][1];
  var c1 = mat_3x3[0][2];
  var a2 = mat_3x3[1][0];
  var b2 = mat_3x3[1][1];
  var c2 = mat_3x3[1][2];
  var a3 = mat_3x3[2][0];
  var b3 = mat_3x3[2][1];
  var c3 = mat_3x3[2][2];
  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2);
  var det = a1 * d1 + b1 * d2 + c1 * d3;
  var v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  var v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  var v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}
function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  var x = mat_3x3[0][0] * in_3[0] + mat_3x3[0][1] * in_3[1] + mat_3x3[0][2] * in_3[2];
  var y = mat_3x3[1][0] * in_3[0] + mat_3x3[1][1] * in_3[1] + mat_3x3[1][2] * in_3[2];
  var z = mat_3x3[2][0] * in_3[0] + mat_3x3[2][1] * in_3[1] + mat_3x3[2][2] * in_3[2];
  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}
function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  var tmp = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
  for (var i = 0; i < 3; i++) {
    tmp[0][i] = a_3x3[0][0] * b_3x3[0][i] + a_3x3[0][1] * b_3x3[1][i] + a_3x3[0][2] * b_3x3[2][i];
    tmp[1][i] = a_3x3[1][0] * b_3x3[0][i] + a_3x3[1][1] * b_3x3[1][i] + a_3x3[1][2] * b_3x3[2][i];
    tmp[2][i] = a_3x3[2][0] * b_3x3[0][i] + a_3x3[2][1] * b_3x3[1][i] + a_3x3[2][2] * b_3x3[2][i];
  }
  for (var j = 0; j < 3; j++) {
    out_3x3[j][0] = tmp[j][0];
    out_3x3[j][1] = tmp[j][1];
    out_3x3[j][2] = tmp[j][2];
  }
}
function multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {
  if (colA !== rowB) {
    vtkErrorMacro2("Number of columns of A must match number of rows of B.");
  }
  for (var i = 0; i < rowA; i++) {
    for (var j = 0; j < colB; j++) {
      out_rowXcol[i][j] = 0;
      for (var k = 0; k < colA; k++) {
        out_rowXcol[i][j] += a[i][k] * b[k][j];
      }
    }
  }
}
function transpose3x3(in_3x3, outT_3x3) {
  var tmp;
  tmp = in_3x3[1][0];
  outT_3x3[1][0] = in_3x3[0][1];
  outT_3x3[0][1] = tmp;
  tmp = in_3x3[2][0];
  outT_3x3[2][0] = in_3x3[0][2];
  outT_3x3[0][2] = tmp;
  tmp = in_3x3[2][1];
  outT_3x3[2][1] = in_3x3[1][2];
  outT_3x3[1][2] = tmp;
  outT_3x3[0][0] = in_3x3[0][0];
  outT_3x3[1][1] = in_3x3[1][1];
  outT_3x3[2][2] = in_3x3[2][2];
}
function invert3x3(in_3x3, outI_3x3) {
  var a1 = in_3x3[0][0];
  var b1 = in_3x3[0][1];
  var c1 = in_3x3[0][2];
  var a2 = in_3x3[1][0];
  var b2 = in_3x3[1][1];
  var c2 = in_3x3[1][2];
  var a3 = in_3x3[2][0];
  var b3 = in_3x3[2][1];
  var c3 = in_3x3[2][2];
  var d1 = +determinant2x2(b2, b3, c2, c3);
  var d2 = -determinant2x2(a2, a3, c2, c3);
  var d3 = +determinant2x2(a2, a3, b2, b3);
  var e1 = -determinant2x2(b1, b3, c1, c3);
  var e2 = +determinant2x2(a1, a3, c1, c3);
  var e3 = -determinant2x2(a1, a3, b1, b3);
  var f1 = +determinant2x2(b1, b2, c1, c2);
  var f2 = -determinant2x2(a1, a2, c1, c2);
  var f3 = +determinant2x2(a1, a2, b1, b2);
  var det = a1 * d1 + b1 * d2 + c1 * d3;
  outI_3x3[0][0] = d1 / det;
  outI_3x3[1][0] = d2 / det;
  outI_3x3[2][0] = d3 / det;
  outI_3x3[0][1] = e1 / det;
  outI_3x3[1][1] = e2 / det;
  outI_3x3[2][1] = e3 / det;
  outI_3x3[0][2] = f1 / det;
  outI_3x3[1][2] = f2 / det;
  outI_3x3[2][2] = f3 / det;
}
function identity3x3(mat_3x3) {
  for (var i = 0; i < 3; i++) {
    mat_3x3[i][0] = mat_3x3[i][1] = mat_3x3[i][2] = 0;
    mat_3x3[i][i] = 1;
  }
}
function determinant3x3(mat_3x3) {
  return mat_3x3[0][0] * mat_3x3[1][1] * mat_3x3[2][2] + mat_3x3[1][0] * mat_3x3[2][1] * mat_3x3[0][2] + mat_3x3[2][0] * mat_3x3[0][1] * mat_3x3[1][2] - mat_3x3[0][0] * mat_3x3[2][1] * mat_3x3[1][2] - mat_3x3[1][0] * mat_3x3[0][1] * mat_3x3[2][2] - mat_3x3[2][0] * mat_3x3[1][1] * mat_3x3[0][2];
}
function quaternionToMatrix3x3(quat_4, mat_3x3) {
  var ww = quat_4[0] * quat_4[0];
  var wx = quat_4[0] * quat_4[1];
  var wy = quat_4[0] * quat_4[2];
  var wz = quat_4[0] * quat_4[3];
  var xx = quat_4[1] * quat_4[1];
  var yy = quat_4[2] * quat_4[2];
  var zz = quat_4[3] * quat_4[3];
  var xy = quat_4[1] * quat_4[2];
  var xz = quat_4[1] * quat_4[3];
  var yz = quat_4[2] * quat_4[3];
  var rr = xx + yy + zz;
  var f = 1 / (ww + rr);
  var s = (ww - rr) * f;
  f *= 2;
  mat_3x3[0][0] = xx * f + s;
  mat_3x3[1][0] = (xy + wz) * f;
  mat_3x3[2][0] = (xz - wy) * f;
  mat_3x3[0][1] = (xy - wz) * f;
  mat_3x3[1][1] = yy * f + s;
  mat_3x3[2][1] = (yz + wx) * f;
  mat_3x3[0][2] = (xz + wy) * f;
  mat_3x3[1][2] = (yz - wx) * f;
  mat_3x3[2][2] = zz * f + s;
}
function areEquals(a, b) {
  var eps = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-6;
  if (a.length !== b.length) {
    return false;
  }
  function isEqual(element, index) {
    return Math.abs(element - b[index]) <= eps;
  }
  return a.every(isEqual);
}
function roundNumber(num) {
  var digits = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!"".concat(num).includes("e")) {
    return +"".concat(Math.round("".concat(num, "e+").concat(digits)), "e-").concat(digits);
  }
  var arr = "".concat(num).split("e");
  var sig = "";
  if (+arr[1] + digits > 0) {
    sig = "+";
  }
  return +"".concat(Math.round("".concat(+arr[0], "e").concat(sig).concat(+arr[1] + digits)), "e-").concat(digits);
}
function roundVector(vector) {
  var out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  var digits = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  out[0] = roundNumber(vector[0], digits);
  out[1] = roundNumber(vector[1], digits);
  out[2] = roundNumber(vector[2], digits);
  return out;
}
function jacobiN(a, n, w, v) {
  var i;
  var j;
  var k;
  var iq;
  var ip;
  var numPos;
  var tresh;
  var theta;
  var t;
  var tau;
  var sm;
  var s;
  var h;
  var g;
  var c;
  var tmp;
  var b = createArray(n);
  var z = createArray(n);
  var vtkROTATE = function vtkROTATE2(aa, ii, jj, kk, ll) {
    g = aa[ii][jj];
    h = aa[kk][ll];
    aa[ii][jj] = g - s * (h + g * tau);
    aa[kk][ll] = h + s * (g - h * tau);
  };
  for (ip = 0; ip < n; ip++) {
    for (iq = 0; iq < n; iq++) {
      v[ip][iq] = 0;
    }
    v[ip][ip] = 1;
  }
  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip][ip];
    z[ip] = 0;
  }
  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0;
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip][iq]);
      }
    }
    if (sm === 0) {
      break;
    }
    if (i < 3) {
      tresh = 0.2 * sm / (n * n);
    } else {
      tresh = 0;
    }
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g = 100 * Math.abs(a[ip][iq]);
        if (i > 3 && Math.abs(w[ip]) + g === Math.abs(w[ip]) && Math.abs(w[iq]) + g === Math.abs(w[iq])) {
          a[ip][iq] = 0;
        } else if (Math.abs(a[ip][iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip][iq] / h;
          } else {
            theta = 0.5 * h / a[ip][iq];
            t = 1 / (Math.abs(theta) + Math.sqrt(1 + theta * theta));
            if (theta < 0) {
              t = -t;
            }
          }
          c = 1 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1 + c);
          h = t * a[ip][iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip][iq] = 0;
          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j, ip, j, iq);
          }
          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip, j, j, iq);
          }
          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip, j, iq, j);
          }
          for (j = 0; j < n; j++) {
            vtkROTATE(v, j, ip, j, iq);
          }
        }
      }
    }
    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0;
    }
  }
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro2("vtkMath::Jacobi: Error extracting eigenfunctions");
    return 0;
  }
  for (j = 0; j < n - 1; j++) {
    k = j;
    tmp = w[k];
    for (i = j + 1; i < n; i++) {
      if (w[i] >= tmp || Math.abs(w[i] - tmp) < VTK_SMALL_NUMBER) {
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      for (i = 0; i < n; i++) {
        tmp = v[i][j];
        v[i][j] = v[i][k];
        v[i][k] = tmp;
      }
    }
  }
  var ceil_half_n = (n >> 1) + (n & 1);
  for (j = 0; j < n; j++) {
    for (numPos = 0, i = 0; i < n; i++) {
      if (v[i][j] >= 0) {
        numPos++;
      }
    }
    if (numPos < ceil_half_n) {
      for (i = 0; i < n; i++) {
        v[i][j] *= -1;
      }
    }
  }
  return 1;
}
function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  var tmp = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
  tmp[0][0] = mat_3x3[0][0] + mat_3x3[1][1] + mat_3x3[2][2];
  tmp[1][1] = mat_3x3[0][0] - mat_3x3[1][1] - mat_3x3[2][2];
  tmp[2][2] = -mat_3x3[0][0] + mat_3x3[1][1] - mat_3x3[2][2];
  tmp[3][3] = -mat_3x3[0][0] - mat_3x3[1][1] + mat_3x3[2][2];
  tmp[0][1] = tmp[1][0] = mat_3x3[2][1] - mat_3x3[1][2];
  tmp[0][2] = tmp[2][0] = mat_3x3[0][2] - mat_3x3[2][0];
  tmp[0][3] = tmp[3][0] = mat_3x3[1][0] - mat_3x3[0][1];
  tmp[1][2] = tmp[2][1] = mat_3x3[1][0] + mat_3x3[0][1];
  tmp[1][3] = tmp[3][1] = mat_3x3[0][2] + mat_3x3[2][0];
  tmp[2][3] = tmp[3][2] = mat_3x3[2][1] + mat_3x3[1][2];
  var eigenvectors = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
  var eigenvalues = [0, 0, 0, 0];
  var NTemp = [0, 0, 0, 0];
  var eigenvectorsTemp = [0, 0, 0, 0];
  for (var i = 0; i < 4; i++) {
    NTemp[i] = tmp[i];
    eigenvectorsTemp[i] = eigenvectors[i];
  }
  jacobiN(NTemp, 4, eigenvalues, eigenvectorsTemp);
  quat_4[0] = eigenvectors[0][0];
  quat_4[1] = eigenvectors[1][0];
  quat_4[2] = eigenvectors[2][0];
  quat_4[3] = eigenvectors[3][0];
}
function multiplyQuaternion(quat_1, quat_2, quat_out) {
  var ww = quat_1[0] * quat_2[0];
  var wx = quat_1[0] * quat_2[1];
  var wy = quat_1[0] * quat_2[2];
  var wz = quat_1[0] * quat_2[3];
  var xw = quat_1[1] * quat_2[0];
  var xx = quat_1[1] * quat_2[1];
  var xy = quat_1[1] * quat_2[2];
  var xz = quat_1[1] * quat_2[3];
  var yw = quat_1[2] * quat_2[0];
  var yx = quat_1[2] * quat_2[1];
  var yy = quat_1[2] * quat_2[2];
  var yz = quat_1[2] * quat_2[3];
  var zw = quat_1[3] * quat_2[0];
  var zx = quat_1[3] * quat_2[1];
  var zy = quat_1[3] * quat_2[2];
  var zz = quat_1[3] * quat_2[3];
  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}
function orthogonalize3x3(a_3x3, out_3x3) {
  for (var i = 0; i < 3; i++) {
    out_3x3[0][i] = a_3x3[0][i];
    out_3x3[1][i] = a_3x3[1][i];
    out_3x3[2][i] = a_3x3[2][i];
  }
  var scale = createArray(3);
  var index = createArray(3);
  var largest;
  for (var _i = 0; _i < 3; _i++) {
    var _x = Math.abs(out_3x3[_i][0]);
    var _x2 = Math.abs(out_3x3[_i][1]);
    var _x3 = Math.abs(out_3x3[_i][2]);
    largest = _x2 > _x ? _x2 : _x;
    largest = _x3 > largest ? _x3 : largest;
    scale[_i] = 1;
    if (largest !== 0) {
      scale[_i] /= largest;
    }
  }
  var x1 = Math.abs(out_3x3[0][0]) * scale[0];
  var x2 = Math.abs(out_3x3[1][0]) * scale[1];
  var x3 = Math.abs(out_3x3[2][0]) * scale[2];
  index[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }
  if (x3 >= largest) {
    index[0] = 2;
  }
  if (index[0] !== 0) {
    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);
    scale[index[0]] = scale[0];
  }
  var y2 = Math.abs(out_3x3[1][1]) * scale[1];
  var y3 = Math.abs(out_3x3[2][1]) * scale[2];
  index[1] = 1;
  largest = y2;
  if (y3 >= largest) {
    index[1] = 2;
    vtkSwapVectors3(out_3x3[2], out_3x3[1]);
  }
  index[2] = 2;
  var flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (var _i2 = 0; _i2 < 3; _i2++) {
      out_3x3[0][_i2] = -out_3x3[0][_i2];
      out_3x3[1][_i2] = -out_3x3[1][_i2];
      out_3x3[2][_i2] = -out_3x3[2][_i2];
    }
  }
  var quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);
  if (flip) {
    for (var _i3 = 0; _i3 < 3; _i3++) {
      out_3x3[0][_i3] = -out_3x3[0][_i3];
      out_3x3[1][_i3] = -out_3x3[1][_i3];
      out_3x3[2][_i3] = -out_3x3[2][_i3];
    }
  }
  if (index[1] !== 1) {
    vtkSwapVectors3(out_3x3[index[1]], out_3x3[1]);
  }
  if (index[0] !== 0) {
    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);
  }
}
function diagonalize3x3(a_3x3, w_3, v_3x3) {
  var i;
  var j;
  var k;
  var maxI;
  var tmp;
  var maxVal;
  var C = [createArray(3), createArray(3), createArray(3)];
  var ATemp = createArray(3);
  var VTemp = createArray(3);
  for (i = 0; i < 3; i++) {
    C[i][0] = a_3x3[i][0];
    C[i][1] = a_3x3[i][1];
    C[i][2] = a_3x3[i][2];
    ATemp[i] = C[i];
    VTemp[i] = v_3x3[i];
  }
  jacobiN(ATemp, 3, w_3, VTemp);
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }
  transpose3x3(v_3x3, v_3x3);
  for (i = 0; i < 3; i++) {
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      maxVal = Math.abs(v_3x3[i][0]);
      maxI = 0;
      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i][j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        vtkSwapVectors3(v_3x3[i], v_3x3[maxI]);
      }
      if (v_3x3[maxI][maxI] < 0) {
        v_3x3[maxI][0] = -v_3x3[maxI][0];
        v_3x3[maxI][1] = -v_3x3[maxI][1];
        v_3x3[maxI][2] = -v_3x3[maxI][2];
      }
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;
      v_3x3[j][0] = 0;
      v_3x3[j][1] = 0;
      v_3x3[j][2] = 0;
      v_3x3[j][j] = 1;
      cross(v_3x3[maxI], v_3x3[j], v_3x3[k]);
      normalize(v_3x3[k]);
      cross(v_3x3[k], v_3x3[maxI], v_3x3[j]);
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }
  maxVal = Math.abs(v_3x3[0][0]);
  maxI = 0;
  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i][0]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  if (maxI !== 0) {
    tmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = tmp;
    vtkSwapVectors3(v_3x3[maxI], v_3x3[0]);
  }
  if (Math.abs(v_3x3[1][1]) < Math.abs(v_3x3[2][1])) {
    tmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = tmp;
    vtkSwapVectors3(v_3x3[2], v_3x3[1]);
  }
  for (i = 0; i < 2; i++) {
    if (v_3x3[i][i] < 0) {
      v_3x3[i][0] = -v_3x3[i][0];
      v_3x3[i][1] = -v_3x3[i][1];
      v_3x3[i][2] = -v_3x3[i][2];
    }
  }
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[2][0] = -v_3x3[2][0];
    v_3x3[2][1] = -v_3x3[2][1];
    v_3x3[2][2] = -v_3x3[2][2];
  }
  transpose3x3(v_3x3, v_3x3);
}
function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  var i;
  var B = [createArray(3), createArray(3), createArray(3)];
  for (i = 0; i < 3; i++) {
    B[0][i] = a_3x3[0][i];
    B[1][i] = a_3x3[1][i];
    B[2][i] = a_3x3[2][i];
  }
  var d = determinant3x3(B);
  if (d < 0) {
    for (i = 0; i < 3; i++) {
      B[0][i] = -B[0][i];
      B[1][i] = -B[1][i];
      B[2][i] = -B[2][i];
    }
  }
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}
function luFactorLinearSystem(A, index, size) {
  var i;
  var j;
  var k;
  var largest;
  var maxI = 0;
  var sum;
  var temp1;
  var temp2;
  var scale = createArray(size);
  for (i = 0; i < size; i++) {
    for (largest = 0, j = 0; j < size; j++) {
      if ((temp2 = Math.abs(A[i][j])) > largest) {
        largest = temp2;
      }
    }
    if (largest === 0) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    scale[i] = 1 / largest;
  }
  for (j = 0; j < size; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i][j];
      for (k = 0; k < i; k++) {
        sum -= A[i][k] * A[k][j];
      }
      A[i][j] = sum;
    }
    for (largest = 0, i = j; i < size; i++) {
      sum = A[i][j];
      for (k = 0; k < j; k++) {
        sum -= A[i][k] * A[k][j];
      }
      A[i][j] = sum;
      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    if (j !== maxI) {
      for (k = 0; k < size; k++) {
        temp1 = A[maxI][k];
        A[maxI][k] = A[j][k];
        A[j][k] = temp1;
      }
      scale[maxI] = scale[j];
    }
    index[j] = maxI;
    if (Math.abs(A[j][j]) <= VTK_SMALL_NUMBER) {
      vtkWarningMacro2("Unable to factor linear system");
      return 0;
    }
    if (j !== size - 1) {
      temp1 = 1 / A[j][j];
      for (i = j + 1; i < size; i++) {
        A[i][j] *= temp1;
      }
    }
  }
  return 1;
}
function luSolveLinearSystem(A, index, x, size) {
  var i;
  var j;
  var ii;
  var idx;
  var sum;
  for (ii = -1, i = 0; i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];
    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i][j] * x[j];
      }
    } else if (sum !== 0) {
      ii = i;
    }
    x[i] = sum;
  }
  for (i = size - 1; i >= 0; i--) {
    sum = x[i];
    for (j = i + 1; j < size; j++) {
      sum -= A[i][j] * x[j];
    }
    x[i] = sum / A[i][i];
  }
}
function solveLinearSystem(A, x, size) {
  if (size === 2) {
    var y = createArray(2);
    var det = determinant2x2(A[0][0], A[0][1], A[1][0], A[1][1]);
    if (det === 0) {
      return 0;
    }
    y[0] = (A[1][1] * x[0] - A[0][1] * x[1]) / det;
    y[1] = (-(A[1][0] * x[0]) + A[0][0] * x[1]) / det;
    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }
  if (size === 1) {
    if (A[0][0] === 0) {
      return 0;
    }
    x[0] /= A[0][0];
    return 1;
  }
  var index = createArray(size);
  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index, x, size);
  return 1;
}
function invertMatrix(A, AI, size) {
  var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var column = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
  var tmp1Size = index || createArray(size);
  var tmp2Size = column || createArray(size);
  if (luFactorLinearSystem(A, tmp1Size, size) === 0) {
    return 0;
  }
  for (var j = 0; j < size; j++) {
    for (var i = 0; i < size; i++) {
      tmp2Size[i] = 0;
    }
    tmp2Size[j] = 1;
    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);
    for (var _i4 = 0; _i4 < size; _i4++) {
      AI[_i4][j] = tmp2Size[_i4];
    }
  }
  return 1;
}
function estimateMatrixCondition(A, size) {
  var minValue = +Number.MAX_VALUE;
  var maxValue = -Number.MAX_VALUE;
  for (var i = 0; i < size; i++) {
    for (var j = i; j < size; j++) {
      if (Math.abs(A[i][j]) > max) {
        maxValue = Math.abs(A[i][j]);
      }
    }
  }
  for (var _i5 = 0; _i5 < size; _i5++) {
    if (Math.abs(A[_i5][_i5]) < min) {
      minValue = Math.abs(A[_i5][_i5]);
    }
  }
  if (minValue === 0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}
function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}
function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  if (numberOfSamples < xOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  var i;
  var j;
  var k;
  var XXt = createArray(xOrder);
  var eigenvals = createArray(xOrder);
  var eigenvecs = createArray(xOrder);
  for (i = 0; i < xOrder; i++) {
    eigenvecs[i] = createArray(xOrder);
    XXt[i] = createArray(xOrder);
    for (j = 0; j < xOrder; j++) {
      XXt[i][j] = 0;
    }
  }
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i][j] += xt[k][i] * xt[k][j];
      }
    }
  }
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i][j] = XXt[j][i];
    }
  }
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);
  for (i = 0; i < xOrder; i++) {
    mt[i][0] = eigenvecs[i][xOrder - 1];
  }
  return 1;
}
function solveLeastSquares(numberOfSamples, xt, xOrder, yt, yOrder, mt) {
  var checkHomogeneous = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : true;
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro2("Insufficient number of samples. Underdetermined.");
    return 0;
  }
  var homogenFlags = createArray(yOrder);
  var allHomogeneous = 1;
  var hmt;
  var homogRC = 0;
  var i;
  var j;
  var k;
  var someHomogeneous = 0;
  if (checkHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i][j]) > VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro2("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()");
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }
  if (someHomogeneous) {
    hmt = createArray(xOrder);
    for (j = 0; j < xOrder; j++) {
      hmt[j] = [0];
    }
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }
  var XXt = createArray(xOrder);
  var XXtI = createArray(xOrder);
  var XYt = createArray(xOrder);
  for (i = 0; i < xOrder; i++) {
    XXt[i] = createArray(xOrder);
    XXtI[i] = createArray(xOrder);
    for (j = 0; j < xOrder; j++) {
      XXt[i][j] = 0;
      XXtI[i][j] = 0;
    }
    XYt[i] = createArray(yOrder);
    for (j = 0; j < yOrder; j++) {
      XYt[i][j] = 0;
    }
  }
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i][j] += xt[k][i] * xt[k][j];
      }
      for (j = 0; j < yOrder; j++) {
        XYt[i][j] += xt[k][i] * yt[k][j];
      }
    }
  }
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i][j] = XXt[j][i];
    }
  }
  var successFlag = invertMatrix(XXt, XXtI, xOrder);
  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i][j] = 0;
        for (k = 0; k < xOrder; k++) {
          mt[i][j] += XXtI[i][k] * XYt[k][j];
        }
      }
    }
  }
  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        for (i = 0; i < xOrder; i++) {
          mt[i][j] = hmt[i][0];
        }
      }
    }
  }
  if (someHomogeneous) {
    return homogRC && successFlag;
  }
  return successFlag;
}
function hex2float(hexStr) {
  var outFloatArray = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0.5, 1];
  switch (hexStr.length) {
    case 3:
      outFloatArray[0] = parseInt(hexStr[0], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[2], 16) * 17 / 255;
      return outFloatArray;
    case 4:
      outFloatArray[0] = parseInt(hexStr[1], 16) * 17 / 255;
      outFloatArray[1] = parseInt(hexStr[2], 16) * 17 / 255;
      outFloatArray[2] = parseInt(hexStr[3], 16) * 17 / 255;
      return outFloatArray;
    case 6:
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9:
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}
function rgb2hsv(rgb, hsv) {
  var h;
  var s;
  var _rgb = _slicedToArray(rgb, 3), r = _rgb[0], g = _rgb[1], b = _rgb[2];
  var onethird = 1 / 3;
  var onesixth = 1 / 6;
  var twothird = 2 / 3;
  var cmax = r;
  var cmin = r;
  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  var v = cmax;
  if (v > 0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = onesixth * (g - b) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + onesixth * (b - r) / (cmax - cmin);
    } else {
      h = twothird + onesixth * (r - g) / (cmax - cmin);
    }
    if (h < 0) {
      h += 1;
    }
  } else {
    h = 0;
  }
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}
function hsv2rgb(hsv, rgb) {
  var _hsv = _slicedToArray(hsv, 3), h = _hsv[0], s = _hsv[1], v = _hsv[2];
  var onethird = 1 / 3;
  var onesixth = 1 / 6;
  var twothird = 2 / 3;
  var fivesixth = 5 / 6;
  var r;
  var g;
  var b;
  if (h > onesixth && h <= onethird) {
    g = 1;
    r = (onethird - h) / onesixth;
    b = 0;
  } else if (h > onethird && h <= 0.5) {
    g = 1;
    b = (h - onethird) / onesixth;
    r = 0;
  } else if (h > 0.5 && h <= twothird) {
    b = 1;
    g = (twothird - h) / onesixth;
    r = 0;
  } else if (h > twothird && h <= fivesixth) {
    b = 1;
    r = (h - twothird) / onesixth;
    g = 0;
  } else if (h > fivesixth && h <= 1) {
    r = 1;
    b = (1 - h) / onesixth;
    g = 0;
  } else {
    r = 1;
    g = h / onesixth;
    b = 0;
  }
  r = s * r + (1 - s);
  g = s * g + (1 - s);
  b = s * b + (1 - s);
  r *= v;
  g *= v;
  b *= v;
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function lab2xyz(lab, xyz) {
  var _lab = _slicedToArray(lab, 3), L = _lab[0], a = _lab[1], b = _lab[2];
  var var_Y = (L + 16) / 116;
  var var_X = a / 500 + var_Y;
  var var_Z = var_Y - b / 200;
  if (Math.pow(var_Y, 3) > 8856e-6) {
    var_Y = Math.pow(var_Y, 3);
  } else {
    var_Y = (var_Y - 16 / 116) / 7.787;
  }
  if (Math.pow(var_X, 3) > 8856e-6) {
    var_X = Math.pow(var_X, 3);
  } else {
    var_X = (var_X - 16 / 116) / 7.787;
  }
  if (Math.pow(var_Z, 3) > 8856e-6) {
    var_Z = Math.pow(var_Z, 3);
  } else {
    var_Z = (var_Z - 16 / 116) / 7.787;
  }
  var ref_X = 0.9505;
  var ref_Y = 1;
  var ref_Z = 1.089;
  xyz[0] = ref_X * var_X;
  xyz[1] = ref_Y * var_Y;
  xyz[2] = ref_Z * var_Z;
}
function xyz2lab(xyz, lab) {
  var _xyz = _slicedToArray(xyz, 3), x = _xyz[0], y = _xyz[1], z = _xyz[2];
  var ref_X = 0.9505;
  var ref_Y = 1;
  var ref_Z = 1.089;
  var var_X = x / ref_X;
  var var_Y = y / ref_Y;
  var var_Z = z / ref_Z;
  if (var_X > 8856e-6)
    var_X = Math.pow(var_X, 1 / 3);
  else
    var_X = 7.787 * var_X + 16 / 116;
  if (var_Y > 8856e-6)
    var_Y = Math.pow(var_Y, 1 / 3);
  else
    var_Y = 7.787 * var_Y + 16 / 116;
  if (var_Z > 8856e-6)
    var_Z = Math.pow(var_Z, 1 / 3);
  else
    var_Z = 7.787 * var_Z + 16 / 116;
  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}
function xyz2rgb(xyz, rgb) {
  var _xyz2 = _slicedToArray(xyz, 3), x = _xyz2[0], y = _xyz2[1], z = _xyz2[2];
  var r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  var g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  var b = x * 0.0557 + y * -0.204 + z * 1.057;
  if (r > 31308e-7)
    r = 1.055 * Math.pow(r, 1 / 2.4) - 0.055;
  else
    r *= 12.92;
  if (g > 31308e-7)
    g = 1.055 * Math.pow(g, 1 / 2.4) - 0.055;
  else
    g *= 12.92;
  if (b > 31308e-7)
    b = 1.055 * Math.pow(b, 1 / 2.4) - 0.055;
  else
    b *= 12.92;
  var maxVal = r;
  if (maxVal < g)
    maxVal = g;
  if (maxVal < b)
    maxVal = b;
  if (maxVal > 1) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }
  if (r < 0)
    r = 0;
  if (g < 0)
    g = 0;
  if (b < 0)
    b = 0;
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}
function rgb2xyz(rgb, xyz) {
  var _rgb2 = _slicedToArray(rgb, 3), r = _rgb2[0], g = _rgb2[1], b = _rgb2[2];
  if (r > 0.04045)
    r = Math.pow((r + 0.055) / 1.055, 2.4);
  else
    r /= 12.92;
  if (g > 0.04045)
    g = Math.pow((g + 0.055) / 1.055, 2.4);
  else
    g /= 12.92;
  if (b > 0.04045)
    b = Math.pow((b + 0.055) / 1.055, 2.4);
  else
    b /= 12.92;
  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}
function rgb2lab(rgb, lab) {
  var xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}
function lab2rgb(lab, rgb) {
  var xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}
function uninitializeBounds(bounds) {
  bounds[0] = 1;
  bounds[1] = -1;
  bounds[2] = 1;
  bounds[3] = -1;
  bounds[4] = 1;
  bounds[5] = -1;
  return bounds;
}
function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0);
}
function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
  return bounds;
}
function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}
function clampVector(vector, minVector, maxVector) {
  var out = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [0, 0, 0];
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);
  return out;
}
function clampAndNormalizeValue(value, range) {
  var result = 0;
  if (range[0] !== range[1]) {
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    result = (result - range[0]) / (range[1] - range[0]);
  }
  return result;
}
function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }
  for (var i = 0; i < 6; i += 2) {
    if (extent1[i] < extent2[i] || extent1[i] > extent2[i + 1] || extent1[i + 1] < extent2[i] || extent1[i + 1] > extent2[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (var i = 0; i < 6; i += 2) {
    if (bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] || bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] || bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]) {
      return 0;
    }
  }
  return 1;
}
function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (var i = 0; i < 3; i++) {
    if (point_3[i] + delta_3[i] < bounds_6[2 * i] || point_3[i] - delta_3[i] > bounds_6[2 * i + 1]) {
      return 0;
    }
  }
  return 1;
}
function solve3PointCircle(p1, p2, p3, center) {
  var v21 = createArray(3);
  var v32 = createArray(3);
  var v13 = createArray(3);
  var v12 = createArray(3);
  var v23 = createArray(3);
  var v31 = createArray(3);
  for (var i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }
  var norm12 = norm(v12);
  var norm23 = norm(v23);
  var norm13 = norm(v13);
  var crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  var normCross = norm(crossv21v32);
  var radius = norm12 * norm23 * norm13 / (2 * normCross);
  var normCross22 = 2 * normCross * normCross;
  var alpha = norm23 * norm23 * dot(v21, v31) / normCross22;
  var beta = norm13 * norm13 * dot(v12, v32) / normCross22;
  var gamma = norm12 * norm12 * dot(v13, v23) / normCross22;
  for (var _i6 = 0; _i6 < 3; ++_i6) {
    center[_i6] = alpha * p1[_i6] + beta * p2[_i6] + gamma * p3[_i6];
  }
  return radius;
}
function createUninitializedBounds() {
  return [].concat([
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE,
    Number.MAX_VALUE,
    -Number.MAX_VALUE
  ]);
}
function getMajorAxisIndex(vector) {
  var maxValue = -1;
  var axisIndex = -1;
  for (var i = 0; i < vector.length; i++) {
    var value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }
  return axisIndex;
}
function floatToHex2(value) {
  var integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return "0".concat(integer.toString(16));
}
function floatRGB2HexCode(rgbArray) {
  var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "#";
  return "".concat(prefix).concat(rgbArray.map(floatToHex2).join(""));
}
function floatToChar(f) {
  return Math.round(f * 255);
}
function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return "rgb(".concat(rgbArray.map(floatToChar).join(", "), ")");
  }
  return "rgba(".concat(floatToChar(rgbArray[0] || 0), ", ").concat(floatToChar(rgbArray[1] || 0), ", ").concat(floatToChar(rgbArray[2] || 0), ", ").concat(rgbArray[3] || 0, ")");
}
var import_seedrandom, vtkErrorMacro2, vtkWarningMacro2, randomSeedValue, VTK_MAX_ROTATIONS, VTK_SMALL_NUMBER, Pi, round, floor, ceil, min, max, ceilLog2, factorial, gaussian, areMatricesEqual, getScalarTypeFittingRange, getAdjustedScalarRange, inf, negInf, isInf, isFinite, isNaN2, isNan, vtkMath, vtkMath$1;
var init_Math = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/Math/index.js"() {
    init_slicedToArray();
    import_seedrandom = __toESM(require_seedrandom2());
    init_macros();
    vtkErrorMacro2 = macro.vtkErrorMacro;
    vtkWarningMacro2 = macro.vtkWarningMacro;
    randomSeedValue = 0;
    VTK_MAX_ROTATIONS = 20;
    VTK_SMALL_NUMBER = 1e-12;
    Pi = function Pi2() {
      return Math.PI;
    };
    round = Math.round;
    floor = Math.floor;
    ceil = Math.ceil;
    min = Math.min;
    max = Math.max;
    ceilLog2 = notImplemented("ceilLog2");
    factorial = notImplemented("factorial");
    gaussian = notImplemented("gaussian");
    areMatricesEqual = areEquals;
    getScalarTypeFittingRange = notImplemented("GetScalarTypeFittingRange");
    getAdjustedScalarRange = notImplemented("GetAdjustedScalarRange");
    inf = Infinity;
    negInf = -Infinity;
    isInf = function isInf2(value) {
      return !Number.isFinite(value);
    };
    isFinite = Number.isFinite;
    isNaN2 = Number.isNaN;
    isNan = isNaN2;
    vtkMath = {
      Pi,
      radiansFromDegrees,
      degreesFromRadians,
      round,
      floor,
      ceil,
      ceilLog2,
      min,
      max,
      arrayMin,
      arrayMax,
      arrayRange,
      isPowerOfTwo,
      nearestPowerOfTwo,
      factorial,
      binomial,
      beginCombination,
      nextCombination,
      randomSeed,
      getSeed,
      random,
      gaussian,
      add,
      subtract,
      multiplyScalar,
      multiplyScalar2D,
      multiplyAccumulate,
      multiplyAccumulate2D,
      dot,
      outer,
      cross,
      norm,
      normalize,
      perpendiculars,
      projectVector,
      projectVector2D,
      distance2BetweenPoints,
      angleBetweenVectors,
      gaussianAmplitude,
      gaussianWeight,
      dot2D,
      outer2D,
      norm2D,
      normalize2D,
      determinant2x2,
      LUFactor3x3,
      LUSolve3x3,
      linearSolve3x3,
      multiply3x3_vect3,
      multiply3x3_mat3,
      multiplyMatrix,
      transpose3x3,
      invert3x3,
      identity3x3,
      determinant3x3,
      quaternionToMatrix3x3,
      areEquals,
      areMatricesEqual,
      roundNumber,
      roundVector,
      matrix3x3ToQuaternion,
      multiplyQuaternion,
      orthogonalize3x3,
      diagonalize3x3,
      singularValueDecomposition3x3,
      solveLinearSystem,
      invertMatrix,
      luFactorLinearSystem,
      luSolveLinearSystem,
      estimateMatrixCondition,
      jacobi,
      jacobiN,
      solveHomogeneousLeastSquares,
      solveLeastSquares,
      hex2float,
      rgb2hsv,
      hsv2rgb,
      lab2xyz,
      xyz2lab,
      xyz2rgb,
      rgb2xyz,
      rgb2lab,
      lab2rgb,
      uninitializeBounds,
      areBoundsInitialized,
      computeBoundsFromPoints,
      clampValue,
      clampVector,
      clampAndNormalizeValue,
      getScalarTypeFittingRange,
      getAdjustedScalarRange,
      extentIsWithinOtherExtent,
      boundsIsWithinOtherBounds,
      pointIsWithinBounds,
      solve3PointCircle,
      inf,
      negInf,
      isInf,
      isNan: isNaN2,
      isNaN: isNaN2,
      isFinite,
      createUninitializedBounds,
      getMajorAxisIndex,
      floatToHex2,
      floatRGB2HexCode,
      float2CssRGBA
    };
    vtkMath$1 = Object.freeze({
      __proto__: null,
      Pi,
      radiansFromDegrees,
      degreesFromRadians,
      round,
      floor,
      ceil,
      min,
      max,
      arrayMin,
      arrayMax,
      arrayRange,
      ceilLog2,
      factorial,
      nearestPowerOfTwo,
      isPowerOfTwo,
      binomial,
      beginCombination,
      nextCombination,
      randomSeed,
      getSeed,
      random,
      gaussian,
      add,
      subtract,
      multiplyScalar,
      multiplyScalar2D,
      multiplyAccumulate,
      multiplyAccumulate2D,
      dot,
      outer,
      cross,
      norm,
      normalize,
      perpendiculars,
      projectVector,
      dot2D,
      projectVector2D,
      distance2BetweenPoints,
      angleBetweenVectors,
      signedAngleBetweenVectors,
      gaussianAmplitude,
      gaussianWeight,
      outer2D,
      norm2D,
      normalize2D,
      determinant2x2,
      LUFactor3x3,
      LUSolve3x3,
      linearSolve3x3,
      multiply3x3_vect3,
      multiply3x3_mat3,
      multiplyMatrix,
      transpose3x3,
      invert3x3,
      identity3x3,
      determinant3x3,
      quaternionToMatrix3x3,
      areEquals,
      areMatricesEqual,
      roundNumber,
      roundVector,
      jacobiN,
      matrix3x3ToQuaternion,
      multiplyQuaternion,
      orthogonalize3x3,
      diagonalize3x3,
      singularValueDecomposition3x3,
      luFactorLinearSystem,
      luSolveLinearSystem,
      solveLinearSystem,
      invertMatrix,
      estimateMatrixCondition,
      jacobi,
      solveHomogeneousLeastSquares,
      solveLeastSquares,
      hex2float,
      rgb2hsv,
      hsv2rgb,
      lab2xyz,
      xyz2lab,
      xyz2rgb,
      rgb2xyz,
      rgb2lab,
      lab2rgb,
      uninitializeBounds,
      areBoundsInitialized,
      computeBoundsFromPoints,
      clampValue,
      clampVector,
      clampAndNormalizeValue,
      getScalarTypeFittingRange,
      getAdjustedScalarRange,
      extentIsWithinOtherExtent,
      boundsIsWithinOtherBounds,
      pointIsWithinBounds,
      solve3PointCircle,
      inf,
      negInf,
      isInf,
      isFinite,
      isNaN: isNaN2,
      isNan,
      createUninitializedBounds,
      getMajorAxisIndex,
      floatToHex2,
      floatRGB2HexCode,
      float2CssRGBA,
      "default": vtkMath
    });
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Camera.js
var Camera_exports = {};
__export(Camera_exports, {
  DEFAULT_VALUES: () => DEFAULT_VALUES,
  default: () => vtkCamera$1,
  extend: () => extend,
  newInstance: () => newInstance2
});
function vtkCamera(publicAPI, model) {
  model.classHierarchy.push("vtkCamera");
  var origin = new Float64Array(3);
  var dopbasis = new Float64Array([0, 0, -1]);
  var upbasis = new Float64Array([0, 1, 0]);
  var tmpMatrix = mat4_exports.identity(new Float64Array(16));
  var tmpvec12 = new Float64Array(3);
  var tmpvec2 = new Float64Array(3);
  var tmpvec3 = new Float64Array(3);
  var rotateMatrix = mat4_exports.identity(new Float64Array(16));
  var trans = mat4_exports.identity(new Float64Array(16));
  var newPosition = new Float64Array(3);
  var newFocalPoint = new Float64Array(3);
  function computeViewPlaneNormal() {
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }
  publicAPI.orthogonalizeViewUp = function() {
    var vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];
    publicAPI.modified();
  };
  publicAPI.setPosition = function(x, y, z) {
    if (x === model.position[0] && y === model.position[1] && z === model.position[2]) {
      return;
    }
    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setFocalPoint = function(x, y, z) {
    if (x === model.focalPoint[0] && y === model.focalPoint[1] && z === model.focalPoint[2]) {
      return;
    }
    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.setDistance = function(d) {
    if (model.distance === d) {
      return;
    }
    model.distance = d;
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro2("Distance is set to minimum.");
    }
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    publicAPI.modified();
  };
  publicAPI.computeDistance = function() {
    var dx = model.focalPoint[0] - model.position[0];
    var dy = model.focalPoint[1] - model.position[1];
    var dz = model.focalPoint[2] - model.position[2];
    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro2("Distance is set to minimum.");
      var vec = model.directionOfProjection;
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }
    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.dolly = function(amount) {
    if (amount <= 0) {
      return;
    }
    var d = model.distance / amount;
    publicAPI.setPosition(model.focalPoint[0] - d * model.directionOfProjection[0], model.focalPoint[1] - d * model.directionOfProjection[1], model.focalPoint[2] - d * model.directionOfProjection[2]);
  };
  publicAPI.roll = function(angle) {
    var eye = model.position;
    var at = model.focalPoint;
    var up = model.viewUp;
    var viewUpVec4 = new Float64Array([up[0], up[1], up[2], 0]);
    mat4_exports.identity(rotateMatrix);
    var viewDir = new Float64Array([at[0] - eye[0], at[1] - eye[1], at[2] - eye[2]]);
    mat4_exports.rotate(rotateMatrix, rotateMatrix, radiansFromDegrees(angle), viewDir);
    vec4_exports.transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);
    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];
    publicAPI.modified();
  };
  publicAPI.azimuth = function(angle) {
    var fp = model.focalPoint;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.yaw = function(angle) {
    var position = model.position;
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), model.viewUp);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint(newFocalPoint[0], newFocalPoint[1], newFocalPoint[2]);
  };
  publicAPI.elevation = function(angle) {
    var fp = model.focalPoint;
    var vt = publicAPI.getViewMatrix();
    var axis = [-vt[0], -vt[1], -vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, fp);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-fp[0], -fp[1], -fp[2]]);
    vec3_exports.transformMat4(newPosition, model.position, trans);
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };
  publicAPI.pitch = function(angle) {
    var position = model.position;
    var vt = publicAPI.getViewMatrix();
    var axis = [vt[0], vt[1], vt[2]];
    mat4_exports.identity(trans);
    mat4_exports.translate(trans, trans, position);
    mat4_exports.rotate(trans, trans, radiansFromDegrees(angle), axis);
    mat4_exports.translate(trans, trans, [-position[0], -position[1], -position[2]]);
    vec3_exports.transformMat4(newFocalPoint, model.focalPoint, trans);
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(newFocalPoint));
  };
  publicAPI.zoom = function(factor) {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };
  publicAPI.translate = function(x, y, z) {
    var offset = [x, y, z];
    add(model.position, offset, model.position);
    add(model.focalPoint, offset, model.focalPoint);
    publicAPI.computeDistance();
    publicAPI.modified();
  };
  publicAPI.applyTransform = function(transformMat4) {
    var vuOld = [].concat(_toConsumableArray(model.viewUp), [1]);
    var posNew = [];
    var fpNew = [];
    var vuNew = [];
    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];
    vec4_exports.transformMat4(posNew, [].concat(_toConsumableArray(model.position), [1]), transformMat4);
    vec4_exports.transformMat4(fpNew, [].concat(_toConsumableArray(model.focalPoint), [1]), transformMat4);
    vec4_exports.transformMat4(vuNew, vuOld, transformMat4);
    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];
    publicAPI.setPosition.apply(publicAPI, _toConsumableArray(posNew.slice(0, 3)));
    publicAPI.setFocalPoint.apply(publicAPI, _toConsumableArray(fpNew.slice(0, 3)));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(vuNew.slice(0, 3)));
  };
  publicAPI.getThickness = function() {
    return model.clippingRange[1] - model.clippingRange[0];
  };
  publicAPI.setThickness = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro2("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.clippingRange[0], model.clippingRange[0] + t);
  };
  publicAPI.setThicknessFromFocalPoint = function(thickness) {
    var t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro2("Thickness is set to minimum.");
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };
  publicAPI.setRoll = function(angle) {
  };
  publicAPI.getRoll = function() {
  };
  publicAPI.setObliqueAngles = function(alpha, beta) {
  };
  publicAPI.getOrientation = function() {
  };
  publicAPI.getOrientationWXYZ = function() {
  };
  publicAPI.getFrustumPlanes = function(aspect) {
  };
  publicAPI.getCameraLightTransformMatrix = function() {
  };
  publicAPI.deepCopy = function(sourceCamera) {
  };
  publicAPI.physicalOrientationToWorldDirection = function(ori) {
    var oriq = quat_exports.fromValues(ori[0], ori[1], ori[2], ori[3]);
    var coriq = quat_exports.create();
    var qdir = quat_exports.fromValues(0, 0, 1, 0);
    quat_exports.conjugate(coriq, oriq);
    quat_exports.multiply(qdir, oriq, qdir);
    quat_exports.multiply(qdir, qdir, coriq);
    return [qdir[0], qdir[1], qdir[2]];
  };
  publicAPI.getPhysicalToWorldMatrix = function(result) {
    publicAPI.getWorldToPhysicalMatrix(result);
    mat4_exports.invert(result, result);
  };
  publicAPI.getWorldToPhysicalMatrix = function(result) {
    mat4_exports.identity(result);
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    mat4_exports.transpose(result, result);
    vec3_exports.set(tmpvec12, 1 / model.physicalScale, 1 / model.physicalScale, 1 / model.physicalScale);
    mat4_exports.scale(result, result, tmpvec12);
    mat4_exports.translate(result, result, model.physicalTranslation);
  };
  publicAPI.computeViewParametersFromViewMatrix = function(vmat) {
    mat4_exports.invert(tmpMatrix, vmat);
    vec3_exports.transformMat4(tmpvec12, origin, tmpMatrix);
    publicAPI.computeDistance();
    var oldDist = model.distance;
    publicAPI.setPosition(tmpvec12[0], tmpvec12[1], tmpvec12[2]);
    vec3_exports.transformMat4(tmpvec2, dopbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec2, tmpvec2, tmpvec12);
    vec3_exports.normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);
    vec3_exports.transformMat4(tmpvec3, upbasis, tmpMatrix);
    vec3_exports.subtract(tmpvec3, tmpvec3, tmpvec12);
    vec3_exports.normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);
    publicAPI.setDistance(oldDist);
  };
  publicAPI.computeViewParametersFromPhysicalMatrix = function(mat) {
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);
    mat4_exports.multiply(tmpMatrix, mat, tmpMatrix);
    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };
  publicAPI.setViewMatrix = function(mat) {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      mat4_exports.copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      mat4_exports.transpose(model.viewMatrix, model.viewMatrix);
    }
  };
  publicAPI.getViewMatrix = function() {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }
    mat4_exports.lookAt(tmpMatrix, model.position, model.focalPoint, model.viewUp);
    mat4_exports.transpose(tmpMatrix, tmpMatrix);
    var result = new Float64Array(16);
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.setProjectionMatrix = function(mat) {
    model.projectionMatrix = mat;
  };
  publicAPI.getProjectionMatrix = function(aspect, nearz, farz) {
    var result = new Float64Array(16);
    mat4_exports.identity(result);
    if (model.projectionMatrix) {
      var scale = 1 / model.physicalScale;
      vec3_exports.set(tmpvec12, scale, scale, scale);
      mat4_exports.copy(result, model.projectionMatrix);
      mat4_exports.scale(result, result, tmpvec12);
      mat4_exports.transpose(result, result);
      return result;
    }
    mat4_exports.identity(tmpMatrix);
    var cWidth = model.clippingRange[1] - model.clippingRange[0];
    var cRange = [model.clippingRange[0] + (nearz + 1) * cWidth / 2, model.clippingRange[0] + (farz + 1) * cWidth / 2];
    if (model.parallelProjection) {
      var width = model.parallelScale * aspect;
      var height = model.parallelScale;
      var xmin = (model.windowCenter[0] - 1) * width;
      var xmax = (model.windowCenter[0] + 1) * width;
      var ymin = (model.windowCenter[1] - 1) * height;
      var ymax = (model.windowCenter[1] + 1) * height;
      mat4_exports.ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      mat4_exports.transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error("Off-Axis projection is not supported at this time");
    } else {
      var tmp = Math.tan(radiansFromDegrees(model.viewAngle) / 2);
      var _width;
      var _height;
      if (model.useHorizontalViewAngle === true) {
        _width = model.clippingRange[0] * tmp;
        _height = model.clippingRange[0] * tmp / aspect;
      } else {
        _width = model.clippingRange[0] * tmp * aspect;
        _height = model.clippingRange[0] * tmp;
      }
      var _xmin = (model.windowCenter[0] - 1) * _width;
      var _xmax = (model.windowCenter[0] + 1) * _width;
      var _ymin = (model.windowCenter[1] - 1) * _height;
      var _ymax = (model.windowCenter[1] + 1) * _height;
      var znear = cRange[0];
      var zfar = cRange[1];
      tmpMatrix[0] = 2 * znear / (_xmax - _xmin);
      tmpMatrix[5] = 2 * znear / (_ymax - _ymin);
      tmpMatrix[2] = (_xmin + _xmax) / (_xmax - _xmin);
      tmpMatrix[6] = (_ymin + _ymax) / (_ymax - _ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1;
      tmpMatrix[11] = -2 * znear * zfar / (zfar - znear);
      tmpMatrix[15] = 0;
    }
    mat4_exports.copy(result, tmpMatrix);
    return result;
  };
  publicAPI.getCompositeProjectionMatrix = function(aspect, nearz, farz) {
    var vMat = publicAPI.getViewMatrix();
    var pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    mat4_exports.multiply(pMat, vMat, pMat);
    return pMat;
  };
  publicAPI.setDirectionOfProjection = function(x, y, z) {
    if (model.directionOfProjection[0] === x && model.directionOfProjection[1] === y && model.directionOfProjection[2] === z) {
      return;
    }
    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;
    var vec = model.directionOfProjection;
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };
  publicAPI.setDeviceAngles = function(alpha, beta, gamma, screen) {
    var physVRight = [3];
    cross(model.physicalViewNorth, model.physicalViewUp, physVRight);
    var rotmat = mat4_exports.identity(new Float64Array(16));
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(alpha), model.physicalViewUp);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(beta), physVRight);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(gamma), model.physicalViewNorth);
    mat4_exports.rotate(rotmat, rotmat, radiansFromDegrees(-screen), model.physicalViewUp);
    var dop = new Float64Array([-model.physicalViewUp[0], -model.physicalViewUp[1], -model.physicalViewUp[2]]);
    var vup = new Float64Array(model.physicalViewNorth);
    vec3_exports.transformMat4(dop, dop, rotmat);
    vec3_exports.transformMat4(vup, vup, rotmat);
    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };
  publicAPI.setOrientationWXYZ = function(degrees, x, y, z) {
    var quatMat = mat4_exports.identity(new Float64Array(16));
    if (degrees !== 0 && (x !== 0 || y !== 0 || z !== 0)) {
      var angle = radiansFromDegrees(degrees);
      var q = quat_exports.create();
      quat_exports.setAxisAngle(q, [x, y, z], angle);
      mat4_exports.fromQuat(quatMat, q);
    }
    var newdop = new Float64Array(3);
    vec3_exports.transformMat4(newdop, [0, 0, -1], quatMat);
    var newvup = new Float64Array(3);
    vec3_exports.transformMat4(newvup, [0, 1, 0], quatMat);
    publicAPI.setDirectionOfProjection.apply(publicAPI, _toConsumableArray(newdop));
    publicAPI.setViewUp.apply(publicAPI, _toConsumableArray(newvup));
    publicAPI.modified();
  };
  publicAPI.computeClippingRange = function(bounds) {
    var vn = null;
    var position = null;
    vn = model.viewPlaneNormal;
    position = model.position;
    var a = -vn[0];
    var b = -vn[1];
    var c = -vn[2];
    var d = -(a * position[0] + b * position[1] + c * position[2]);
    var range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];
    for (var k = 0; k < 2; k++) {
      for (var j = 0; j < 2; j++) {
        for (var i = 0; i < 2; i++) {
          var dist = a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }
    return range;
  };
}
function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["distance"]);
  macro.setGet(publicAPI, model, ["parallelProjection", "useHorizontalViewAngle", "viewAngle", "parallelScale", "useOffAxisProjection", "freezeFocalPoint", "physicalScale"]);
  macro.getArray(publicAPI, model, ["directionOfProjection", "viewPlaneNormal", "position", "focalPoint"]);
  macro.setGetArray(publicAPI, model, ["clippingRange", "windowCenter"], 2);
  macro.setGetArray(publicAPI, model, ["viewUp", "screenBottomLeft", "screenBottomRight", "screenTopRight", "physicalTranslation", "physicalViewUp", "physicalViewNorth"], 3);
  vtkCamera(publicAPI, model);
}
var vtkDebugMacro2, DEFAULT_VALUES, newInstance2, vtkCamera$1;
var init_Camera = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Camera.js"() {
    init_toConsumableArray();
    init_esm();
    init_macros();
    init_Math();
    vtkDebugMacro2 = macro.vtkDebugMacro;
    DEFAULT_VALUES = {
      position: [0, 0, 1],
      focalPoint: [0, 0, 0],
      viewUp: [0, 1, 0],
      directionOfProjection: [0, 0, -1],
      parallelProjection: false,
      useHorizontalViewAngle: false,
      viewAngle: 30,
      parallelScale: 1,
      clippingRange: [0.01, 1000.01],
      windowCenter: [0, 0],
      viewPlaneNormal: [0, 0, 1],
      useOffAxisProjection: false,
      screenBottomLeft: [-0.5, -0.5, -0.5],
      screenBottomRight: [0.5, -0.5, -0.5],
      screenTopRight: [0.5, 0.5, -0.5],
      freezeFocalPoint: false,
      projectionMatrix: null,
      viewMatrix: null,
      physicalTranslation: [0, 0, 0],
      physicalScale: 1,
      physicalViewUp: [0, 1, 0],
      physicalViewNorth: [0, 0, -1]
    };
    newInstance2 = macro.newInstance(extend, "vtkCamera");
    vtkCamera$1 = {
      newInstance: newInstance2,
      extend
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/Math.js
var Math_exports = {};
__export(Math_exports, {
  LUFactor3x3: () => LUFactor3x3,
  LUSolve3x3: () => LUSolve3x3,
  Pi: () => Pi,
  add: () => add,
  angleBetweenVectors: () => angleBetweenVectors,
  areBoundsInitialized: () => areBoundsInitialized,
  areEquals: () => areEquals,
  areMatricesEqual: () => areMatricesEqual,
  arrayMax: () => arrayMax,
  arrayMin: () => arrayMin,
  arrayRange: () => arrayRange,
  beginCombination: () => beginCombination,
  binomial: () => binomial,
  boundsIsWithinOtherBounds: () => boundsIsWithinOtherBounds,
  ceil: () => ceil,
  ceilLog2: () => ceilLog2,
  clampAndNormalizeValue: () => clampAndNormalizeValue,
  clampValue: () => clampValue,
  clampVector: () => clampVector,
  computeBoundsFromPoints: () => computeBoundsFromPoints,
  createUninitializedBounds: () => createUninitializedBounds,
  cross: () => cross,
  default: () => vtkMath,
  degreesFromRadians: () => degreesFromRadians,
  determinant2x2: () => determinant2x2,
  determinant3x3: () => determinant3x3,
  diagonalize3x3: () => diagonalize3x3,
  distance2BetweenPoints: () => distance2BetweenPoints,
  dot: () => dot,
  dot2D: () => dot2D,
  estimateMatrixCondition: () => estimateMatrixCondition,
  extentIsWithinOtherExtent: () => extentIsWithinOtherExtent,
  factorial: () => factorial,
  float2CssRGBA: () => float2CssRGBA,
  floatRGB2HexCode: () => floatRGB2HexCode,
  floatToHex2: () => floatToHex2,
  floor: () => floor,
  gaussian: () => gaussian,
  gaussianAmplitude: () => gaussianAmplitude,
  gaussianWeight: () => gaussianWeight,
  getAdjustedScalarRange: () => getAdjustedScalarRange,
  getMajorAxisIndex: () => getMajorAxisIndex,
  getScalarTypeFittingRange: () => getScalarTypeFittingRange,
  getSeed: () => getSeed,
  hex2float: () => hex2float,
  hsv2rgb: () => hsv2rgb,
  identity3x3: () => identity3x3,
  inf: () => inf,
  invert3x3: () => invert3x3,
  invertMatrix: () => invertMatrix,
  isFinite: () => isFinite,
  isInf: () => isInf,
  isNaN: () => isNaN2,
  isNan: () => isNan,
  isPowerOfTwo: () => isPowerOfTwo,
  jacobi: () => jacobi,
  jacobiN: () => jacobiN,
  lab2rgb: () => lab2rgb,
  lab2xyz: () => lab2xyz,
  linearSolve3x3: () => linearSolve3x3,
  luFactorLinearSystem: () => luFactorLinearSystem,
  luSolveLinearSystem: () => luSolveLinearSystem,
  matrix3x3ToQuaternion: () => matrix3x3ToQuaternion,
  max: () => max,
  min: () => min,
  multiply3x3_mat3: () => multiply3x3_mat3,
  multiply3x3_vect3: () => multiply3x3_vect3,
  multiplyAccumulate: () => multiplyAccumulate,
  multiplyAccumulate2D: () => multiplyAccumulate2D,
  multiplyMatrix: () => multiplyMatrix,
  multiplyQuaternion: () => multiplyQuaternion,
  multiplyScalar: () => multiplyScalar,
  multiplyScalar2D: () => multiplyScalar2D,
  nearestPowerOfTwo: () => nearestPowerOfTwo,
  negInf: () => negInf,
  nextCombination: () => nextCombination,
  norm: () => norm,
  norm2D: () => norm2D,
  normalize: () => normalize,
  normalize2D: () => normalize2D,
  orthogonalize3x3: () => orthogonalize3x3,
  outer: () => outer,
  outer2D: () => outer2D,
  perpendiculars: () => perpendiculars,
  pointIsWithinBounds: () => pointIsWithinBounds,
  projectVector: () => projectVector,
  projectVector2D: () => projectVector2D,
  quaternionToMatrix3x3: () => quaternionToMatrix3x3,
  radiansFromDegrees: () => radiansFromDegrees,
  random: () => random,
  randomSeed: () => randomSeed,
  rgb2hsv: () => rgb2hsv,
  rgb2lab: () => rgb2lab,
  rgb2xyz: () => rgb2xyz,
  round: () => round,
  roundNumber: () => roundNumber,
  roundVector: () => roundVector,
  signedAngleBetweenVectors: () => signedAngleBetweenVectors,
  singularValueDecomposition3x3: () => singularValueDecomposition3x3,
  solve3PointCircle: () => solve3PointCircle,
  solveHomogeneousLeastSquares: () => solveHomogeneousLeastSquares,
  solveLeastSquares: () => solveLeastSquares,
  solveLinearSystem: () => solveLinearSystem,
  subtract: () => subtract,
  transpose3x3: () => transpose3x3,
  uninitializeBounds: () => uninitializeBounds,
  xyz2lab: () => xyz2lab,
  xyz2rgb: () => xyz2rgb
});
var import_seedrandom2;
var init_Math2 = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/Math.js"() {
    init_slicedToArray();
    import_seedrandom2 = __toESM(require_seedrandom2());
    init_macros();
    init_Math();
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/Plane.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function evaluate(normal, origin, x) {
  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
}
function distanceToPlane(x, origin, normal) {
  var distance = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  return Math.abs(distance);
}
function projectPoint(x, origin, normal, xproj) {
  var xo = [];
  subtract(x, origin, xo);
  var t = dot(normal, xo);
  xproj[0] = x[0] - t * normal[0];
  xproj[1] = x[1] - t * normal[1];
  xproj[2] = x[2] - t * normal[2];
}
function projectVector2(v, normal, vproj) {
  var t = dot(v, normal);
  var n2 = dot(normal, normal);
  if (n2 === 0) {
    n2 = 1;
  }
  vproj[0] = v[0] - t * normal[0] / n2;
  vproj[1] = v[1] - t * normal[1] / n2;
  vproj[2] = v[2] - t * normal[2] / n2;
  return vproj;
}
function generalizedProjectPoint(x, origin, normal, xproj) {
  var xo = [];
  subtract(x, origin, xo);
  var t = dot(normal, xo);
  var n2 = dot(normal, normal);
  if (n2 !== 0) {
    xproj[0] = x[0] - t * normal[0] / n2;
    xproj[1] = x[1] - t * normal[1] / n2;
    xproj[2] = x[2] - t * normal[2] / n2;
  } else {
    xproj[0] = x[0];
    xproj[1] = x[1];
    xproj[2] = x[2];
  }
}
function intersectWithLine(p1, p2, origin, normal) {
  var outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: []
  };
  var p21 = [];
  var p1Origin = [];
  subtract(p2, p1, p21);
  subtract(origin, p1, p1Origin);
  var num = dot(normal, p1Origin);
  var den = dot(normal, p21);
  var fabsden;
  var fabstolerance;
  if (den < 0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }
  outObj.t = num / den;
  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];
  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
  return outObj;
}
function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
  var outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null
  };
  var cross$1 = [];
  cross(plane1Normal, plane2Normal, cross$1);
  var absCross = cross$1.map(function(n) {
    return Math.abs(n);
  });
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    var v = [];
    subtract(plane1Origin, plane2Origin, v);
    if (dot(plane1Normal, v) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }
  var maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = "x";
  } else if (absCross[1] > absCross[2]) {
    maxc = "y";
  } else {
    maxc = "z";
  }
  var iP = [];
  var d1 = -dot(plane1Normal, plane1Origin);
  var d2 = -dot(plane2Normal, plane2Origin);
  switch (maxc) {
    case "x":
      iP[0] = 0;
      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];
      break;
    case "y":
      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];
      iP[1] = 0;
      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
      break;
    case "z":
      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];
      iP[2] = 0;
      break;
  }
  outObj.l0 = iP;
  add(iP, cross$1, outObj.l1);
  outObj.intersection = true;
  return outObj;
}
function vtkPlane(publicAPI, model) {
  model.classHierarchy.push("vtkPlane");
  publicAPI.distanceToPlane = function(x) {
    return distanceToPlane(x, model.origin, model.normal);
  };
  publicAPI.projectPoint = function(x, xproj) {
    projectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.projectVector = function(v, vproj) {
    return projectVector2(v, model.normal, vproj);
  };
  publicAPI.push = function(distance) {
    if (distance === 0) {
      return;
    }
    for (var i = 0; i < 3; i++) {
      model.origin[i] += distance * model.normal[i];
    }
  };
  publicAPI.generalizedProjectPoint = function(x, xproj) {
    generalizedProjectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.evaluateFunction = function(x, y, z) {
    if (!Array.isArray(x)) {
      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
    }
    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
  };
  publicAPI.evaluateGradient = function(xyz) {
    var retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };
  publicAPI.intersectWithLine = function(p1, p2) {
    return intersectWithLine(p1, p2, model.origin, model.normal);
  };
  publicAPI.intersectWithPlane = function(planeOrigin, planeNormal) {
    return intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
  };
}
function extend2(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
  vtkPlane(publicAPI, model);
}
var PLANE_TOLERANCE, COINCIDE, DISJOINT, STATIC, DEFAULT_VALUES2, newInstance3, vtkPlane$1;
var init_Plane = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/Plane.js"() {
    init_defineProperty();
    init_Math();
    init_macros();
    PLANE_TOLERANCE = 1e-6;
    COINCIDE = "coincide";
    DISJOINT = "disjoint";
    STATIC = {
      evaluate,
      distanceToPlane,
      projectPoint,
      projectVector: projectVector2,
      generalizedProjectPoint,
      intersectWithLine,
      intersectWithPlane,
      DISJOINT,
      COINCIDE
    };
    DEFAULT_VALUES2 = {
      normal: [0, 0, 1],
      origin: [0, 0, 0]
    };
    newInstance3 = macro.newInstance(extend2, "vtkPlane");
    vtkPlane$1 = _objectSpread3({
      newInstance: newInstance3,
      extend: extend2
    }, STATIC);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _equals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function _isValid(bounds) {
  return bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
}
function _setBounds(bounds, otherBounds) {
  bounds[0] = otherBounds[0];
  bounds[1] = otherBounds[1];
  bounds[2] = otherBounds[2];
  bounds[3] = otherBounds[3];
  bounds[4] = otherBounds[4];
  bounds[5] = otherBounds[5];
  return bounds;
}
function _reset(bounds) {
  return _setBounds(bounds, INIT_BOUNDS);
}
function _addPoint(bounds) {
  var _bounds = _slicedToArray(bounds, 6), xMin = _bounds[0], xMax = _bounds[1], yMin = _bounds[2], yMax = _bounds[3], zMin = _bounds[4], zMax = _bounds[5];
  bounds[0] = xMin < (arguments.length <= 1 ? void 0 : arguments[1]) ? xMin : arguments.length <= 1 ? void 0 : arguments[1];
  bounds[1] = xMax > (arguments.length <= 1 ? void 0 : arguments[1]) ? xMax : arguments.length <= 1 ? void 0 : arguments[1];
  bounds[2] = yMin < (arguments.length <= 2 ? void 0 : arguments[2]) ? yMin : arguments.length <= 2 ? void 0 : arguments[2];
  bounds[3] = yMax > (arguments.length <= 2 ? void 0 : arguments[2]) ? yMax : arguments.length <= 2 ? void 0 : arguments[2];
  bounds[4] = zMin < (arguments.length <= 3 ? void 0 : arguments[3]) ? zMin : arguments.length <= 3 ? void 0 : arguments[3];
  bounds[5] = zMax > (arguments.length <= 3 ? void 0 : arguments[3]) ? zMax : arguments.length <= 3 ? void 0 : arguments[3];
  return bounds;
}
function _addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
  var _bounds2 = _slicedToArray(bounds, 6), _xMin = _bounds2[0], _xMax = _bounds2[1], _yMin = _bounds2[2], _yMax = _bounds2[3], _zMin = _bounds2[4], _zMax = _bounds2[5];
  if (zMax === void 0) {
    bounds[0] = Math.min(xMin[0], _xMin);
    bounds[1] = Math.max(xMin[1], _xMax);
    bounds[2] = Math.min(xMin[2], _yMin);
    bounds[3] = Math.max(xMin[3], _yMax);
    bounds[4] = Math.min(xMin[4], _zMin);
    bounds[5] = Math.max(xMin[5], _zMax);
  } else {
    bounds[0] = Math.min(xMin, _xMin);
    bounds[1] = Math.max(xMax, _xMax);
    bounds[2] = Math.min(yMin, _yMin);
    bounds[3] = Math.max(yMax, _yMax);
    bounds[4] = Math.min(zMin, _zMin);
    bounds[5] = Math.max(zMax, _zMax);
  }
  return bounds;
}
function _setMinPoint(bounds, x, y, z) {
  var _bounds3 = _slicedToArray(bounds, 6), xMin = _bounds3[0], xMax = _bounds3[1], yMin = _bounds3[2], yMax = _bounds3[3], zMin = _bounds3[4], zMax = _bounds3[5];
  bounds[0] = x;
  bounds[1] = x > xMax ? x : xMax;
  bounds[2] = y;
  bounds[3] = y > yMax ? y : yMax;
  bounds[4] = z;
  bounds[5] = z > zMax ? z : zMax;
  return xMin !== x || yMin !== y || zMin !== z;
}
function _setMaxPoint(bounds, x, y, z) {
  var _bounds4 = _slicedToArray(bounds, 6), xMin = _bounds4[0], xMax = _bounds4[1], yMin = _bounds4[2], yMax = _bounds4[3], zMin = _bounds4[4], zMax = _bounds4[5];
  bounds[0] = x < xMin ? x : xMin;
  bounds[1] = x;
  bounds[2] = y < yMin ? y : yMin;
  bounds[3] = y;
  bounds[4] = z < zMin ? z : zMin;
  bounds[5] = z;
  return xMax !== x || yMax !== y || zMax !== z;
}
function _inflate(bounds, delta) {
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
function _scale(bounds, sx, sy, sz) {
  if (!_isValid(bounds)) {
    return false;
  }
  if (sx >= 0) {
    bounds[0] *= sx;
    bounds[1] *= sx;
  } else {
    bounds[0] = sx * bounds[1];
    bounds[1] = sx * bounds[0];
  }
  if (sy >= 0) {
    bounds[2] *= sy;
    bounds[3] *= sy;
  } else {
    bounds[2] = sy * bounds[3];
    bounds[3] = sy * bounds[2];
  }
  if (sz >= 0) {
    bounds[4] *= sz;
    bounds[5] *= sz;
  } else {
    bounds[4] = sz * bounds[5];
    bounds[5] = sz * bounds[4];
  }
  return true;
}
function _getCenter(bounds) {
  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
}
function _getLength(bounds, index) {
  return bounds[index * 2 + 1] - bounds[index * 2];
}
function _getLengths(bounds) {
  return [_getLength(bounds, 0), _getLength(bounds, 1), _getLength(bounds, 2)];
}
function _getXRange(bounds) {
  return bounds.slice(0, 2);
}
function _getYRange(bounds) {
  return bounds.slice(2, 4);
}
function _getZRange(bounds) {
  return bounds.slice(4, 6);
}
function _getMaxLength(bounds) {
  var l = _getLengths(bounds);
  if (l[0] > l[1]) {
    if (l[0] > l[2]) {
      return l[0];
    }
    return l[2];
  }
  if (l[1] > l[2]) {
    return l[1];
  }
  return l[2];
}
function _getDiagonalLength(bounds) {
  if (_isValid(bounds)) {
    var l = _getLengths(bounds);
    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);
  }
  return null;
}
function _getMinPoint(bounds) {
  return [bounds[0], bounds[2], bounds[4]];
}
function _getMaxPoint(bounds) {
  return [bounds[1], bounds[3], bounds[5]];
}
function oppositeSign(a, b) {
  return a <= 0 && b >= 0 || a >= 0 && b <= 0;
}
function _getCorners(bounds, corners) {
  var count = 0;
  for (var ix = 0; ix < 2; ix++) {
    for (var iy = 2; iy < 4; iy++) {
      for (var iz = 4; iz < 6; iz++) {
        corners[count] = [bounds[ix], bounds[iy], bounds[iz]];
        count++;
      }
    }
  }
  return corners;
}
function _computeCornerPoints(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function _computeScale(bounds) {
  var scale3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var center = _getCenter(bounds);
  scale3[0] = bounds[1] - center[0];
  scale3[1] = bounds[3] - center[1];
  scale3[2] = bounds[5] - center[2];
  return scale3;
}
function _computeLocalBounds(points, u, v, w) {
  var bounds = [].concat(INIT_BOUNDS);
  var pointsData = points.getData();
  for (var i = 0; i < pointsData.length; i += 3) {
    var point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
    var du = dot(point, u);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    var dv = dot(point, v);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    var dw = dot(point, w);
    bounds[4] = Math.min(dw, bounds[4]);
    bounds[5] = Math.max(dw, bounds[5]);
  }
  return bounds;
}
function _intersectBox(bounds, origin, dir, coord, tolerance) {
  var inside = true;
  var quadrant = [];
  var whichPlane = 0;
  var maxT = [];
  var candidatePlane = [0, 0, 0];
  var RIGHT = 0;
  var LEFT = 1;
  var MIDDLE = 2;
  for (var i = 0; i < 3; i++) {
    if (origin[i] < bounds[2 * i]) {
      quadrant[i] = LEFT;
      candidatePlane[i] = bounds[2 * i];
      inside = false;
    } else if (origin[i] > bounds[2 * i + 1]) {
      quadrant[i] = RIGHT;
      candidatePlane[i] = bounds[2 * i + 1];
      inside = false;
    } else {
      quadrant[i] = MIDDLE;
    }
  }
  if (inside) {
    coord[0] = origin[0];
    coord[1] = origin[1];
    coord[2] = origin[2];
    tolerance[0] = 0;
    return 1;
  }
  for (var _i = 0; _i < 3; _i++) {
    if (quadrant[_i] !== MIDDLE && dir[_i] !== 0) {
      maxT[_i] = (candidatePlane[_i] - origin[_i]) / dir[_i];
    } else {
      maxT[_i] = -1;
    }
  }
  for (var _i2 = 0; _i2 < 3; _i2++) {
    if (maxT[whichPlane] < maxT[_i2]) {
      whichPlane = _i2;
    }
  }
  if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
    return 0;
  }
  tolerance[0] = maxT[whichPlane];
  for (var _i3 = 0; _i3 < 3; _i3++) {
    if (whichPlane !== _i3) {
      coord[_i3] = origin[_i3] + maxT[whichPlane] * dir[_i3];
      if (coord[_i3] < bounds[2 * _i3] || coord[_i3] > bounds[2 * _i3 + 1]) {
        return 0;
      }
    } else {
      coord[_i3] = candidatePlane[_i3];
    }
  }
  return 1;
}
function _intersectPlane(bounds, origin, normal) {
  var p = [];
  var d = 0;
  var sign = 1;
  var firstOne = 1;
  for (var z = 4; z <= 5; ++z) {
    p[2] = bounds[z];
    for (var y = 2; y <= 3; ++y) {
      p[1] = bounds[y];
      for (var x = 0; x <= 1; ++x) {
        p[0] = bounds[x];
        d = vtkPlane$1.evaluate(normal, origin, p);
        if (firstOne) {
          sign = d >= 0 ? 1 : -1;
          firstOne = 0;
        }
        if (d === 0 || sign > 0 && d < 0 || sign < 0 && d > 0) {
          return 1;
        }
      }
    }
  }
  return 0;
}
function _intersect(bounds, bBounds) {
  if (!(_isValid(bounds) && _isValid(bBounds))) {
    return false;
  }
  var newBounds = [0, 0, 0, 0, 0, 0];
  var intersection2;
  for (var i = 0; i < 3; i++) {
    intersection2 = false;
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      intersection2 = true;
      newBounds[i * 2] = bBounds[i * 2];
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      intersection2 = true;
      newBounds[i * 2] = bounds[i * 2];
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      intersection2 = true;
      newBounds[i * 2 + 1] = bBounds[2 * i + 1];
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      intersection2 = true;
      newBounds[i * 2 + 1] = bounds[i * 2 + 1];
    }
    if (!intersection2) {
      return false;
    }
  }
  bounds[0] = newBounds[0];
  bounds[1] = newBounds[1];
  bounds[2] = newBounds[2];
  bounds[3] = newBounds[3];
  bounds[4] = newBounds[4];
  bounds[5] = newBounds[5];
  return true;
}
function _intersects(bounds, bBounds) {
  if (!(_isValid(bounds) && _isValid(bBounds))) {
    return false;
  }
  for (var i = 0; i < 3; i++) {
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      continue;
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      continue;
    }
    return false;
  }
  return true;
}
function _containsPoint(bounds, x, y, z) {
  if (x < bounds[0] || x > bounds[1]) {
    return false;
  }
  if (y < bounds[2] || y > bounds[3]) {
    return false;
  }
  if (z < bounds[4] || z > bounds[5]) {
    return false;
  }
  return true;
}
function contains(bounds, otherBounds) {
  if (!_intersects(bounds, otherBounds)) {
    return false;
  }
  if (!_containsPoint.apply(void 0, [bounds].concat(_toConsumableArray(_getMinPoint(otherBounds))))) {
    return false;
  }
  if (!_containsPoint.apply(void 0, [bounds].concat(_toConsumableArray(_getMaxPoint(otherBounds))))) {
    return false;
  }
  return true;
}
function _cutWithPlane(bounds, origin, normal) {
  var index = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
  var d = [0, 0, 0, 0, 0, 0, 0, 0];
  var idx = 0;
  for (var ix = 0; ix < 2; ix++) {
    for (var iy = 2; iy < 4; iy++) {
      for (var iz = 4; iz < 6; iz++) {
        var x = [bounds[ix], bounds[iy], bounds[iz]];
        d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
      }
    }
  }
  var dir = 2;
  while (dir--) {
    if (oppositeSign(d[index[dir][0]], d[index[dir][4]]) && oppositeSign(d[index[dir][1]], d[index[dir][5]]) && oppositeSign(d[index[dir][2]], d[index[dir][6]]) && oppositeSign(d[index[dir][3]], d[index[dir][7]])) {
      break;
    }
  }
  if (dir < 0) {
    return false;
  }
  var sign = Math.sign(normal[dir]);
  var size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
  var t = sign > 0 ? 1 : 0;
  for (var i = 0; i < 4; i++) {
    if (size === 0) {
      continue;
    }
    var ti = Math.abs(d[index[dir][i]]) / size;
    if (sign > 0 && ti < t) {
      t = ti;
    }
    if (sign < 0 && ti > t) {
      t = ti;
    }
  }
  var bound = (1 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
  if (sign > 0) {
    bounds[dir * 2] = bound;
  } else {
    bounds[dir * 2 + 1] = bound;
  }
  return true;
}
function newInstance4(initialValues) {
  var bounds = initialValues && initialValues.bounds;
  return new BoundingBox(bounds);
}
var INIT_BOUNDS, BoundingBox, STATIC2, vtkBoundingBox;
var init_BoundingBox = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js"() {
    init_defineProperty();
    init_classCallCheck();
    init_createClass();
    init_toConsumableArray();
    init_slicedToArray();
    init_Math();
    init_Plane();
    INIT_BOUNDS = [
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      Number.MAX_VALUE,
      -Number.MAX_VALUE,
      Number.MAX_VALUE,
      -Number.MAX_VALUE
    ];
    BoundingBox = function() {
      function BoundingBox2(refBounds) {
        _classCallCheck(this, BoundingBox2);
        this.bounds = refBounds;
        if (!this.bounds) {
          this.bounds = new Float64Array(INIT_BOUNDS);
        }
      }
      _createClass(BoundingBox2, [{
        key: "getBounds",
        value: function getBounds() {
          return this.bounds;
        }
      }, {
        key: "equals",
        value: function equals(otherBounds) {
          return _equals(this.bounds, otherBounds);
        }
      }, {
        key: "isValid",
        value: function isValid() {
          return _isValid(this.bounds);
        }
      }, {
        key: "setBounds",
        value: function setBounds(otherBounds) {
          return _setBounds(this.bounds, otherBounds);
        }
      }, {
        key: "reset",
        value: function reset() {
          return _reset(this.bounds);
        }
      }, {
        key: "addPoint",
        value: function addPoint() {
          for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
            xyz[_key] = arguments[_key];
          }
          return _addPoint(this.bounds, xyz);
        }
      }, {
        key: "addBounds",
        value: function addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
          return _addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
        }
      }, {
        key: "setMinPoint",
        value: function setMinPoint(x, y, z) {
          return _setMinPoint(this.bounds, x, y, z);
        }
      }, {
        key: "setMaxPoint",
        value: function setMaxPoint(x, y, z) {
          return _setMaxPoint(this.bounds, x, y, z);
        }
      }, {
        key: "inflate",
        value: function inflate(delta) {
          return _inflate(this.bounds, delta);
        }
      }, {
        key: "scale",
        value: function scale(sx, sy, sz) {
          return _scale(this.bounds, sx, sy, sz);
        }
      }, {
        key: "getCenter",
        value: function getCenter() {
          return _getCenter(this.bounds);
        }
      }, {
        key: "getLength",
        value: function getLength(index) {
          return _getLength(this.bounds, index);
        }
      }, {
        key: "getLengths",
        value: function getLengths() {
          return _getLengths(this.bounds);
        }
      }, {
        key: "getMaxLength",
        value: function getMaxLength() {
          return _getMaxLength(this.bounds);
        }
      }, {
        key: "getDiagonalLength",
        value: function getDiagonalLength() {
          return _getDiagonalLength(this.bounds);
        }
      }, {
        key: "getMinPoint",
        value: function getMinPoint() {
          return _getMinPoint(this.bounds);
        }
      }, {
        key: "getMaxPoint",
        value: function getMaxPoint() {
          return _getMaxPoint(this.bounds);
        }
      }, {
        key: "getXRange",
        value: function getXRange() {
          return _getXRange(this.bounds);
        }
      }, {
        key: "getYRange",
        value: function getYRange() {
          return _getYRange(this.bounds);
        }
      }, {
        key: "getZRange",
        value: function getZRange() {
          return _getZRange(this.bounds);
        }
      }, {
        key: "getCorners",
        value: function getCorners(corners) {
          return _getCorners(this.bounds, corners);
        }
      }, {
        key: "computeCornerPoints",
        value: function computeCornerPoints(point1, point2) {
          return _computeCornerPoints(this.bounds, point1, point2);
        }
      }, {
        key: "computeLocalBounds",
        value: function computeLocalBounds(u, v, w) {
          return _computeLocalBounds(this.bounds, u, v, w);
        }
      }, {
        key: "computeScale3",
        value: function computeScale3(scale3) {
          return _computeScale(this.bounds, scale3);
        }
      }, {
        key: "cutWithPlane",
        value: function cutWithPlane(origin, normal) {
          return _cutWithPlane(this.bounds, origin, normal);
        }
      }, {
        key: "intersectBox",
        value: function intersectBox(origin, dir, coord, tolerance) {
          return _intersectBox(this.bounds, origin, dir, coord, tolerance);
        }
      }, {
        key: "intersectPlane",
        value: function intersectPlane(origin, normal) {
          return _intersectPlane(this.bounds, origin, normal);
        }
      }, {
        key: "intersect",
        value: function intersect(otherBounds) {
          return _intersect(this.bounds, otherBounds);
        }
      }, {
        key: "intersects",
        value: function intersects(otherBounds) {
          return _intersects(this.bounds, otherBounds);
        }
      }, {
        key: "containsPoint",
        value: function containsPoint(x, y, z) {
          return _containsPoint(this.bounds, x, y, z);
        }
      }, {
        key: "contains",
        value: function contains2(otherBounds) {
          return _intersects(this.bounds, otherBounds);
        }
      }]);
      return BoundingBox2;
    }();
    STATIC2 = {
      equals: _equals,
      isValid: _isValid,
      setBounds: _setBounds,
      reset: _reset,
      addPoint: _addPoint,
      addBounds: _addBounds,
      setMinPoint: _setMinPoint,
      setMaxPoint: _setMaxPoint,
      inflate: _inflate,
      scale: _scale,
      getCenter: _getCenter,
      getLength: _getLength,
      getLengths: _getLengths,
      getMaxLength: _getMaxLength,
      getDiagonalLength: _getDiagonalLength,
      getMinPoint: _getMinPoint,
      getMaxPoint: _getMaxPoint,
      getXRange: _getXRange,
      getYRange: _getYRange,
      getZRange: _getZRange,
      getCorners: _getCorners,
      computeCornerPoints: _computeCornerPoints,
      computeLocalBounds: _computeLocalBounds,
      computeScale3: _computeScale,
      cutWithPlane: _cutWithPlane,
      intersectBox: _intersectBox,
      intersectPlane: _intersectPlane,
      intersect: _intersect,
      intersects: _intersects,
      containsPoint: _containsPoint,
      contains,
      INIT_BOUNDS
    };
    vtkBoundingBox = _objectSpread4({
      newInstance: newInstance4
    }, STATIC2);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
function notImplemented2(method) {
  return function() {
    return macro.vtkErrorMacro("vtkProp::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = function() {
    var m1 = model.mtime;
    for (var index = 0; index < model.textures.length; ++index) {
      var m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.getNestedProps = function() {
    return null;
  };
  publicAPI.getActors = function() {
    return [];
  };
  publicAPI.getActors2D = function() {
    return [];
  };
  publicAPI.getVolumes = function() {
    return [];
  };
  publicAPI.pick = notImplemented2("pick");
  publicAPI.hasKey = notImplemented2("hasKey");
  publicAPI.getNestedVisibility = function() {
    return model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  };
  publicAPI.getNestedPickable = function() {
    return model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  };
  publicAPI.getNestedDragable = function() {
    return model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  };
  publicAPI.getRedrawMTime = function() {
    return model.mtime;
  };
  publicAPI.setEstimatedRenderTime = function(t) {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = function() {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = function(t) {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = function(t) {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = function() {
    return false;
  };
  publicAPI.getTextures = function() {
    return model.textures;
  };
  publicAPI.hasTexture = function(texture) {
    return model.textures.indexOf(texture) !== -1;
  };
  publicAPI.addTexture = function(texture) {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = function(texture) {
    var newTextureList = model.textures.filter(function(item) {
      return item !== texture;
    });
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = function() {
    model.textures = [];
    publicAPI.modified();
  };
}
function extend3(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["visibility", "pickable", "dragable", "useBounds", "renderTimeMultiplier", "_parentProp"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var DEFAULT_VALUES3, newInstance5, vtkProp$1;
var init_Prop = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Prop.js"() {
    init_macros();
    DEFAULT_VALUES3 = {
      visibility: true,
      pickable: true,
      dragable: true,
      useBounds: true,
      allocatedRenderTime: 10,
      estimatedRenderTime: 0,
      savedEstimatedRenderTime: 0,
      renderTimeMultiplier: 1,
      paths: null,
      textures: []
    };
    newInstance5 = macro.newInstance(extend3, "vtkProp");
    vtkProp$1 = {
      newInstance: newInstance5,
      extend: extend3
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = function(deltaXYZ) {
    model.position = model.position.map(function(value, index) {
      return value + deltaXYZ[index];
    });
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = function() {
    var q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    var oaxis = new Float64Array(3);
    var w = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.rotateX = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = function(val) {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = function(degrees, x, y, z) {
    if (degrees === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    var angle = radiansFromDegrees(degrees);
    var q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle);
    var quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = function(x, y, z) {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setUserMatrix = function(matrix) {
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
  };
  publicAPI.getMatrix = function() {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = function() {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (var i = 0; i < 4; ++i) {
        for (var j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getCenter = function() {
    return vtkBoundingBox.getCenter(model.bounds);
  };
  publicAPI.getLength = function() {
    return vtkBoundingBox.getLength(model.bounds);
  };
  publicAPI.getXRange = function() {
    return vtkBoundingBox.getXRange(model.bounds);
  };
  publicAPI.getYRange = function() {
    return vtkBoundingBox.getYRange(model.bounds);
  };
  publicAPI.getZRange = function() {
    return vtkBoundingBox.getZRange(model.bounds);
  };
  publicAPI.getUserMatrix = function() {
    return model.userMatrix;
  };
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
}
function extend4(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["bounds", "isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var DEFAULT_VALUES4, newInstance6, vtkProp3D$1;
var init_Prop3D = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js"() {
    init_esm();
    init_macros();
    init_BoundingBox();
    init_Math();
    init_Prop();
    DEFAULT_VALUES4 = {
      origin: [0, 0, 0],
      position: [0, 0, 0],
      orientation: [0, 0, 0],
      rotation: null,
      scale: [1, 1, 1],
      bounds: [1, -1, 1, -1, 1, -1],
      userMatrix: null,
      userMatrixMTime: null,
      cachedProp3D: null,
      isIdentity: true,
      matrixMTime: null
    };
    newInstance6 = macro.newInstance(extend4, "vtkProp3D");
    vtkProp3D$1 = {
      newInstance: newInstance6,
      extend: extend4
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js
var Constants_exports2 = {};
__export(Constants_exports2, {
  DataTypeByteSize: () => DataTypeByteSize,
  DefaultDataType: () => DefaultDataType,
  VtkDataTypes: () => VtkDataTypes,
  default: () => Constants2
});
var DataTypeByteSize, VtkDataTypes, DefaultDataType, Constants2;
var init_Constants2 = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/DataArray/Constants.js"() {
    DataTypeByteSize = {
      Int8Array: 1,
      Uint8Array: 1,
      Uint8ClampedArray: 1,
      Int16Array: 2,
      Uint16Array: 2,
      Int32Array: 4,
      Uint32Array: 4,
      Float32Array: 4,
      Float64Array: 8
    };
    VtkDataTypes = {
      VOID: "",
      CHAR: "Int8Array",
      SIGNED_CHAR: "Int8Array",
      UNSIGNED_CHAR: "Uint8Array",
      SHORT: "Int16Array",
      UNSIGNED_SHORT: "Uint16Array",
      INT: "Int32Array",
      UNSIGNED_INT: "Uint32Array",
      FLOAT: "Float32Array",
      DOUBLE: "Float64Array"
    };
    DefaultDataType = VtkDataTypes.FLOAT;
    Constants2 = {
      DefaultDataType,
      DataTypeByteSize,
      VtkDataTypes
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/DataArray.js
var DataArray_exports = {};
__export(DataArray_exports, {
  STATIC: () => STATIC3,
  default: () => vtkDataArray$1,
  extend: () => extend5,
  newInstance: () => newInstance7
});
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function fastComputeRange(arr, offset, numberOfComponents) {
  var len = arr.length;
  var min2;
  var max2;
  var x;
  var i;
  if (len === 0) {
    return {
      min: Number.MAX_VALUE,
      max: -Number.MAX_VALUE
    };
  }
  min2 = arr[offset];
  max2 = min2;
  for (i = offset; i < len; i += numberOfComponents) {
    x = arr[i];
    if (x < min2) {
      min2 = x;
    } else if (x > max2) {
      max2 = x;
    }
  }
  return {
    min: min2,
    max: max2
  };
}
function createRangeHelper() {
  var min2 = Number.MAX_VALUE;
  var max2 = -Number.MAX_VALUE;
  var count = 0;
  var sum = 0;
  return {
    add: function add2(value) {
      if (min2 > value) {
        min2 = value;
      }
      if (max2 < value) {
        max2 = value;
      }
      count++;
      sum += value;
    },
    get: function get2() {
      return {
        min: min2,
        max: max2,
        count,
        sum,
        mean: sum / count
      };
    },
    getRange: function getRange() {
      return {
        min: min2,
        max: max2
      };
    }
  };
}
function computeRange(values) {
  var component = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var numberOfComponents = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (component < 0 && numberOfComponents > 1) {
    var size = values.length;
    var numberOfValues = size / numberOfComponents;
    var data = new Float64Array(numberOfValues);
    for (var i = 0, j = 0; i < numberOfValues; ++i) {
      var _i;
      for (var nextJ = j + numberOfComponents; j < nextJ; ++j) {
        data[i] += values[j] * values[j];
      }
      _i = i, data[_i] = Math.pow(data[_i], 0.5);
    }
    return fastComputeRange(data, 0, 1);
  }
  return fastComputeRange(values, component < 0 ? 0 : component, numberOfComponents);
}
function ensureRangeSize(rangeArray) {
  var size = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var ranges = rangeArray || [];
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}
function getDataType(typedArray) {
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}
function getMaxNorm(normArray) {
  var numComps = normArray.getNumberOfComponents();
  var maxNorm = 0;
  for (var i = 0; i < normArray.getNumberOfTuples(); ++i) {
    var norm$1 = norm(normArray.getTuple(i), numComps);
    if (norm$1 > maxNorm) {
      maxNorm = norm$1;
    }
  }
  return maxNorm;
}
function vtkDataArray(publicAPI, model) {
  model.classHierarchy.push("vtkDataArray");
  function dataChange() {
    model.ranges = null;
    publicAPI.modified();
  }
  publicAPI.getElementComponentSize = function() {
    return model.values.BYTES_PER_ELEMENT;
  };
  publicAPI.getComponent = function(tupleIdx) {
    var compIdx = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    return model.values[tupleIdx * model.numberOfComponents + compIdx];
  };
  publicAPI.setComponent = function(tupleIdx, compIdx, value) {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      dataChange();
    }
  };
  publicAPI.getData = function() {
    return model.values;
  };
  publicAPI.getRange = function() {
    var componentIndex = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : -1;
    var rangeIdx = componentIndex < 0 ? model.numberOfComponents : componentIndex;
    var range = null;
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];
    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }
    range = computeRange(model.values, componentIndex, model.numberOfComponents);
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setRange = function(rangeValue, componentIndex) {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    var range = {
      min: rangeValue.min,
      max: rangeValue.max
    };
    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };
  publicAPI.setTuple = function(idx, tuple) {
    var offset = idx * model.numberOfComponents;
    for (var i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };
  publicAPI.getTuple = function(idx) {
    var tupleToFill = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : TUPLE_HOLDER;
    var numberOfComponents = model.numberOfComponents || 1;
    if (tupleToFill.length !== numberOfComponents) {
      tupleToFill.length = numberOfComponents;
    }
    var offset = idx * numberOfComponents;
    if (numberOfComponents === 1) {
      tupleToFill[0] = model.values[offset];
    } else if (numberOfComponents === 2) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
    } else if (numberOfComponents === 3) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
      tupleToFill[2] = model.values[offset + 2];
    } else if (numberOfComponents === 4) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
      tupleToFill[2] = model.values[offset + 2];
      tupleToFill[3] = model.values[offset + 3];
    } else {
      for (var i = 0; i < numberOfComponents; i++) {
        tupleToFill[i] = model.values[offset + i];
      }
    }
    return tupleToFill;
  };
  publicAPI.getTupleLocation = function() {
    var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    return idx * model.numberOfComponents;
  };
  publicAPI.getNumberOfComponents = function() {
    return model.numberOfComponents;
  };
  publicAPI.getNumberOfValues = function() {
    return model.values.length;
  };
  publicAPI.getNumberOfTuples = function() {
    return model.values.length / model.numberOfComponents;
  };
  publicAPI.getDataType = function() {
    return model.dataType;
  };
  publicAPI.newClone = function() {
    return newInstance7({
      empty: true,
      name: model.name,
      dataType: model.dataType,
      numberOfComponents: model.numberOfComponents
    });
  };
  publicAPI.getName = function() {
    if (!model.name) {
      publicAPI.modified();
      model.name = "vtkDataArray".concat(publicAPI.getMTime());
    }
    return model.name;
  };
  publicAPI.setData = function(typedArray, numberOfComponents) {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    dataChange();
  };
  publicAPI.getState = function() {
    if (model.deleted) {
      return null;
    }
    var jsonArchive = _objectSpread5(_objectSpread5({}, model), {}, {
      vtkClass: publicAPI.getClassName()
    });
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;
    Object.keys(jsonArchive).forEach(function(keyName) {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });
    var sortedObj = {};
    Object.keys(jsonArchive).sort().forEach(function(name) {
      sortedObj[name] = jsonArchive[name];
    });
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }
    return sortedObj;
  };
}
function extend5(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  if (!model.empty && !model.values && !model.size) {
    throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");
  }
  if (!model.values) {
    model.values = newTypedArray(model.dataType, model.size);
  } else if (Array.isArray(model.values)) {
    model.values = newTypedArrayFrom(model.dataType, model.values);
  }
  if (model.values) {
    model.size = model.values.length;
    model.dataType = getDataType(model.values);
  }
  obj(publicAPI, model);
  set(publicAPI, model, ["name", "numberOfComponents"]);
  vtkDataArray(publicAPI, model);
}
var DefaultDataType2, TUPLE_HOLDER, STATIC3, DEFAULT_VALUES5, newInstance7, vtkDataArray$1;
var init_DataArray = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/DataArray.js"() {
    init_defineProperty();
    init_Constants2();
    init_macros();
    init_Math();
    DefaultDataType2 = Constants2.DefaultDataType;
    TUPLE_HOLDER = [];
    STATIC3 = {
      computeRange,
      createRangeHelper,
      fastComputeRange,
      getDataType,
      getMaxNorm
    };
    DEFAULT_VALUES5 = {
      name: "",
      numberOfComponents: 1,
      size: 0,
      dataType: DefaultDataType2,
      rangeTuple: [0, 0]
    };
    newInstance7 = newInstance(extend5, "vtkDataArray");
    vtkDataArray$1 = _objectSpread5(_objectSpread5({
      newInstance: newInstance7,
      extend: extend5
    }, STATIC3), Constants2);
  }
});

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
var VectorMode, ScalarMappingTarget, vtkScalarsToColors;
var init_Constants3 = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js"() {
    VectorMode = {
      MAGNITUDE: 0,
      COMPONENT: 1,
      RGBCOLORS: 2
    };
    ScalarMappingTarget = {
      LUMINANCE: 1,
      LUMINANCE_ALPHA: 2,
      RGB: 3,
      RGBA: 4
    };
    vtkScalarsToColors = {
      VectorMode,
      ScalarMappingTarget
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var ColorMode, ScalarMode, GetArray, Constants3;
var init_Constants4 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js"() {
    ColorMode = {
      DEFAULT: 0,
      MAP_SCALARS: 1,
      DIRECT_SCALARS: 2
    };
    ScalarMode = {
      DEFAULT: 0,
      USE_POINT_DATA: 1,
      USE_CELL_DATA: 2,
      USE_POINT_FIELD_DATA: 3,
      USE_CELL_FIELD_DATA: 4,
      USE_FIELD_DATA: 5
    };
    GetArray = {
      BY_ID: 0,
      BY_NAME: 1
    };
    Constants3 = {
      ColorMode,
      GetArray,
      ScalarMode
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255 + 0.5);
}
function vtkScalarsToColors2(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = function() {
    return publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
  };
  publicAPI.setVectorModeToComponent = function() {
    return publicAPI.setVectorMode(VectorMode2.COMPONENT);
  };
  publicAPI.setVectorModeToRGBColors = function() {
    return publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
  };
  publicAPI.build = function() {
  };
  publicAPI.isOpaque = function() {
    return true;
  };
  publicAPI.setAnnotations = function(values, annotations) {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro3("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      var num = annotations.length;
      for (var i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = function(value, annotation) {
    var i = publicAPI.checkForAnnotatedValue(value);
    var modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };
  publicAPI.getNumberOfAnnotatedValues = function() {
    return model.annotationArray.length;
  };
  publicAPI.getAnnotatedValue = function(idx) {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = function(idx) {
    if (model.annotationArray[idx] === void 0) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = function(val) {
    return model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  };
  publicAPI.removeAnnotation = function(value) {
    var i = publicAPI.checkForAnnotatedValue(value);
    var needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = function() {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = function(val, rgba) {
    if (model.indexedLookup) {
      var i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = function(value) {
    return publicAPI.getAnnotatedValueIndexInternal(value);
  };
  publicAPI.getAnnotatedValueIndexInternal = function(value) {
    if (model.annotatedValueMap[value] !== void 0) {
      var na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = function(val, rgba) {
    rgba[0] = 0;
    rgba[1] = 0;
    rgba[2] = 0;
    rgba[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = function() {
    model.annotatedValueMap = [];
    var na = model.annotationArray.length;
    for (var i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };
  publicAPI.mapScalars = function(scalars, colorMode, componentIn) {
    var numberOfComponents = scalars.getNumberOfComponents();
    var newColors = null;
    if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes2.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      var newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes2.UNSIGNED_CHAR
      };
      var s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      var component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = function(input, output, compsToUse) {
    var length = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    for (var i = 0; i < length; i++) {
      var sum = 0;
      for (var j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };
  publicAPI.mapVectorsThroughTable = function(input, output, outputFormat, vectorComponentIn, vectorSizeIn) {
    var vectorMode = publicAPI.getVectorMode();
    var vectorSize = vectorSizeIn;
    var vectorComponent = vectorComponentIn;
    var inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode2.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode2.COMPONENT;
      }
    }
    var inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode2.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode2.RGBCOLORS: {
        break;
      }
      case VectorMode2.MAGNITUDE:
      default: {
        var magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = function(newColors, colors, alpha, convtFun) {
    var a = convtFun(alpha);
    var values = colors.getData();
    var newValues = newColors.getData();
    var size = values.length;
    var component = 0;
    var tuple = 1;
    var count = 0;
    for (var i = component; i < size; i += tuple) {
      var l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = function(newColors, colors, alpha, convtFun) {
    var values = colors.getData();
    var newValues = newColors.getData();
    var size = values.length;
    var component = 0;
    var tuple = 2;
    var count = 0;
    for (var i = component; i < size; i += tuple) {
      var l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };
  publicAPI.rGBToRGBA = function(newColors, colors, alpha, convtFun) {
    var a = floatColorToUChar(alpha);
    var values = colors.getData();
    var newValues = newColors.getData();
    var size = values.length;
    var component = 0;
    var tuple = 3;
    var count = 0;
    for (var i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };
  publicAPI.rGBAToRGBA = function(newColors, colors, alpha, convtFun) {
    var values = colors.getData();
    var newValues = newColors.getData();
    var size = values.length;
    var component = 0;
    var tuple = 4;
    var count = 0;
    for (var i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };
  publicAPI.convertToRGBA = function(colors, numComp, numTuples) {
    var alpha = model.alpha;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes2.UNSIGNED_CHAR) {
      return colors;
    }
    var newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes2.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    var convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes2.FLOAT || colors.getDataType() === VtkDataTypes2.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro3("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = function() {
    return false;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    return 256 * 256 * 256;
  };
  publicAPI.setRange = function(min2, max2) {
    return publicAPI.setMappingRange(min2, max2);
  };
  publicAPI.getRange = function(min2, max2) {
    return publicAPI.getMappingRange();
  };
}
function extend6(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors2(publicAPI, model);
}
var ScalarMappingTarget2, VectorMode2, VtkDataTypes2, ColorMode2, vtkErrorMacro3, DEFAULT_VALUES6, newInstance8, vtkScalarsToColors$1;
var init_ScalarsToColors = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js"() {
    init_defineProperty();
    init_macros();
    init_DataArray();
    init_Constants3();
    init_Constants4();
    ScalarMappingTarget2 = vtkScalarsToColors.ScalarMappingTarget;
    VectorMode2 = vtkScalarsToColors.VectorMode;
    VtkDataTypes2 = vtkDataArray$1.VtkDataTypes;
    ColorMode2 = Constants3.ColorMode;
    vtkErrorMacro3 = macro.vtkErrorMacro;
    DEFAULT_VALUES6 = {
      alpha: 1,
      vectorComponent: 0,
      vectorSize: -1,
      vectorMode: VectorMode2.COMPONENT,
      mappingRange: null,
      annotationArray: null,
      annotatedValueMap: null,
      indexedLookup: false
    };
    newInstance8 = macro.newInstance(extend6, "vtkScalarsToColors");
    vtkScalarsToColors$1 = _objectSpread6({
      newInstance: newInstance8,
      extend: extend6
    }, vtkScalarsToColors);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js
var ColorSpace, Scale, Constants4;
var init_Constants5 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction/Constants.js"() {
    ColorSpace = {
      RGB: 0,
      HSV: 1,
      LAB: 2,
      DIVERGING: 3
    };
    Scale = {
      LINEAR: 0,
      LOG10: 1
    };
    Constants4 = {
      ColorSpace,
      Scale
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js
function ownKeys7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys7(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkColorTransferFunctionLabToMsh(lab, msh) {
  var L = lab[0];
  var a = lab[1];
  var b = lab[2];
  var M = Math.sqrt(L * L + a * a + b * b);
  var s = M > 1e-3 ? Math.acos(L / M) : 0;
  var h = s > 1e-3 ? Math.atan2(b, a) : 0;
  msh[0] = M;
  msh[1] = s;
  msh[2] = h;
}
function vtkColorTransferFunctionMshToLab(msh, lab) {
  var M = msh[0];
  var s = msh[1];
  var h = msh[2];
  lab[0] = M * Math.cos(s);
  lab[1] = M * Math.sin(s) * Math.cos(h);
  lab[2] = M * Math.sin(s) * Math.sin(h);
}
function vtkColorTransferFunctionAdjustHue(msh, unsatM) {
  if (msh[0] >= unsatM - 0.1) {
    return msh[2];
  }
  var hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));
  if (msh[2] > -0.3 * Math.PI) {
    return msh[2] + hueSpin;
  }
  return msh[2] - hueSpin;
}
function vtkColorTransferFunctionAngleDiff(a1, a2) {
  var adiff = a1 - a2;
  if (adiff < 0) {
    adiff = -adiff;
  }
  while (adiff >= 2 * Math.PI) {
    adiff -= 2 * Math.PI;
  }
  if (adiff > Math.PI) {
    adiff = 2 * Math.PI - adiff;
  }
  return adiff;
}
function vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {
  var lab1 = [];
  var lab2 = [];
  rgb2lab(rgb1, lab1);
  rgb2lab(rgb2, lab2);
  var msh1 = [];
  var msh2 = [];
  vtkColorTransferFunctionLabToMsh(lab1, msh1);
  vtkColorTransferFunctionLabToMsh(lab2, msh2);
  var localS = s;
  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {
    var Mmid = Math.max(msh1[0], msh2[0]);
    Mmid = Math.max(88, Mmid);
    if (s < 0.5) {
      msh2[0] = Mmid;
      msh2[1] = 0;
      msh2[2] = 0;
      localS *= 2;
    } else {
      msh1[0] = Mmid;
      msh1[1] = 0;
      msh1[2] = 0;
      localS = 2 * localS - 1;
    }
  }
  if (msh1[1] < 0.05 && msh2[1] > 0.05) {
    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);
  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {
    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);
  }
  var mshTmp = [];
  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];
  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];
  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];
  var labTmp = [];
  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);
  lab2rgb(labTmp, result);
}
function vtkColorTransferFunction(publicAPI, model) {
  model.classHierarchy.push("vtkColorTransferFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.addRGBPoint = function(x, r, g, b) {
    return publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0);
  };
  publicAPI.addRGBPointLong = function(x, r, g, b) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro4("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro4("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      r,
      g,
      b,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.addHSVPoint = function(x, h, s, v) {
    return publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0);
  };
  publicAPI.addHSVPointLong = function(x, h, s, v) {
    var midpoint = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    var sharpness = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 0;
    var rgb = [];
    var hsv = [h, s, v];
    hsv2rgb(hsv, rgb);
    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      var before = JSON.stringify(model.nodes);
      model.nodes = nodes;
      var after = JSON.stringify(model.nodes);
      if (publicAPI.sortAndUpdateRange() || before !== after) {
        publicAPI.modified();
        return true;
      }
    }
    return false;
  };
  publicAPI.sortAndUpdateRange = function() {
    var before = JSON.stringify(model.nodes);
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var after = JSON.stringify(model.nodes);
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked && before !== after) {
      publicAPI.modified();
      return true;
    }
    return modifiedInvoked;
  };
  publicAPI.updateRange = function() {
    var oldRange = [2];
    oldRange[0] = model.mappingRange[0];
    oldRange[1] = model.mappingRange[1];
    var size = model.nodes.length;
    if (size) {
      model.mappingRange[0] = model.nodes[0].x;
      model.mappingRange[1] = model.nodes[size - 1].x;
    } else {
      model.mappingRange[0] = 0;
      model.mappingRange[1] = 0;
    }
    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    var retVal = i;
    if (i >= model.nodes.length) {
      return -1;
    }
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.movePoint = function(oldX, newX) {
    if (oldX === newX) {
      return;
    }
    publicAPI.removePoint(newX);
    for (var i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === oldX) {
        model.nodes[i].x = newX;
        publicAPI.sortAndUpdateRange();
        break;
      }
    }
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addRGBSegment = function(x1, r1, g1, b1, x2, r2, g2, b2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0);
    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0);
    publicAPI.modified();
  };
  publicAPI.addHSVSegment = function(x1, h1, s1, v1, x2, h2, s2, v2) {
    var hsv1 = [h1, s1, v1];
    var hsv2 = [h2, s2, v2];
    var rgb1 = [];
    var rgb2 = [];
    hsv2rgb(hsv1, rgb1);
    hsv2rgb(hsv2, rgb2);
    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);
  };
  publicAPI.mapValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return [Math.floor(255 * rgb[0] + 0.5), Math.floor(255 * rgb[1] + 0.5), Math.floor(255 * rgb[2] + 0.5), 255];
  };
  publicAPI.getColor = function(x, rgb) {
    if (model.indexedLookup) {
      var numNodes = publicAPI.getSize();
      var idx = publicAPI.getAnnotatedValueIndexInternal(x);
      if (idx < 0 || numNodes === 0) {
        publicAPI.getNanColor(rgb);
      } else {
        var nodeVal = [];
        publicAPI.getNodeValue(idx % numNodes, nodeVal);
        rgb[0] = nodeVal.r;
        rgb[1] = nodeVal.g;
        rgb[2] = nodeVal.b;
      }
      return;
    }
    publicAPI.getTable(x, x, 1, rgb);
  };
  publicAPI.getRedValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[0];
  };
  publicAPI.getGreenValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[1];
  };
  publicAPI.getBlueValue = function(x) {
    var rgb = [];
    publicAPI.getColor(x, rgb);
    return rgb[2];
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    if (isNan(xStart) || isNan(xEnd)) {
      for (var i = 0; i < size; i++) {
        table[i * 3 + 0] = model.nanColor[0];
        table[i * 3 + 1] = model.nanColor[1];
        table[i * 3 + 2] = model.nanColor[2];
      }
      return;
    }
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastR = 0;
    var lastG = 0;
    var lastB = 0;
    if (numNodes !== 0) {
      lastR = model.nodes[numNodes - 1].r;
      lastG = model.nodes[numNodes - 1].g;
      lastB = model.nodes[numNodes - 1].b;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var rgb1 = [0, 0, 0];
    var rgb2 = [0, 0, 0];
    var midpoint = 0;
    var sharpness = 0;
    var tmpVec = [];
    var usingLogScale = model.scale === Scale2.LOG10;
    if (usingLogScale) {
      usingLogScale = model.mappingRange[0] > 0;
    }
    var logStart = 0;
    var logEnd = 0;
    var logX = 0;
    if (usingLogScale) {
      logStart = Math.log10(xStart);
      logEnd = Math.log10(xEnd);
    }
    for (var _i = 0; _i < size; _i++) {
      var tidx = 3 * _i;
      if (size > 1) {
        if (usingLogScale) {
          logX = logStart + _i / (size - 1) * (logEnd - logStart);
          x = Math.pow(10, logX);
        } else {
          x = xStart + _i / (size - 1) * (xEnd - xStart);
        }
      } else if (usingLogScale) {
        logX = 0.5 * (logStart + logEnd);
        x = Math.pow(10, logX);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      if (model.discretize) {
        var range = model.mappingRange;
        if (x >= range[0] && x <= range[1]) {
          var numberOfValues = model.numberOfValues;
          var deltaRange = range[1] - range[0];
          if (numberOfValues <= 1) {
            x = range[0] + deltaRange / 2;
          } else {
            var xn = (x - range[0]) / deltaRange;
            var discretizeIndex = floor(numberOfValues * xn);
            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;
          }
        }
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          if (usingLogScale) {
            x1 = Math.log10(x1);
            x2 = Math.log10(x2);
          }
          rgb1[0] = model.nodes[idx - 1].r;
          rgb2[0] = model.nodes[idx].r;
          rgb1[1] = model.nodes[idx - 1].g;
          rgb2[1] = model.nodes[idx].g;
          rgb1[2] = model.nodes[idx - 1].b;
          rgb2[2] = model.nodes[idx].b;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (x > model.mappingRange[1]) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseAboveRangeColor()) {
            table[tidx] = model.aboveRangeColor[0];
            table[tidx + 1] = model.aboveRangeColor[1];
            table[tidx + 2] = model.aboveRangeColor[2];
          } else {
            table[tidx] = lastR;
            table[tidx + 1] = lastG;
            table[tidx + 2] = lastB;
          }
        }
      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {
        table[tidx] = 0;
        table[tidx + 1] = 0;
        table[tidx + 2] = 0;
        if (model.clamping) {
          if (publicAPI.getUseBelowRangeColor()) {
            table[tidx] = model.belowRangeColor[0];
            table[tidx + 1] = model.belowRangeColor[1];
            table[tidx + 2] = model.belowRangeColor[2];
          } else if (numNodes > 0) {
            table[tidx] = model.nodes[0].r;
            table[tidx + 1] = model.nodes[0].g;
            table[tidx + 2] = model.nodes[0].b;
          }
        }
      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {
        if (numNodes > 0) {
          table[tidx] = model.nodes[0].r;
          table[tidx + 1] = model.nodes[0].g;
          table[tidx + 2] = model.nodes[0].b;
        } else {
          table[tidx] = 0;
          table[tidx + 1] = 0;
          table[tidx + 2] = 0;
        }
      } else {
        var s = 0;
        if (usingLogScale) {
          s = (logX - x1) / (x2 - x1);
        } else {
          s = (x - x1) / (x2 - x1);
        }
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = rgb1[0];
            table[tidx + 1] = rgb1[1];
            table[tidx + 2] = rgb1[2];
            continue;
          } else {
            table[tidx] = rgb2[0];
            table[tidx + 1] = rgb2[1];
            table[tidx + 2] = rgb2[2];
            continue;
          }
        }
        if (sharpness < 0.01) {
          if (model.colorSpace === ColorSpace2.RGB) {
            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];
            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];
            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];
          } else if (model.colorSpace === ColorSpace2.HSV) {
            var hsv1 = [];
            var hsv2 = [];
            rgb2hsv(rgb1, hsv1);
            rgb2hsv(rgb2, hsv2);
            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {
              if (hsv1[0] > hsv2[0]) {
                hsv1[0] -= 1;
              } else {
                hsv2[0] -= 1;
              }
            }
            var hsvTmp = [];
            hsvTmp[0] = (1 - s) * hsv1[0] + s * hsv2[0];
            if (hsvTmp[0] < 0) {
              hsvTmp[0] += 1;
            }
            hsvTmp[1] = (1 - s) * hsv1[1] + s * hsv2[1];
            hsvTmp[2] = (1 - s) * hsv1[2] + s * hsv2[2];
            hsv2rgb(hsvTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.LAB) {
            var lab1 = [];
            var lab2 = [];
            rgb2lab(rgb1, lab1);
            rgb2lab(rgb2, lab2);
            var labTmp = [];
            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];
            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];
            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];
            lab2rgb(labTmp, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else if (model.colorSpace === ColorSpace2.DIVERGING) {
            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
            table[tidx] = tmpVec[0];
            table[tidx + 1] = tmpVec[1];
            table[tidx + 2] = tmpVec[2];
          } else {
            vtkErrorMacro4("ColorSpace set to invalid value.", model.colorSpace);
          }
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = void 0;
        var t = void 0;
        if (model.colorSpace === ColorSpace2.RGB) {
          for (var j = 0; j < 3; j++) {
            slope = rgb2[j] - rgb1[j];
            t = (1 - sharpness) * slope;
            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;
          }
        } else if (model.colorSpace === ColorSpace2.HSV) {
          var _hsv = [];
          var _hsv2 = [];
          rgb2hsv(rgb1, _hsv);
          rgb2hsv(rgb2, _hsv2);
          if (model.hSVWrap && (_hsv[0] - _hsv2[0] > 0.5 || _hsv2[0] - _hsv[0] > 0.5)) {
            if (_hsv[0] > _hsv2[0]) {
              _hsv[0] -= 1;
            } else {
              _hsv2[0] -= 1;
            }
          }
          var _hsvTmp = [];
          for (var _j = 0; _j < 3; _j++) {
            slope = _hsv2[_j] - _hsv[_j];
            t = (1 - sharpness) * slope;
            _hsvTmp[_j] = h1 * _hsv[_j] + h2 * _hsv2[_j] + h3 * t + h4 * t;
            if (_j === 0 && _hsvTmp[_j] < 0) {
              _hsvTmp[_j] += 1;
            }
          }
          hsv2rgb(_hsvTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.LAB) {
          var _lab = [];
          var _lab2 = [];
          rgb2lab(rgb1, _lab);
          rgb2lab(rgb2, _lab2);
          var _labTmp = [];
          for (var _j2 = 0; _j2 < 3; _j2++) {
            slope = _lab2[_j2] - _lab[_j2];
            t = (1 - sharpness) * slope;
            _labTmp[_j2] = h1 * _lab[_j2] + h2 * _lab2[_j2] + h3 * t + h4 * t;
          }
          lab2rgb(_labTmp, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else if (model.colorSpace === ColorSpace2.DIVERGING) {
          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);
          table[tidx] = tmpVec[0];
          table[tidx + 1] = tmpVec[1];
          table[tidx + 2] = tmpVec[2];
        } else {
          vtkErrorMacro4("ColorSpace set to invalid value.");
        }
        for (var _j3 = 0; _j3 < 3; _j3++) {
          table[tidx + _j3] = table[tidx + _j3] < 0 ? 0 : table[tidx + _j3];
          table[tidx + _j3] = table[tidx + _j3] > 1 ? 1 : table[tidx + _j3];
        }
      }
    }
  };
  publicAPI.getUint8Table = function(xStart, xEnd, size) {
    var withAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {
      return model.table;
    }
    if (model.nodes.length === 0) {
      vtkErrorMacro4("Attempting to lookup a value with no points in the function");
      return model.table;
    }
    var nbChannels = withAlpha ? 4 : 3;
    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {
      model.table = new Uint8Array(size * nbChannels);
      model.tableSize = size;
      model.tableWithAlpha = withAlpha;
    }
    var tmpTable = [];
    publicAPI.getTable(xStart, xEnd, size, tmpTable);
    for (var i = 0; i < size; i++) {
      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255 + 0.5);
      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255 + 0.5);
      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255 + 0.5);
      if (withAlpha) {
        model.table[i * nbChannels + 3] = 255;
      }
    }
    model.buildTime.modified();
    return model.table;
  };
  publicAPI.buildFunctionFromTable = function(xStart, xEnd, size, table) {
    var inc = 0;
    publicAPI.removeAllPoints();
    if (size > 1) {
      inc = (xEnd - xStart) / (size - 1);
    }
    for (var i = 0; i < size; i++) {
      var node = {
        x: xStart + inc * i,
        r: table[i * 3],
        g: table[i * 3 + 1],
        b: table[i * 3 + 2],
        sharpness: 0,
        midpoint: 0.5
      };
      model.nodes.push(node);
    }
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.getNodeValue = function(index, val) {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro4("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].r;
    val[2] = model.nodes[index].g;
    val[3] = model.nodes[index].b;
    val[4] = model.nodes[index].midpoint;
    val[5] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index, val) {
    if (index < 0 || index >= model.nodes.length) {
      vtkErrorMacro4("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].r = val[1];
    model.nodes[index].g = val[2];
    model.nodes[index].b = val[3];
    model.nodes[index].midpoint = val[4];
    model.nodes[index].sharpness = val[5];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    if (model.indexedLookup && publicAPI.getSize()) {
      return publicAPI.getSize();
    }
    if (model.tableSize) {
      return model.tableSize;
    }
    return 16777216;
  };
  publicAPI.getIndexedColor = function(idx, rgba) {
    var n = publicAPI.getSize();
    if (n > 0 && idx >= 0) {
      var nodeValue = [];
      publicAPI.getNodeValue(idx % n, nodeValue);
      for (var j = 0; j < 3; ++j) {
        rgba[j] = nodeValue[j + 1];
      }
      rgba[3] = 1;
      return;
    }
    publicAPI.getNanColor(rgba);
    rgba[3] = 1;
  };
  publicAPI.fillFromDataPointer = function(nb, ptr) {
    if (nb <= 0 || !ptr) {
      return;
    }
    publicAPI.removeAllPoints();
    for (var i = 0; i < nb; i++) {
      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);
    }
  };
  publicAPI.setMappingRange = function(min2, max2) {
    var range = [min2, max2];
    var originalRange = publicAPI.getRange();
    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {
      return;
    }
    if (range[1] === range[0]) {
      vtkErrorMacro4("attempt to set zero width color range");
      return;
    }
    var scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);
    var shift = range[0] - originalRange[0] * scale;
    for (var i = 0; i < model.nodes.length; ++i) {
      model.nodes[i].x = model.nodes[i].x * scale + shift;
    }
    model.mappingRange[0] = range[0];
    model.mappingRange[1] = range[1];
    publicAPI.modified();
  };
  publicAPI.adjustRange = function(range) {
    var functionRange = publicAPI.getRange();
    var rgb = [];
    if (functionRange[0] < range[0]) {
      publicAPI.getColor(range[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[0], rgb);
      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);
    }
    if (functionRange[1] > range[1]) {
      publicAPI.getColor(range[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    } else {
      publicAPI.getColor(functionRange[1], rgb);
      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    if (model.nodes.length < 2) {
      return -1;
    }
    var distance = Number.MAX_VALUE;
    for (var i = 0; i < model.nodes.length - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.mapScalarsThroughTable = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkDebugMacro3("Transfer Function Has No Points!");
      return;
    }
    if (model.indexedLookup) {
      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);
    } else {
      publicAPI.mapData(input, output, outFormat, inputOffset);
    }
  };
  publicAPI.mapData = function(input, output, outFormat, inputOffset) {
    if (publicAPI.getSize() === 0) {
      vtkWarningMacro3("Transfer Function Has No Points!");
      return;
    }
    var alpha = Math.floor(publicAPI.getAlpha() * 255 + 0.5);
    var length = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    var rgb = [];
    if (outFormat === ScalarMappingTarget3.RGBA) {
      for (var i = 0; i < length; i++) {
        var x = inputV[i * inIncr + inputOffset];
        publicAPI.getColor(x, rgb);
        outputV[i * 4] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255 + 0.5);
        outputV[i * 4 + 3] = alpha;
      }
    }
    if (outFormat === ScalarMappingTarget3.RGB) {
      for (var _i2 = 0; _i2 < length; _i2++) {
        var _x = inputV[_i2 * inIncr + inputOffset];
        publicAPI.getColor(_x, rgb);
        outputV[_i2 * 3] = Math.floor(rgb[0] * 255 + 0.5);
        outputV[_i2 * 3 + 1] = Math.floor(rgb[1] * 255 + 0.5);
        outputV[_i2 * 3 + 2] = Math.floor(rgb[2] * 255 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget3.LUMINANCE) {
      for (var _i3 = 0; _i3 < length; _i3++) {
        var _x2 = inputV[_i3 * inIncr + inputOffset];
        publicAPI.getColor(_x2, rgb);
        outputV[_i3] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
      }
    }
    if (outFormat === ScalarMappingTarget3.LUMINANCE_ALPHA) {
      for (var _i4 = 0; _i4 < length; _i4++) {
        var _x3 = inputV[_i4 * inIncr + inputOffset];
        publicAPI.getColor(_x3, rgb);
        outputV[_i4 * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);
        outputV[_i4 * 2 + 1] = alpha;
      }
    }
  };
  publicAPI.applyColorMap = function(colorMap) {
    if (colorMap.ColorSpace) {
      model.colorSpace = ColorSpace2[colorMap.ColorSpace.toUpperCase()];
      if (model.colorSpace === void 0) {
        vtkErrorMacro4("ColorSpace ".concat(colorMap.ColorSpace, " not supported, using RGB instead"));
        model.colorSpace = ColorSpace2.RGB;
      }
    }
    if (colorMap.NanColor) {
      model.nanColor = [].concat(colorMap.NanColor);
      while (model.nanColor.length < 4) {
        model.nanColor.push(1);
      }
    }
    if (colorMap.RGBPoints) {
      var size = colorMap.RGBPoints.length;
      model.nodes = [];
      var midpoint = 0.5;
      var sharpness = 0;
      for (var i = 0; i < size; i += 4) {
        model.nodes.push({
          x: colorMap.RGBPoints[i],
          r: colorMap.RGBPoints[i + 1],
          g: colorMap.RGBPoints[i + 2],
          b: colorMap.RGBPoints[i + 3],
          midpoint,
          sharpness
        });
      }
    }
    publicAPI.sortAndUpdateRange();
  };
}
function extend7(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  model.table = [];
  model.nodes = [];
  model.nanColor = [0.5, 0, 0, 1];
  model.belowRangeColor = [0, 0, 0, 1];
  model.aboveRangeColor = [1, 1, 1, 1];
  model.buildTime = {};
  macro.obj(model.buildTime);
  macro.get(publicAPI, model, ["buildTime", "mappingRange"]);
  macro.setGet(publicAPI, model, ["useAboveRangeColor", "useBelowRangeColor", "colorSpace", "discretize", "numberOfValues"]);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkColorTransferFunction(publicAPI, model);
}
var ColorSpace2, Scale2, ScalarMappingTarget3, vtkDebugMacro3, vtkErrorMacro4, vtkWarningMacro3, DEFAULT_VALUES7, newInstance9, vtkColorTransferFunction$1;
var init_ColorTransferFunction = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js"() {
    init_defineProperty();
    init_macros();
    init_Math();
    init_ScalarsToColors();
    init_Constants5();
    ColorSpace2 = Constants4.ColorSpace;
    Scale2 = Constants4.Scale;
    ScalarMappingTarget3 = vtkScalarsToColors$1.ScalarMappingTarget;
    vtkDebugMacro3 = macro.vtkDebugMacro;
    vtkErrorMacro4 = macro.vtkErrorMacro;
    vtkWarningMacro3 = macro.vtkWarningMacro;
    DEFAULT_VALUES7 = {
      clamping: true,
      colorSpace: ColorSpace2.RGB,
      hSVWrap: true,
      scale: Scale2.LINEAR,
      nanColor: null,
      belowRangeColor: null,
      aboveRangeColor: null,
      useAboveRangeColor: false,
      useBelowRangeColor: false,
      allowDuplicateScalars: false,
      table: null,
      tableSize: 0,
      buildTime: null,
      nodes: null,
      discretize: false,
      numberOfValues: 256
    };
    newInstance9 = macro.newInstance(extend7, "vtkColorTransferFunction");
    vtkColorTransferFunction$1 = _objectSpread7({
      newInstance: newInstance9,
      extend: extend7
    }, Constants4);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js
function vtkPiecewiseFunction(publicAPI, model) {
  model.classHierarchy.push("vtkPiecewiseFunction");
  publicAPI.getSize = function() {
    return model.nodes.length;
  };
  publicAPI.getType = function() {
    var value;
    var prevValue = 0;
    var functionType = 0;
    if (model.nodes.length > 0) {
      prevValue = model.nodes[0].y;
    }
    for (var i = 1; i < model.nodes.length; i++) {
      value = model.nodes[i].y;
      if (value !== prevValue) {
        if (value > prevValue) {
          switch (functionType) {
            case 0:
            case 1:
              functionType = 1;
              break;
            case 2:
            default:
              functionType = 3;
              break;
          }
        } else {
          switch (functionType) {
            case 0:
            case 2:
              functionType = 2;
              break;
            case 1:
            default:
              functionType = 3;
              break;
          }
        }
      }
      prevValue = value;
      if (functionType === 3) {
        break;
      }
    }
    switch (functionType) {
      case 0:
        return "Constant";
      case 1:
        return "NonDecreasing";
      case 2:
        return "NonIncreasing";
      case 3:
      default:
        return "Varied";
    }
  };
  publicAPI.getDataPointer = function() {
    var size = model.nodes.length;
    model.function = null;
    if (size > 0) {
      model.function = [];
      for (var i = 0; i < size; i++) {
        model.function[2 * i] = model.nodes[i].x;
        model.function[2 * i + 1] = model.nodes[i].y;
      }
    }
    return model.function;
  };
  publicAPI.getFirstNonZeroValue = function() {
    if (model.nodes.length === 0) {
      return 0;
    }
    var allZero = 1;
    var x = 0;
    var i = 0;
    for (; i < model.nodes.length; i++) {
      if (model.nodes[i].y !== 0) {
        allZero = 0;
        break;
      }
    }
    if (allZero) {
      x = Number.MAX_VALUE;
    } else if (i > 0) {
      x = model.nodes[i - 1].x;
    } else if (model.clamping) {
      x = -Number.MAX_VALUE;
    } else {
      x = model.nodes[0].x;
    }
    return x;
  };
  publicAPI.getNodeValue = function(index, val) {
    var size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro5("Index out of range!");
      return -1;
    }
    val[0] = model.nodes[index].x;
    val[1] = model.nodes[index].y;
    val[2] = model.nodes[index].midpoint;
    val[3] = model.nodes[index].sharpness;
    return 1;
  };
  publicAPI.setNodeValue = function(index, val) {
    var size = model.nodes.length;
    if (index < 0 || index >= size) {
      vtkErrorMacro5("Index out of range!");
      return -1;
    }
    var oldX = model.nodes[index].x;
    model.nodes[index].x = val[0];
    model.nodes[index].y = val[1];
    model.nodes[index].midpoint = val[2];
    model.nodes[index].sharpness = val[3];
    if (oldX !== val[0]) {
      publicAPI.sortAndUpdateRange();
    } else {
      publicAPI.modified();
    }
    return 1;
  };
  publicAPI.addPoint = function(x, y) {
    return publicAPI.addPointLong(x, y, 0.5, 0);
  };
  publicAPI.addPointLong = function(x, y, midpoint, sharpness) {
    if (midpoint < 0 || midpoint > 1) {
      vtkErrorMacro5("Midpoint outside range [0.0, 1.0]");
      return -1;
    }
    if (sharpness < 0 || sharpness > 1) {
      vtkErrorMacro5("Sharpness outside range [0.0, 1.0]");
      return -1;
    }
    if (!model.allowDuplicateScalars) {
      publicAPI.removePoint(x);
    }
    var node = {
      x,
      y,
      midpoint,
      sharpness
    };
    model.nodes.push(node);
    publicAPI.sortAndUpdateRange();
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i < model.nodes.length) {
      return i;
    }
    return -1;
  };
  publicAPI.setNodes = function(nodes) {
    if (model.nodes !== nodes) {
      model.nodes = nodes;
      publicAPI.sortAndUpdateRange();
    }
  };
  publicAPI.sortAndUpdateRange = function() {
    model.nodes.sort(function(a, b) {
      return a.x - b.x;
    });
    var modifiedInvoked = publicAPI.updateRange();
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
  };
  publicAPI.updateRange = function() {
    var oldRange = model.range.slice();
    var size = model.nodes.length;
    if (size) {
      model.range[0] = model.nodes[0].x;
      model.range[1] = model.nodes[size - 1].x;
    } else {
      model.range[0] = 0;
      model.range[1] = 0;
    }
    if (oldRange[0] === model.range[0] && oldRange[1] === model.range[1]) {
      return false;
    }
    publicAPI.modified();
    return true;
  };
  publicAPI.removePoint = function(x) {
    var i;
    for (i = 0; i < model.nodes.length; i++) {
      if (model.nodes[i].x === x) {
        break;
      }
    }
    if (i >= model.nodes.length) {
      return -1;
    }
    var retVal = i;
    var modifiedInvoked = false;
    model.nodes.splice(i, 1);
    if (i === 0 || i === model.nodes.length) {
      modifiedInvoked = publicAPI.updateRange();
    }
    if (!modifiedInvoked) {
      publicAPI.modified();
    }
    return retVal;
  };
  publicAPI.removeAllPoints = function() {
    model.nodes = [];
    publicAPI.sortAndUpdateRange();
  };
  publicAPI.addSegment = function(x1, y1, x2, y2) {
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {
        model.nodes.splice(i, 1);
      } else {
        i++;
      }
    }
    publicAPI.addPoint(x1, y1, 0.5, 0);
    publicAPI.addPoint(x2, y2, 0.5, 0);
  };
  publicAPI.getValue = function(x) {
    var table = [];
    publicAPI.getTable(x, x, 1, table);
    return table[0];
  };
  publicAPI.adjustRange = function(range) {
    if (range.length < 2) {
      return 0;
    }
    var functionRange = publicAPI.getRange();
    if (functionRange[0] < range[0]) {
      publicAPI.addPoint(range[0], publicAPI.getValue(range[0]));
    } else {
      publicAPI.addPoint(range[0], publicAPI.getValue(functionRange[0]));
    }
    if (functionRange[1] > range[1]) {
      publicAPI.addPoint(range[1], publicAPI.getValue(range[1]));
    } else {
      publicAPI.addPoint(range[1], publicAPI.getValue(functionRange[1]));
    }
    publicAPI.sortAndUpdateRange();
    for (var i = 0; i < model.nodes.length; ) {
      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {
        model.nodes.splice(i, 1);
      } else {
        ++i;
      }
    }
    publicAPI.sortAndUpdateRange();
    return 1;
  };
  publicAPI.estimateMinNumberOfSamples = function(x1, x2) {
    var d = publicAPI.findMinimumXDistance();
    return Math.ceil((x2 - x1) / d);
  };
  publicAPI.findMinimumXDistance = function() {
    var size = model.nodes.length;
    if (size < 2) {
      return -1;
    }
    var distance = model.nodes[1].x - model.nodes[0].x;
    for (var i = 0; i < size - 1; i++) {
      var currentDist = model.nodes[i + 1].x - model.nodes[i].x;
      if (currentDist < distance) {
        distance = currentDist;
      }
    }
    return distance;
  };
  publicAPI.getTable = function(xStart, xEnd, size, table) {
    var stride = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
    var i;
    var idx = 0;
    var numNodes = model.nodes.length;
    var lastValue = 0;
    if (numNodes !== 0) {
      lastValue = model.nodes[numNodes - 1].y;
    }
    var x = 0;
    var x1 = 0;
    var x2 = 0;
    var y1 = 0;
    var y2 = 0;
    var midpoint = 0;
    var sharpness = 0;
    for (i = 0; i < size; i++) {
      var tidx = stride * i;
      if (size > 1) {
        x = xStart + i / (size - 1) * (xEnd - xStart);
      } else {
        x = 0.5 * (xStart + xEnd);
      }
      while (idx < numNodes && x > model.nodes[idx].x) {
        idx++;
        if (idx < numNodes) {
          x1 = model.nodes[idx - 1].x;
          x2 = model.nodes[idx].x;
          y1 = model.nodes[idx - 1].y;
          y2 = model.nodes[idx].y;
          midpoint = model.nodes[idx - 1].midpoint;
          sharpness = model.nodes[idx - 1].sharpness;
          if (midpoint < 1e-5) {
            midpoint = 1e-5;
          }
          if (midpoint > 0.99999) {
            midpoint = 0.99999;
          }
        }
      }
      if (idx >= numNodes) {
        table[tidx] = model.clamping ? lastValue : 0;
      } else if (idx === 0) {
        table[tidx] = model.clamping ? model.nodes[0].y : 0;
      } else {
        var s = (x - x1) / (x2 - x1);
        if (s < midpoint) {
          s = 0.5 * s / midpoint;
        } else {
          s = 0.5 + 0.5 * (s - midpoint) / (1 - midpoint);
        }
        if (sharpness > 0.99) {
          if (s < 0.5) {
            table[tidx] = y1;
            continue;
          } else {
            table[tidx] = y2;
            continue;
          }
        }
        if (sharpness < 0.01) {
          table[tidx] = (1 - s) * y1 + s * y2;
          continue;
        }
        if (s < 0.5) {
          s = 0.5 * Math.pow(s * 2, 1 + 10 * sharpness);
        } else if (s > 0.5) {
          s = 1 - 0.5 * Math.pow((1 - s) * 2, 1 + 10 * sharpness);
        }
        var ss = s * s;
        var sss = ss * s;
        var h1 = 2 * sss - 3 * ss + 1;
        var h2 = -2 * sss + 3 * ss;
        var h3 = sss - 2 * ss + s;
        var h4 = sss - ss;
        var slope = y2 - y1;
        var t = (1 - sharpness) * slope;
        table[tidx] = h1 * y1 + h2 * y2 + h3 * t + h4 * t;
        var min2 = y1 < y2 ? y1 : y2;
        var max2 = y1 > y2 ? y1 : y2;
        table[tidx] = table[tidx] < min2 ? min2 : table[tidx];
        table[tidx] = table[tidx] > max2 ? max2 : table[tidx];
      }
    }
  };
}
function extend8(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  model.nodes = [];
  macro.setGet(publicAPI, model, ["allowDuplicateScalars", "clamping"]);
  macro.setArray(publicAPI, model, ["range"], 2);
  macro.getArray(publicAPI, model, ["range"]);
  vtkPiecewiseFunction(publicAPI, model);
}
var vtkErrorMacro5, DEFAULT_VALUES8, newInstance10, vtkPiecewiseFunction$1;
var init_PiecewiseFunction = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/PiecewiseFunction.js"() {
    init_macros();
    vtkErrorMacro5 = macro.vtkErrorMacro;
    DEFAULT_VALUES8 = {
      range: [0, 0],
      clamping: true,
      allowDuplicateScalars: false
    };
    newInstance10 = macro.newInstance(extend8, "vtkPiecewiseFunction");
    vtkPiecewiseFunction$1 = {
      newInstance: newInstance10,
      extend: extend8
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js
var InterpolationType, OpacityMode, Constants5;
var init_Constants6 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty/Constants.js"() {
    InterpolationType = {
      NEAREST: 0,
      LINEAR: 1,
      FAST_LINEAR: 2
    };
    OpacityMode = {
      FRACTIONAL: 0,
      PROPORTIONAL: 1
    };
    Constants5 = {
      InterpolationType,
      OpacityMode
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js
function ownKeys8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys8(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkVolumeProperty(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeProperty");
  publicAPI.getMTime = function() {
    var mTime = model.mtime;
    var time;
    for (var index = 0; index < VTK_MAX_VRCOMP; index++) {
      if (model.componentData[index].colorChannels === 1) {
        if (model.componentData[index].grayTransferFunction) {
          time = model.componentData[index].grayTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      } else if (model.componentData[index].colorChannels === 3) {
        if (model.componentData[index].rGBTransferFunction) {
          time = model.componentData[index].rGBTransferFunction.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
      if (model.componentData[index].scalarOpacity) {
        time = model.componentData[index].scalarOpacity.getMTime();
        mTime = mTime > time ? mTime : time;
      }
      if (model.componentData[index].gradientOpacity) {
        if (!model.componentData[index].disableGradientOpacity) {
          time = model.componentData[index].gradientOpacity.getMTime();
          mTime = mTime > time ? mTime : time;
        }
      }
    }
    return mTime;
  };
  publicAPI.getColorChannels = function(index) {
    if (index < 0 || index > 3) {
      vtkErrorMacro6("Bad index - must be between 0 and 3");
      return 0;
    }
    return model.componentData[index].colorChannels;
  };
  publicAPI.setGrayTransferFunction = function(index, func) {
    var modified = false;
    if (model.componentData[index].grayTransferFunction !== func) {
      model.componentData[index].grayTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 1) {
      model.componentData[index].colorChannels = 1;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getGrayTransferFunction = function(index) {
    if (model.componentData[index].grayTransferFunction === null) {
      model.componentData[index].grayTransferFunction = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index].grayTransferFunction.addPoint(0, 0);
      model.componentData[index].grayTransferFunction.addPoint(1024, 1);
      if (model.componentData[index].colorChannels !== 1) {
        model.componentData[index].colorChannels = 1;
      }
      publicAPI.modified();
    }
    return model.componentData[index].grayTransferFunction;
  };
  publicAPI.setRGBTransferFunction = function(index, func) {
    var modified = false;
    if (model.componentData[index].rGBTransferFunction !== func) {
      model.componentData[index].rGBTransferFunction = func;
      modified = true;
    }
    if (model.componentData[index].colorChannels !== 3) {
      model.componentData[index].colorChannels = 3;
      modified = true;
    }
    if (modified) {
      publicAPI.modified();
    }
    return modified;
  };
  publicAPI.getRGBTransferFunction = function(index) {
    if (model.componentData[index].rGBTransferFunction === null) {
      model.componentData[index].rGBTransferFunction = vtkColorTransferFunction$1.newInstance();
      model.componentData[index].rGBTransferFunction.addRGBPoint(0, 0, 0, 0);
      model.componentData[index].rGBTransferFunction.addRGBPoint(1024, 1, 1, 1);
      if (model.componentData[index].colorChannels !== 3) {
        model.componentData[index].colorChannels = 3;
      }
      publicAPI.modified();
    }
    return model.componentData[index].rGBTransferFunction;
  };
  publicAPI.setScalarOpacity = function(index, func) {
    if (model.componentData[index].scalarOpacity !== func) {
      model.componentData[index].scalarOpacity = func;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getScalarOpacity = function(index) {
    if (model.componentData[index].scalarOpacity === null) {
      model.componentData[index].scalarOpacity = vtkPiecewiseFunction$1.newInstance();
      model.componentData[index].scalarOpacity.addPoint(0, 1);
      model.componentData[index].scalarOpacity.addPoint(1024, 1);
      publicAPI.modified();
    }
    return model.componentData[index].scalarOpacity;
  };
  publicAPI.setComponentWeight = function(index, value) {
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro6("Invalid index");
      return false;
    }
    var val = Math.min(1, Math.max(0, value));
    if (model.componentData[index].componentWeight !== val) {
      model.componentData[index].componentWeight = val;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getComponentWeight = function(index) {
    if (index < 0 || index >= VTK_MAX_VRCOMP) {
      vtkErrorMacro6("Invalid index");
      return 0;
    }
    return model.componentData[index].componentWeight;
  };
  publicAPI.setInterpolationTypeToNearest = function() {
    return publicAPI.setInterpolationType(InterpolationType2.NEAREST);
  };
  publicAPI.setInterpolationTypeToLinear = function() {
    return publicAPI.setInterpolationType(InterpolationType2.LINEAR);
  };
  publicAPI.setInterpolationTypeToFastLinear = function() {
    return publicAPI.setInterpolationType(InterpolationType2.FAST_LINEAR);
  };
  publicAPI.getInterpolationTypeAsString = function() {
    return macro.enumToString(InterpolationType2, model.interpolationType);
  };
  var sets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode"];
  sets.forEach(function(val) {
    var cap = macro.capitalize(val);
    publicAPI["set".concat(cap)] = function(index, value) {
      if (model.componentData[index]["".concat(val)] !== value) {
        model.componentData[index]["".concat(val)] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  });
  var gets = ["useGradientOpacity", "scalarOpacityUnitDistance", "gradientOpacityMinimumValue", "gradientOpacityMinimumOpacity", "gradientOpacityMaximumValue", "gradientOpacityMaximumOpacity", "opacityMode"];
  gets.forEach(function(val) {
    var cap = macro.capitalize(val);
    publicAPI["get".concat(cap)] = function(index) {
      return model.componentData[index]["".concat(val)];
    };
  });
}
function extend9(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  macro.obj(publicAPI, model);
  if (!model.componentData) {
    model.componentData = [];
    for (var i = 0; i < VTK_MAX_VRCOMP; ++i) {
      model.componentData.push({
        colorChannels: 1,
        grayTransferFunction: null,
        rGBTransferFunction: null,
        scalarOpacity: null,
        scalarOpacityUnitDistance: 1,
        opacityMode: OpacityMode2.FRACTIONAL,
        gradientOpacityMinimumValue: 0,
        gradientOpacityMinimumOpacity: 0,
        gradientOpacityMaximumValue: 1,
        gradientOpacityMaximumOpacity: 1,
        useGradientOpacity: false,
        componentWeight: 1
      });
    }
  }
  macro.setGet(publicAPI, model, ["independentComponents", "interpolationType", "shade", "ambient", "diffuse", "specular", "specularPower", "useLabelOutline", "labelOutlineThickness"]);
  vtkVolumeProperty(publicAPI, model);
}
var InterpolationType2, OpacityMode2, vtkErrorMacro6, VTK_MAX_VRCOMP, DEFAULT_VALUES9, newInstance11, vtkVolumeProperty$1;
var init_VolumeProperty = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/VolumeProperty.js"() {
    init_defineProperty();
    init_macros();
    init_ColorTransferFunction();
    init_PiecewiseFunction();
    init_Constants6();
    InterpolationType2 = Constants5.InterpolationType;
    OpacityMode2 = Constants5.OpacityMode;
    vtkErrorMacro6 = macro.vtkErrorMacro;
    VTK_MAX_VRCOMP = 4;
    DEFAULT_VALUES9 = {
      independentComponents: true,
      interpolationType: InterpolationType2.FAST_LINEAR,
      shade: 0,
      ambient: 0.1,
      diffuse: 0.7,
      specular: 0.2,
      specularPower: 10,
      useLabelOutline: false,
      labelOutlineThickness: 1
    };
    newInstance11 = macro.newInstance(extend9, "vtkVolumeProperty");
    vtkVolumeProperty$1 = _objectSpread8({
      newInstance: newInstance11,
      extend: extend9
    }, Constants5);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Volume.js
var Volume_exports = {};
__export(Volume_exports, {
  default: () => vtkVolume$1,
  extend: () => extend10,
  newInstance: () => newInstance12
});
function vtkVolume(publicAPI, model) {
  model.classHierarchy.push("vtkVolume");
  publicAPI.getVolumes = function() {
    return publicAPI;
  };
  publicAPI.makeProperty = vtkVolumeProperty$1.newInstance;
  publicAPI.getProperty = function() {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = function() {
    if (model.mapper === null) {
      return model.bounds;
    }
    var bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    var zip = function zip2(rows) {
      return rows[0].map(function(_, c) {
        return rows.map(function(row) {
          return row[c];
        });
      });
    };
    if (!model.mapperBounds || !zip([bds, model.mapperBounds]).reduce(function(a, b) {
      return a && b[0] === b[1];
    }, true) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro4("Recomputing bounds...");
      model.mapperBounds = bds.map(function(x) {
        return x;
      });
      var bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      var tmp4 = new Float64Array(16);
      mat4_exports.transpose(tmp4, model.matrix);
      bbox.forEach(function(pt) {
        return vec3_exports.transformMat4(pt, pt, tmp4);
      });
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map(function(d, i) {
        return i % 2 === 0 ? bbox.reduce(function(a, b) {
          return a > b[i / 2] ? b[i / 2] : a;
        }, d) : bbox.reduce(function(a, b) {
          return a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a;
        }, d);
      });
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = function() {
    var mt = model.mtime;
    if (model.property !== null) {
      var time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = function() {
    var mt = model.mtime;
    if (model.mapper !== null) {
      var time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
}
function extend10(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["mapper"]);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkVolume(publicAPI, model);
}
var vtkDebugMacro4, DEFAULT_VALUES10, newInstance12, vtkVolume$1;
var init_Volume = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Volume.js"() {
    init_esm();
    init_macros();
    init_BoundingBox();
    init_Prop3D();
    init_VolumeProperty();
    vtkDebugMacro4 = macro.vtkDebugMacro;
    DEFAULT_VALUES10 = {
      mapper: null,
      property: null,
      bounds: [1, -1, 1, -1, 1, -1]
    };
    newInstance12 = macro.newInstance(extend10, "vtkVolume");
    vtkVolume$1 = {
      newInstance: newInstance12,
      extend: extend10
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  publicAPI.build = function(prepass) {
  };
  publicAPI.render = function(prepass) {
  };
  publicAPI.traverse = function(renderPass) {
    var passTraversal = renderPass.getTraverseOperation();
    var fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (var index = 0; index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = function(renderPass, prepass) {
    var customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = function(dataObject) {
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (var index = 0; index < model.children.length; ++index) {
      var child = model.children[index];
      var vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return void 0;
  };
  publicAPI.getFirstAncestorOfType = function(type) {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.addMissingNode = function(dobj) {
    if (!dobj) {
      return;
    }
    var result = model._renderableChildMap.get(dobj);
    if (result !== void 0) {
      result.setVisited(true);
    } else {
      var newNode = publicAPI.createViewNode(dobj);
      if (newNode) {
        newNode.setParent(publicAPI);
        newNode.setVisited(true);
        model._renderableChildMap.set(dobj, newNode);
        model.children.push(newNode);
      }
    }
  };
  publicAPI.addMissingNodes = function(dataObjs) {
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    for (var index = 0; index < dataObjs.length; ++index) {
      var dobj = dataObjs[index];
      var result = model._renderableChildMap.get(dobj);
      if (result !== void 0) {
        result.setVisited(true);
      } else {
        var newNode = publicAPI.createViewNode(dobj);
        if (newNode) {
          newNode.setParent(publicAPI);
          newNode.setVisited(true);
          model._renderableChildMap.set(dobj, newNode);
          model.children.push(newNode);
        }
      }
    }
  };
  publicAPI.prepareNodes = function() {
    for (var index = 0; index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };
  publicAPI.setVisited = function(val) {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = function() {
    var deleted = null;
    for (var index = 0; index < model.children.length; ++index) {
      var child = model.children[index];
      var visited = child.getVisited();
      if (!visited) {
        var renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        if (!deleted) {
          deleted = [];
        }
        deleted.push(child);
      } else {
        child.setVisited(false);
      }
    }
    if (deleted) {
      model.children = model.children.filter(function(el) {
        return !deleted.includes(el);
      });
    }
  };
  publicAPI.createViewNode = function(dataObj) {
    if (!model.myFactory) {
      vtkErrorMacro7("Cannot create view nodes without my own factory");
      return null;
    }
    var ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
}
function extend11(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var vtkErrorMacro7, PASS_TYPES, DEFAULT_VALUES11, newInstance13, vtkViewNode$1;
var init_ViewNode = __esm({
  "node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js"() {
    init_macros();
    vtkErrorMacro7 = macro.vtkErrorMacro;
    PASS_TYPES = ["Build", "Render"];
    DEFAULT_VALUES11 = {
      renderable: null,
      myFactory: null,
      children: [],
      visited: false
    };
    newInstance13 = macro.newInstance(extend11, "vtkViewNode");
    vtkViewNode$1 = {
      newInstance: newInstance13,
      extend: extend11,
      PASS_TYPES
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
var ViewNodeFactory_exports = {};
__export(ViewNodeFactory_exports, {
  default: () => vtkViewNodeFactory$1,
  extend: () => extend12,
  newInstance: () => newInstance14
});
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = function(dataObject) {
    if (dataObject.isDeleted()) {
      return null;
    }
    var cpt = 0;
    var className = dataObject.getClassName(cpt++);
    var isObject = false;
    var keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    var vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
  publicAPI.registerOverride = function(className, func) {
    model.overrides[className] = func;
  };
}
function extend12(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var DEFAULT_VALUES12, newInstance14, vtkViewNodeFactory$1;
var init_ViewNodeFactory = __esm({
  "node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js"() {
    init_macros();
    DEFAULT_VALUES12 = {};
    newInstance14 = macro.newInstance(extend12, "vtkViewNodeFactory");
    vtkViewNodeFactory$1 = {
      newInstance: newInstance14,
      extend: extend12
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
function extend13(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
var CLASS_MAPPING, DEFAULT_VALUES13, newInstance15, vtkViewNodeFactory2;
var init_ViewNodeFactory2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js"() {
    init_macros();
    init_ViewNodeFactory();
    CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
    DEFAULT_VALUES13 = {};
    newInstance15 = macro.newInstance(extend13, "vtkOpenGLViewNodeFactory");
    vtkViewNodeFactory2 = {
      newInstance: newInstance15,
      extend: extend13
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
var Camera_exports2 = {};
__export(Camera_exports2, {
  default: () => vtkCamera2,
  extend: () => extend14,
  newInstance: () => newInstance16
});
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      var tsize = model.openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = function(ren) {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      var aspectRatio = model.openGLRenderer.getAspectRatio();
      mat4_exports.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      mat4_exports.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      mat4_exports.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
function extend14(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var DEFAULT_VALUES14, newInstance16, vtkCamera2;
var init_Camera2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    DEFAULT_VALUES14 = {
      context: null,
      lastRenderer: null,
      keyMatrixTime: null,
      keyMatrices: null
    };
    newInstance16 = newInstance(extend14);
    vtkCamera2 = {
      newInstance: newInstance16,
      extend: extend14
    };
    registerOverride("vtkCamera", newInstance16);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var Renderer_exports = {};
__export(Renderer_exports, {
  default: () => vtkRenderer,
  extend: () => extend15,
  newInstance: () => newInstance17
});
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = function() {
    var count = 0;
    var lights = model.renderable.getLightsByReference();
    for (var index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro5("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      var clearMask = 0;
      var gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      var ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      gl.clear(clearMask);
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.cameraPass = function(prepass) {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = function() {
    var size = model._parent.getSizeByReference();
    var viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = function() {
    var vport = model.renderable.getViewportByReference();
    var tileViewPort = [0, 0, 1, 1];
    var vpu = vport[0] - tileViewPort[0];
    var vpv = vport[1] - tileViewPort[1];
    var ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    var lowerLeftU = Math.round(ndvp[0]);
    var lowerLeftV = Math.round(ndvp[1]);
    var vpu2 = vport[2] - tileViewPort[0];
    var vpv2 = vport[3] - tileViewPort[1];
    var ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    var usize = Math.round(ndvp2[0]) - lowerLeftU;
    var vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = function() {
    var clearMask = 0;
    var gl = model.context;
    if (!model.renderable.getTransparent()) {
      var background = model.renderable.getBackgroundByReference();
      model.context.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      model.context.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    var ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.clear(clearMask);
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
function extend15(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var vtkDebugMacro5, DEFAULT_VALUES15, newInstance17, vtkRenderer;
var init_Renderer = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js"() {
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    vtkDebugMacro5 = vtkDebugMacro;
    DEFAULT_VALUES15 = {
      context: null,
      _openGLRenderWindow: null,
      selector: null
    };
    newInstance17 = newInstance(extend15, "vtkOpenGLRenderer");
    vtkRenderer = {
      newInstance: newInstance17,
      extend: extend15
    };
    registerOverride("vtkRenderer", newInstance17);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js
var SlicingMode, Constants6;
var init_Constants7 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/ImageMapper/Constants.js"() {
    SlicingMode = {
      NONE: -1,
      I: 0,
      J: 1,
      K: 2,
      X: 3,
      Y: 4,
      Z: 5
    };
    Constants6 = {
      SlicingMode
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var ObjectType, Constants7;
var init_Constants8 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js"() {
    ObjectType = {
      ARRAY_BUFFER: 0,
      ELEMENT_ARRAY_BUFFER: 1,
      TEXTURE_BUFFER: 2
    };
    Constants7 = {
      ObjectType
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
function ownKeys9(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys9(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType2.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType2.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType2.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  var internalType = null;
  var internalHandle = null;
  var dirty = true;
  var error = "";
  publicAPI.getType = function() {
    return internalType;
  };
  publicAPI.setType = function(value) {
    internalType = value;
  };
  publicAPI.getHandle = function() {
    return internalHandle;
  };
  publicAPI.isReady = function() {
    return dirty === false;
  };
  publicAPI.generateBuffer = function(type) {
    var objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = function(data, type) {
    var alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    dirty = false;
    return true;
  };
  publicAPI.bind = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = function() {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = function() {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
    }
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = function() {
    return error;
  };
}
function extend16(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var ObjectType2, STATIC4, DEFAULT_VALUES16, newInstance18, vtkBufferObject;
var init_BufferObject = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js"() {
    init_defineProperty();
    init_macros();
    init_Constants8();
    ObjectType2 = Constants7.ObjectType;
    STATIC4 = {};
    DEFAULT_VALUES16 = {
      objectType: ObjectType2.ARRAY_BUFFER,
      context: null
    };
    newInstance18 = macro.newInstance(extend16);
    vtkBufferObject = _objectSpread9(_objectSpread9({
      newInstance: newInstance18,
      extend: extend16
    }, STATIC4), Constants7);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Constants_exports3 = {};
__export(Constants_exports3, {
  Interpolation: () => Interpolation,
  Representation: () => Representation,
  Shading: () => Shading,
  default: () => PropertyConst
});
var Shading, Representation, Interpolation, PropertyConst;
var init_Constants9 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js"() {
    Shading = {
      FLAT: 0,
      GOURAUD: 1,
      PHONG: 2
    };
    Representation = {
      POINTS: 0,
      WIREFRAME: 1,
      SURFACE: 2
    };
    Interpolation = Shading;
    PropertyConst = {
      Shading,
      Representation,
      Interpolation
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  var inverseScale = new Float64Array(3);
  vec3_exports.inverse(inverseScale, coordScale);
  var matrix = new Float64Array(16);
  mat4_exports.fromRotationTranslationScale(matrix, quat_exports.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(vec3_exports.exactEquals(coordShift, [0, 0, 0]) && vec3_exports.exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    var pointData = options.points.getData();
    var normalData = null;
    var tcoordData = null;
    var colorData = null;
    var colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    var textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach(function(a) {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    var pointIdx = 0;
    var normalIdx = 0;
    var tcoordIdx = 0;
    var colorIdx = 0;
    var custIdx = 0;
    var cellCount = 0;
    var addAPoint;
    var cellBuilders = {
      anythingToPoints: function anythingToPoints2(numPoints2, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints2; ++i2) {
          addAPoint(cellPts[offset + i2]);
        }
      },
      linesToWireframe: function linesToWireframe2(numPoints2, cellPts, offset) {
        for (var i2 = 0; i2 < numPoints2 - 1; ++i2) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1]);
        }
      },
      polysToWireframe: function polysToWireframe2(numPoints2, cellPts, offset) {
        if (numPoints2 > 2) {
          for (var i2 = 0; i2 < numPoints2; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + (i2 + 1) % numPoints2]);
          }
        }
      },
      stripsToWireframe: function stripsToWireframe2(numPoints2, cellPts, offset) {
        if (numPoints2 > 2) {
          for (var i2 = 0; i2 < numPoints2 - 1; ++i2) {
            addAPoint(cellPts[offset + i2]);
            addAPoint(cellPts[offset + i2 + 1]);
          }
          for (var _i = 0; _i < numPoints2 - 2; _i++) {
            addAPoint(cellPts[offset + _i]);
            addAPoint(cellPts[offset + _i + 2]);
          }
        }
      },
      polysToSurface: function polysToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + 0]);
          addAPoint(cellPts[offset + i2 + 1]);
          addAPoint(cellPts[offset + i2 + 2]);
        }
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        for (var i2 = 0; i2 < npts - 2; i2++) {
          addAPoint(cellPts[offset + i2]);
          addAPoint(cellPts[offset + i2 + 1 + i2 % 2]);
          addAPoint(cellPts[offset + i2 + 1 + (i2 + 1) % 2]);
        }
      }
    };
    var cellCounters2 = {
      anythingToPoints: function anythingToPoints2(numPoints2, cellPts) {
        return numPoints2;
      },
      linesToWireframe: function linesToWireframe2(numPoints2, cellPts) {
        if (numPoints2 > 1) {
          return (numPoints2 - 1) * 2;
        }
        return 0;
      },
      polysToWireframe: function polysToWireframe2(numPoints2, cellPts) {
        if (numPoints2 > 2) {
          return numPoints2 * 2;
        }
        return 0;
      },
      stripsToWireframe: function stripsToWireframe2(numPoints2, cellPts) {
        if (numPoints2 > 2) {
          return numPoints2 * 4 - 6;
        }
        return 0;
      },
      polysToSurface: function polysToSurface2(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface: function stripsToSurface2(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    var func = null;
    var countFunc = null;
    if (outRep === Representation.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters2.anythingToPoints;
    } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
      func = cellBuilders["".concat(inRep, "ToWireframe")];
      countFunc = cellCounters2["".concat(inRep, "ToWireframe")];
    } else {
      func = cellBuilders["".concat(inRep, "ToSurface")];
      countFunc = cellCounters2["".concat(inRep, "ToSurface")];
    }
    var array = cellArray.getData();
    var size = array.length;
    var caboCount = 0;
    for (var index = 0; index < size; ) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }
    var packedUCVBO = null;
    var packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    var vboidx = 0;
    var ucidx = 0;
    var diagSq = 0;
    var distSq = 0;
    for (var i = 0; i < 3; ++i) {
      var range = options.points.getRange(i);
      var delta = range[1] - range[0];
      diagSq += delta * delta;
      var distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }
    var useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || Math.abs(Math.log10(diagSq)) > 3 || diagSq === 0 && distSq > 1e6);
    if (useShiftAndScale) {
      var coordShift = new Float64Array(3);
      var coordScale = new Float64Array(3);
      for (var _i2 = 0; _i2 < 3; ++_i2) {
        var _range = options.points.getRange(_i2);
        var _delta = _range[1] - _range[0];
        coordShift[_i2] = 0.5 * (_range[1] + _range[0]);
        coordScale[_i2] = _delta > 0 ? 1 / _delta : 1;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    addAPoint = function addAPointFunc(i2) {
      pointIdx = i2 * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = i2 * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach(function(attr) {
        custIdx = i2 * attr.components;
        for (var j2 = 0; j2 < attr.components; ++j2) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        tcoordIdx = i2 * textureComponents;
        for (var j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = i2 * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (var _index = 0; _index < size; ) {
      func(array[_index], array, _index + 1);
      _index += array[_index] + 1;
      cellCount++;
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = function(coordShift, coordScale) {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro8("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro8("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !vec3_exports.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !vec3_exports.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
function extend17(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var vtkErrorMacro8, DEFAULT_VALUES17, newInstance19, vtkCellArrayBufferObject;
var init_CellArrayBufferObject = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js"() {
    init_esm();
    init_macros();
    init_BufferObject();
    init_Constants8();
    init_Constants9();
    vtkErrorMacro8 = macro.vtkErrorMacro;
    DEFAULT_VALUES17 = {
      elementCount: 0,
      stride: 0,
      colorBOStride: 0,
      vertexOffset: 0,
      normalOffset: 0,
      tCoordOffset: 0,
      tCoordComponents: 0,
      colorOffset: 0,
      colorComponents: 0,
      tcoordBO: null,
      customData: [],
      coordShift: null,
      coordScale: null,
      coordShiftAndScaleEnabled: false,
      inverseShiftAndScaleMatrix: null
    };
    newInstance19 = macro.newInstance(extend17);
    vtkCellArrayBufferObject = {
      newInstance: newInstance19,
      extend: extend17
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = function() {
    var stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    var isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro9("Error compiling shader '".concat(model.source, "': ").concat(lastError));
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
function extend18(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var vtkErrorMacro9, DEFAULT_VALUES18, newInstance20, vtkShader$1;
var init_Shader = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js"() {
    init_macros();
    vtkErrorMacro9 = macro.vtkErrorMacro;
    DEFAULT_VALUES18 = {
      shaderType: "Unknown",
      source: "",
      error: "",
      handle: 0,
      dirty: false,
      context: null
    };
    newInstance20 = macro.newInstance(extend18, "vtkShader");
    vtkShader$1 = {
      newInstance: newInstance20,
      extend: extend18
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
function substitute(source, search, replace) {
  var all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  var replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  var gflag = "";
  if (all) {
    gflag = "g";
  }
  var regex = new RegExp(search, gflag);
  var resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = function() {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro10(model.vertexShader.getSource().split("\n").map(function(line, index) {
        return "".concat(index, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro10(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro10(model.fragmentShader.getSource().split("\n").map(function(line, index) {
        return "".concat(index, ": ").concat(line);
      }).join("\n"));
      vtkErrorMacro10(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro10(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro10(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro10("Links failed: ".concat(model.error));
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = function() {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
  };
  publicAPI.bind = function() {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = function() {
    return !!model.bound;
  };
  publicAPI.release = function() {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = function(ctx) {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = function() {
    if (model.inked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    var isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      var lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro10("Error linking shader ".concat(lastError));
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    var f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = function(name, v1, v2) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = function(name, a1, a2, a3) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (a3 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = function(name, a) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };
  publicAPI.setUniform3iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4fv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    var array = args;
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };
  publicAPI.setUniform4iv = function(name, v) {
    var location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = "Could not set uniform ".concat(name, " . No such uniform.");
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = function(name) {
    if (!name || !model.linked) {
      return -1;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = "Uniform ".concat(name, " not found in current shader program.");
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = function(name) {
    if (!name) {
      return false;
    }
    var loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro10("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = function(name) {
    if (!name) {
      return false;
    }
    var loc = Object.keys(model.attributeLocs).indexOf(name);
    if (loc !== -1) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro10("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      var thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.comntext.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = function(shader) {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = function(ctx) {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = function(mtime) {
    model.lastCameraMTime = mtime;
  };
}
function extend19(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var vtkErrorMacro10, DEFAULT_VALUES19, newInstance21, vtkShaderProgram$1;
var init_ShaderProgram = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js"() {
    init_macros();
    init_Shader();
    vtkErrorMacro10 = macro.vtkErrorMacro;
    DEFAULT_VALUES19 = {
      vertexShaderHandle: 0,
      fragmentShaderHandle: 0,
      geometryShaderHandle: 0,
      vertexShader: null,
      fragmentShader: null,
      geometryShader: null,
      linked: false,
      bound: false,
      compiled: false,
      error: "",
      handle: 0,
      numberOfOutputs: 0,
      attributesLocs: null,
      uniformLocs: null,
      md5Hash: 0,
      context: null,
      lastCameraMTime: null
    };
    newInstance21 = macro.newInstance(extend19, "vtkShaderProgram");
    vtkShaderProgram$1 = {
      newInstance: newInstance21,
      extend: extend19,
      substitute
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = function() {
  };
  publicAPI.initialize = function() {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = function() {
    return model.handleVAO !== 0 || model.supported === false;
  };
  publicAPI.bind = function() {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = function() {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      var gl = model.context;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          var matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (var i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = function() {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = function() {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2) {
    return publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, 0, false);
  };
  publicAPI.addAttributeArrayWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, isMatrix) {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    var gl = model.context;
    var attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize2;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      var buffFound = false;
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          var found = false;
          for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
            var attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = function(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor) {
    var result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize2, divisor, true);
    if (!result) {
      return result;
    }
    var gl = model.context;
    var index = gl.getAttribLocation(model.handleProgram, name);
    for (var i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, elementTupleSize, elementType, normalize2, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = function(name) {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (var ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        var buff = model.buffers[ibuff];
        for (var iatt = 0; iatt < buff.attributes.length; ++iatt) {
          var attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
function extend20(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var DEFAULT_VALUES20, newInstance22, vtkVertexArrayObject;
var init_VertexArrayObject = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js"() {
    init_macros();
    init_Constants8();
    DEFAULT_VALUES20 = {
      forceEmulation: false,
      handleVAO: 0,
      handleProgram: 0,
      supported: true,
      buffers: null,
      context: null
    };
    newInstance22 = macro.newInstance(extend20, "vtkOpenGLVertexArrayObject");
    vtkVertexArrayObject = {
      newInstance: newInstance22,
      extend: extend20
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = function(win) {
    model.program.setContext(win.getContext());
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = function(oglwin) {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
}
function extend21(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var DEFAULT_VALUES21, newInstance23, vtkHelper;
var init_Helper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js"() {
    init_macros();
    init_CellArrayBufferObject();
    init_ShaderProgram();
    init_VertexArrayObject();
    DEFAULT_VALUES21 = {
      program: null,
      shaderSourceTime: null,
      VAO: null,
      attributeUpdateTime: null,
      CABO: null,
      primitiveType: 0
    };
    newInstance23 = macro.newInstance(extend21);
    vtkHelper = {
      newInstance: newInstance23,
      extend: extend21
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Constants_exports4 = {};
__export(Constants_exports4, {
  Filter: () => Filter,
  Wrap: () => Wrap,
  default: () => Constants8
});
var Wrap, Filter, Constants8;
var init_Constants10 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js"() {
    Wrap = {
      CLAMP_TO_EDGE: 0,
      REPEAT: 1,
      MIRRORED_REPEAT: 2
    };
    Filter = {
      NEAREST: 0,
      LINEAR: 1,
      NEAREST_MIPMAP_NEAREST: 2,
      NEAREST_MIPMAP_LINEAR: 3,
      LINEAR_MIPMAP_NEAREST: 4,
      LINEAR_MIPMAP_LINEAR: 5
    };
    Constants8 = {
      Wrap,
      Filter
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
function toHalf(val) {
  floatView[0] = val;
  var x = int32View[0];
  var bits = x >> 16 & 32768;
  var m = x >> 12 & 2047;
  var e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e === 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  var s = (h & 32768) >> 15;
  var e = (h & 31744) >> 10;
  var f = h & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  }
  if (e === 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var floatView, int32View, HalfFloat;
var init_HalfFloat = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js"() {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
    HalfFloat = {
      fromHalf,
      toHalf
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var Texture_exports = {};
__export(Texture_exports, {
  default: () => vtkOpenGLTexture$1,
  extend: () => extend22,
  newInstance: () => newInstance24
});
function ownKeys10(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread10(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys10(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys10(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkOpenGLTexture(publicAPI, model) {
  var _this = this;
  model.classHierarchy.push("vtkOpenGLTexture");
  publicAPI.render = function() {
    var renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter2.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter2.NEAREST);
      publicAPI.setMagnificationFilter(Filter2.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap2.REPEAT);
      publicAPI.setWrapS(Wrap2.REPEAT);
      publicAPI.setWrapT(Wrap2.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        var canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw(canvas.width, canvas.height, 4, VtkDataTypes3.UNSIGNED_CHAR, canvas, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        var jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw(jsid.width, jsid.height, 4, VtkDataTypes3.UNSIGNED_CHAR, jsid.data, true);
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      var input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        var ext = input.getExtent();
        var inScalars = input.getPointData().getScalars();
        var data = [];
        for (var i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          var indata = model.renderable.getInputData(i);
          var scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), data);
        } else {
          publicAPI.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  publicAPI.destroyTexture = function() {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = function() {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = function() {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = function() {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = function() {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = function(rwin) {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = function() {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = function() {
    var result = false;
    if (model.context && model.handle) {
      var target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro4("impossible case");
          break;
      }
      var oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = function() {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = function(vtktype, numComps) {
    if (!model.internalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro6("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = function(vtktype, numComps) {
    var result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, false);
    if (result) {
      return result;
    }
    result = _this._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, true);
    if (!result) {
      vtkDebugMacro6("Unsupported internal texture type!");
      vtkDebugMacro6("Unable to find suitable internal format for T=".concat(vtktype, " NC= ").concat(numComps));
    }
    return result;
  };
  publicAPI.setInternalFormat = function(iFormat) {
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = function(vtktype, numComps) {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = function(vtktype, numComps) {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = function() {
    model.format = 0;
    model.internalFormat = 0;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes3.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (useHalfFloatType && VtkDataTypes3.SHORT):
          return model.context.HALF_FLOAT;
        case (useHalfFloatType && VtkDataTypes3.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes3.FLOAT:
        case VtkDataTypes3.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes3.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes3.FLOAT:
      case VtkDataTypes3.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          var halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    var useHalfFloatType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.openGLDataType) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType, useHalfFloatType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = function() {
    var shift = 0;
    var scale = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255;
        shift = 0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536;
        shift = 0;
        break;
      case model.context.INT:
        scale = 21474836475e-1;
        shift = scale - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295;
        shift = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale
    };
  };
  publicAPI.getOpenGLFilterMode = function(emode) {
    switch (emode) {
      case Filter2.NEAREST:
        return model.context.NEAREST;
      case Filter2.LINEAR:
        return model.context.LINEAR;
      case Filter2.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter2.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter2.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter2.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = function(vtktype) {
    switch (vtktype) {
      case Wrap2.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap2.REPEAT:
        return model.context.REPEAT;
      case Wrap2.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  function updateArrayDataType(dataType, data) {
    var depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var pixData = [];
    var pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    if (dataType !== VtkDataTypes3.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          var newArray = new Float32Array(pixCount);
          for (var i = 0; i < pixCount; i++) {
            newArray[i] = data[idx][i];
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes3.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (var _idx = 0; _idx < data.length; _idx++) {
        if (data[_idx]) {
          var _newArray = new Uint8Array(pixCount);
          for (var _i = 0; _i < pixCount; _i++) {
            _newArray[_i] = data[_idx][_i];
          }
          pixData.push(_newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var halfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (halfFloat) {
      for (var _idx2 = 0; _idx2 < data.length; _idx2++) {
        if (data[_idx2]) {
          var _newArray2 = new Uint16Array(pixCount);
          for (var _i2 = 0; _i2 < pixCount; _i2++) {
            _newArray2[_i2] = HalfFloat.toHalf(data[_idx2][_i2]);
          }
          pixData.push(_newArray2);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i3 = 0; _i3 < data.length; _i3++) {
        pixData.push(data[_i3]);
      }
    }
    return pixData;
  }
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    var pixData = [];
    var width = model.width;
    var height = model.height;
    var numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      var halfFloat = model.context.getExtension("OES_texture_half_float");
      var newWidth = nearestPowerOfTwo(width);
      var newHeight = nearestPowerOfTwo(height);
      var pixCount = newWidth * newHeight * model.components;
      for (var idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          var newArray = null;
          var jFactor = height / newHeight;
          var iFactor = width / newWidth;
          var usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (var j = 0; j < newHeight; j++) {
            var joff = j * newWidth * numComps;
            var jidx = j * jFactor;
            var jlow = Math.floor(jidx);
            var jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            var jmix = jidx - jlow;
            var jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (var i = 0; i < newWidth; i++) {
              var ioff = i * numComps;
              var iidx = i * iFactor;
              var ilow = Math.floor(iidx);
              var ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              var imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (var c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (var _i4 = 0; _i4 < data.length; _i4++) {
        pixData.push(data[_i4]);
      }
    }
    return pixData;
  }
  publicAPI.create2DFromRaw = function(width, height, numComps, dataType, data) {
    var flip = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : false;
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var pixData = updateArrayDataType(dataType, dataArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = function(width, height, numComps, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    var pixData = updateArrayDataType(dataType, data);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    var invertedData = [];
    var widthLevel = model.width;
    var heightLevel = model.height;
    for (var i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (var y = 0; y < heightLevel; ++y) {
        var row1 = y * widthLevel * model.components;
        var row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    for (var _i5 = 0; _i5 < 6; _i5++) {
      var j = 0;
      var w = model.width;
      var h = model.height;
      while (w >= 1 && h >= 1) {
        var tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + _i5];
        }
        model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + _i5, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        j++;
        w /= 2;
        h /= 2;
      }
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = function(width, height, dataType, data) {
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes3.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = function(image) {
    publicAPI.getOpenGLDataType(VtkDataTypes3.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes3.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes3.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.width = image.width;
    model.height = image.height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    var needNearestPowerOfTwo = !isPowerOfTwo(image.width) || !isPowerOfTwo(image.height);
    var canvas = document.createElement("canvas");
    canvas.width = needNearestPowerOfTwo ? nearestPowerOfTwo(image.width) : image.width;
    canvas.height = needNearestPowerOfTwo ? nearestPowerOfTwo(image.height) : image.height;
    var ctx = canvas.getContext("2d");
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
    var safeImage = canvas;
    model.context.texImage2D(model.target, 0, model.internalFormat, model.format, model.openGLDataType, safeImage);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(numComps, numPixelsIn, data) {
    var min2 = [];
    var max2 = [];
    for (var c = 0; c < numComps; ++c) {
      min2[c] = data[c];
      max2[c] = data[c];
    }
    var count = 0;
    for (var i = 0; i < numPixelsIn; ++i) {
      for (var _c = 0; _c < numComps; ++_c) {
        if (data[count] < min2[_c]) {
          min2[_c] = data[count];
        }
        if (data[count] > max2[_c]) {
          max2[_c] = data[count];
        }
        count++;
      }
    }
    var offset = [];
    var scale = [];
    for (var _c2 = 0; _c2 < numComps; ++_c2) {
      if (min2[_c2] === max2[_c2]) {
        max2[_c2] = min2[_c2] + 1;
      }
      offset[_c2] = min2[_c2];
      scale[_c2] = max2[_c2] - min2[_c2];
    }
    return {
      scale,
      offset
    };
  }
  function hasExactHalfFloat(offset, scale) {
    for (var c = 0; c < offset.length; c++) {
      var min2 = offset[c];
      var max2 = scale[c] + min2;
      if (min2 < -2048 || min2 > 2048 || max2 < -2048 || max2 > 2048) {
        return false;
      }
    }
    return true;
  }
  function checkUseHalfFloat(dataType, offset, scale, preferSizeOverAccuracy) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    var halfFloatExt = model.context.getExtension("OES_texture_half_float");
    var useHalfFloat = model._openGLRenderWindow.getWebgl2() ? model.openGLDataType === model.context.HALF_FLOAT : halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    if (!useHalfFloat) {
      return false;
    }
    if (!hasExactHalfFloat(offset, scale) && !preferSizeOverAccuracy) {
      return false;
    }
    return true;
  }
  publicAPI.create3DFromRaw = function(width, height, depth, numComps, dataType, data) {
    var useHalfFloatType = true;
    publicAPI.getOpenGLDataType(dataType, useHalfFloatType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    var dataArray = [data];
    var is3DArray = true;
    var pixData = updateArrayDataType(dataType, dataArray, is3DArray);
    var scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function(width, height, depth, numComps, dataType, data) {
    var preferSizeOverAccuracy = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : false;
    var numPixelsIn = width * height * depth;
    var offset = [];
    var scale = [];
    for (var c = 0; c < numComps; ++c) {
      offset[c] = 0;
      scale[c] = 1;
    }
    model.volumeInfo = {
      scale,
      offset,
      width,
      height,
      depth
    };
    var _computeScaleOffsets = computeScaleOffsets(numComps, numPixelsIn, data), computedOffset = _computeScaleOffsets.offset, computedScale = _computeScaleOffsets.scale;
    model.volumeInfo.dataComputedScale = computedScale;
    model.volumeInfo.dataComputedOffset = computedOffset;
    var useHalfFloat = checkUseHalfFloat(dataType, computedOffset, computedScale, preferSizeOverAccuracy);
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes3.FLOAT || useHalfFloat && (dataType === VtkDataTypes3.SHORT || dataType === VtkDataTypes3.UNSIGNED_SHORT)) {
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      if (dataType === VtkDataTypes3.UNSIGNED_CHAR) {
        for (var _c3 = 0; _c3 < numComps; ++_c3) {
          model.volumeInfo.scale[_c3] = 255;
        }
        return publicAPI.create3DFromRaw(width, height, depth, numComps, dataType, data);
      }
      var _newArray3 = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = computedOffset;
      model.volumeInfo.scale = computedScale;
      var count = 0;
      var scaleInverse = computedScale.map(function(s) {
        return 1 / s;
      });
      for (var i = 0; i < numPixelsIn; i++) {
        for (var nc = 0; nc < numComps; nc++) {
          _newArray3[count] = (data[count] - computedOffset[nc]) * scaleInverse[nc];
          count++;
        }
      }
      return publicAPI.create3DFromRaw(width, height, depth, numComps, VtkDataTypes3.FLOAT, _newArray3);
    }
    var res = computeScaleOffsets(numComps, numPixelsIn, data);
    var volCopyData = function volCopyData2(outArray, outIdx2, inValue, smin, smax) {
      outArray[outIdx2] = inValue;
    };
    var dataTypeToUse = VtkDataTypes3.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes3.UNSIGNED_CHAR) {
      for (var _c4 = 0; _c4 < numComps; ++_c4) {
        res.offset[_c4] = 0;
        res.scale[_c4] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes3.FLOAT;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes3.UNSIGNED_CHAR;
      volCopyData = function volCopyData2(outArray, outIdx2, inValue, soffset, sscale) {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro11("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    var maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes3.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    var xstride = 1;
    var ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    var targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    var xreps = Math.floor(targetWidth * xstride / width);
    var yreps = Math.ceil(depth / xreps);
    var targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = res.offset;
    model.volumeInfo.scale = res.scale;
    var newArray;
    var pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes3.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    var outIdx = 0;
    var tileWidth = Math.floor(width / xstride);
    var tileHeight = Math.floor(height / ystride);
    for (var yRep = 0; yRep < yreps; yRep++) {
      var xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      var outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (var tileY = 0; tileY < tileHeight; tileY++) {
        for (var xRep = 0; xRep < xrepsThisRow; xRep++) {
          var inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (var tileX = 0; tileX < tileWidth; tileX++) {
            for (var _nc = 0; _nc < numComps; _nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + _nc], res.offset[_nc], res.scale[_nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = function(ctx) {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
}
function extend22(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target"]);
  vtkOpenGLTexture(publicAPI, model);
}
var Wrap2, Filter2, VtkDataTypes3, vtkDebugMacro6, vtkErrorMacro11, vtkWarningMacro4, DEFAULT_VALUES22, newInstance24, vtkOpenGLTexture$1;
var init_Texture = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js"() {
    init_defineProperty();
    init_Constants10();
    init_HalfFloat();
    init_macros();
    init_DataArray();
    init_Math();
    init_ViewNode();
    init_ViewNodeFactory2();
    Wrap2 = Constants8.Wrap;
    Filter2 = Constants8.Filter;
    VtkDataTypes3 = vtkDataArray$1.VtkDataTypes;
    vtkDebugMacro6 = vtkDebugMacro;
    vtkErrorMacro11 = vtkErrorMacro;
    vtkWarningMacro4 = vtkWarningMacro;
    DEFAULT_VALUES22 = {
      _openGLRenderWindow: null,
      context: null,
      handle: 0,
      sendParametersTime: null,
      textureBuildTime: null,
      numberOfDimensions: 0,
      target: 0,
      format: 0,
      openGLDataType: 0,
      components: 0,
      width: 0,
      height: 0,
      depth: 0,
      autoParameters: true,
      wrapS: Wrap2.CLAMP_TO_EDGE,
      wrapT: Wrap2.CLAMP_TO_EDGE,
      wrapR: Wrap2.CLAMP_TO_EDGE,
      minificationFilter: Filter2.NEAREST,
      magnificationFilter: Filter2.NEAREST,
      minLOD: -1e3,
      maxLOD: 1e3,
      baseLevel: 0,
      maxLevel: 1e3,
      generateMipmap: false
    };
    newInstance24 = newInstance(extend22, "vtkOpenGLTexture");
    vtkOpenGLTexture$1 = _objectSpread10({
      newInstance: newInstance24,
      extend: extend22
    }, Constants8);
    registerOverride("vtkTexture", newInstance24);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js
var InterpolationType3;
var init_Constants11 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/ImageProperty/Constants.js"() {
    InterpolationType3 = {
      NEAREST: 0,
      LINEAR: 1
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS;
var init_vtkPolyDataVS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js"() {
    vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS;
var init_vtkPolyDataFS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js"() {
    vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = function(shaders, ren, actor) {
    var cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      var FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
var vtkReplacementShaderMapper;
var init_ReplacementShaderMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js"() {
    init_ShaderProgram();
    vtkReplacementShaderMapper = {
      implementReplaceShaderCoincidentOffset
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js
var ImageMapper_exports = {};
__export(ImageMapper_exports, {
  default: () => vtkImageMapper,
  extend: () => extend23,
  newInstance: () => newInstance25
});
function computeFnToString(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
function vtkOpenGLImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType("vtkOpenGLImageSlice");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.pwfTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getCoincidentParameters = function(ren, actor) {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };
  publicAPI.render = function() {
    var actor = model.openGLImageSlice.getRenderable();
    var ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
    var tNumComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var tcoordDec = [
      "varying vec2 tcoordVCVSOutput;",
      "uniform float cshift0;",
      "uniform float cscale0;",
      "uniform float pwfshift0;",
      "uniform float pwfscale0;",
      "uniform sampler2D texture1;",
      "uniform sampler2D colorTexture1;",
      "uniform sampler2D pwfTexture1;",
      "uniform float opacity;"
    ];
    if (iComps) {
      for (var comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          "uniform float cshift".concat(comp, ";"),
          "uniform float cscale".concat(comp, ";"),
          "uniform float pwfshift".concat(comp, ";"),
          "uniform float pwfscale".concat(comp, ";")
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "#define height0 0.5"]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "#define height0 0.25", "#define height1 0.75"]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "#define height0 0.17", "#define height1 0.5", "#define height2 0.83"]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat(["uniform float mix0;", "uniform float mix1;", "uniform float mix2;", "uniform float mix3;", "#define height0 0.125", "#define height1 0.375", "#define height2 0.625", "#define height3 0.875"]);
          break;
        default:
          vtkErrorMacro12("Unsupported number of independent coordinates.");
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", tcoordDec).result;
    if (iComps) {
      var rgba = ["r", "g", "b", "a"];
      var tcoordImpl = ["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];
      for (var _comp = 0; _comp < tNumComp; _comp++) {
        tcoordImpl = tcoordImpl.concat(["vec3 tcolor".concat(_comp, " = mix").concat(_comp, " * texture2D(colorTexture1, vec2(tvalue.").concat(rgba[_comp], " * cscale").concat(_comp, " + cshift").concat(_comp, ", height").concat(_comp, ")).rgb;"), "float compWeight".concat(_comp, " = mix").concat(_comp, " * texture2D(pwfTexture1, vec2(tvalue.").concat(rgba[_comp], " * pwfscale").concat(_comp, " + pwfshift").concat(_comp, ", height").concat(_comp, ")).r;")]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;", "gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);
          break;
        default:
          vtkErrorMacro12("Unsupported number of independent coordinates.");
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", tcoordImpl).result;
    } else {
      switch (tNumComp) {
        case 1:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["float intensity = texture2D(texture1, tcoordVCVSOutput).r;", "vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;", "float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;", "gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]).result;
          break;
        case 2:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "float intensity = tcolor.r*cscale0 + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;
          break;
        default:
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;", "gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,", "  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result;
      }
    }
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };
  publicAPI.replaceShaderClip = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[6];", "varying float clipDistancesVSOutput[6];"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[6];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < 6; planeNum++)", "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var tNumComp = model.openGLTexture.getComponents();
    var iComp = actor.getProperty().getIndependentComponents();
    var needRebuild = false;
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {
      needRebuild = true;
      model.lastRenderPassShaderReplacement = null;
    }
    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();
      needRebuild = true;
    }
    if (needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || model.lastTextureComponents !== tNumComp || model.lastIndependentComponents !== iComp) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro12("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), model.context.FALSE)) {
          vtkErrorMacro12("Error setting tcoordMC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    var texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("texture1", texUnit);
    var numComp = model.openGLTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (var i = 0; i < numComp; i++) {
        cellBO.getProgram().setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    var oglShiftScale = model.openGLTexture.getShiftAndScale();
    for (var _i = 0; _i < numComp; _i++) {
      var cw = actor.getProperty().getColorWindow();
      var cl = actor.getProperty().getColorLevel();
      var target = iComps ? _i : 0;
      var cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
        var cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }
      var scale = oglShiftScale.scale / cw;
      var shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf("cshift".concat(_i), shift);
      cellBO.getProgram().setUniformf("cscale".concat(_i), scale);
    }
    for (var _i2 = 0; _i2 < numComp; _i2++) {
      var pwfScale = 1;
      var pwfShift = 0;
      var _target = iComps ? _i2 : 0;
      var pwfun = actor.getProperty().getPiecewiseFunction(_target);
      if (pwfun) {
        var pwfRange = pwfun.getRange();
        var length = pwfRange[1] - pwfRange[0];
        var mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf("pwfshift".concat(_i2), pwfShift);
      cellBO.getProgram().setUniformf("pwfscale".concat(_i2), pwfScale);
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      var cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    var texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("colorTexture1", texColorUnit);
    var texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi("pwfTexture1", texOpacityUnit);
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtkErrorMacro("OpenGL has a limit of 6 clipping planes");
        numClipPlanes = 6;
      }
      var image = model.currentInput;
      var w2imat4 = image.getWorldToIndex();
      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      var mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.imagematinv, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      mat4_exports.multiply(model.imagematinv, mat, w2imat4);
      var planeEquations = [];
      for (var _i3 = 0; _i3 < numClipPlanes; _i3++) {
        var planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(model.imagematinv, _i3, planeEquation);
        for (var j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var actMats = model.openGLImageSlice.getKeyMatrices();
    var image = model.currentInput;
    var i2wmat4 = image.getIndexToWorld();
    mat4_exports.multiply(model.imagemat, actMats.mcwc, i2wmat4);
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    mat4_exports.multiply(model.imagemat, keyMats.wcpc, model.imagemat);
    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      var inverseShiftScaleMat = cellBO.getCABO().getInverseShiftAndScaleMatrix();
      mat4_exports.multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }
    program.setUniformMatrix("MCPCMatrix", model.imagemat);
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var ppty = actor.getProperty();
    var opacity = ppty.getOpacity();
    program.setUniformf("opacity", opacity);
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();
    if (model.tris.getCABO().getElementCount()) {
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }
    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro12("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var imgScalars = image.getPointData() && image.getPointData().getScalars();
    if (!imgScalars) {
      return;
    }
    var actorProperty = actor.getProperty();
    var iType = actorProperty.getInterpolationType();
    if (iType === InterpolationType3.NEAREST) {
      model.colorTexture.setMinificationFilter(Filter.NEAREST);
      model.colorTexture.setMagnificationFilter(Filter.NEAREST);
      model.pwfTexture.setMinificationFilter(Filter.NEAREST);
      model.pwfTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.pwfTexture.setMinificationFilter(Filter.LINEAR);
      model.pwfTexture.setMagnificationFilter(Filter.LINEAR);
    }
    var numComp = imgScalars.getNumberOfComponents();
    var iComps = actorProperty.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var textureHeight = iComps ? 2 * numIComps : 1;
    var cfunToString = computeFnToString(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      var cWidth = 1024;
      var cSize = cWidth * textureHeight * 3;
      var cTable = new Uint8Array(cSize);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(cWidth * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (var i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255 * tmpTable[i];
            }
          } else {
            for (var _i4 = 0; _i4 < cWidth * 3; _i4++) {
              cTable[c * cWidth * 6 + _i4] = 255 * tmpTable[_i4];
            }
          }
        }
        model.colorTexture.create2DFromRaw(cWidth, textureHeight, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      } else {
        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {
          cTable[_i5] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 1] = 255 * _i5 / ((cWidth - 1) * 3);
          cTable[_i5 + 2] = 255 * _i5 / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(cWidth, 1, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      }
      model.colorTextureString = cfunToString;
    }
    var pwfunToString = computeFnToString(actorProperty, actorProperty.getPiecewiseFunction, numIComps);
    if (model.pwfTextureString !== pwfunToString) {
      var pwfWidth = 1024;
      var pwfSize = pwfWidth * textureHeight;
      var pwfTable = new Uint8Array(pwfSize);
      var pwfun = actorProperty.getPiecewiseFunction();
      model.pwfTexture.resetFormatAndType();
      if (pwfun) {
        var pwfFloatTable = new Float32Array(pwfSize);
        var _tmpTable = new Float32Array(pwfWidth);
        for (var _c = 0; _c < numIComps; ++_c) {
          pwfun = actorProperty.getPiecewiseFunction(_c);
          if (pwfun === null) {
            pwfFloatTable.fill(1);
          } else {
            var pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, _tmpTable, 1);
            if (iComps) {
              for (var _i6 = 0; _i6 < pwfWidth; _i6++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i6] = _tmpTable[_i6];
                pwfFloatTable[_c * pwfWidth * 2 + _i6 + pwfWidth] = _tmpTable[_i6];
              }
            } else {
              for (var _i7 = 0; _i7 < pwfWidth; _i7++) {
                pwfFloatTable[_c * pwfWidth * 2 + _i7] = _tmpTable[_i7];
              }
            }
          }
        }
        model.pwfTexture.create2DFromRaw(pwfWidth, textureHeight, 1, VtkDataTypes.FLOAT, pwfFloatTable);
      } else {
        pwfTable.fill(255);
        model.pwfTexture.create2DFromRaw(pwfWidth, 1, 1, VtkDataTypes.UNSIGNED_CHAR, pwfTable);
      }
      model.pwfTextureString = pwfunToString;
    }
    var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
    var slice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      slice = model.renderable.getSliceAtPosition(slice);
    }
    var nSlice = Math.round(slice);
    var ext = image.getExtent();
    var sliceOffset;
    if (ijkMode === SlicingMode2.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode2.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
      sliceOffset = nSlice - ext[4];
    }
    var toString = "".concat(slice, "A").concat(image.getMTime(), "A").concat(imgScalars.getMTime(), "B").concat(publicAPI.getMTime(), "C").concat(model.renderable.getSlicingMode(), "D").concat(actor.getProperty().getMTime());
    if (model.VBOBuildString !== toString) {
      var dims = image.getDimensions();
      if (iType === InterpolationType3.NEAREST) {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(Filter.NEAREST);
      } else {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        } else {
          model.openGLTexture.setMinificationFilter(Filter.LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(Filter.LINEAR);
      }
      model.openGLTexture.setWrapS(Wrap.CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(Wrap.CLAMP_TO_EDGE);
      var sliceSize = dims[0] * dims[1] * numComp;
      var ptsArray = new Float32Array(12);
      var tcoordArray = new Float32Array(8);
      for (var _i8 = 0; _i8 < 4; _i8++) {
        tcoordArray[_i8 * 2] = _i8 % 2 ? 1 : 0;
        tcoordArray[_i8 * 2 + 1] = _i8 > 1 ? 1 : 0;
      }
      var sliceDepth = [SlicingMode2.X, SlicingMode2.Y, SlicingMode2.Z].includes(model.renderable.getSlicingMode()) ? slice : nSlice;
      var spatialExt = image.getSpatialExtent();
      var basicScalars = imgScalars.getData();
      var scalars = null;
      if (ijkMode === SlicingMode2.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        var id = 0;
        for (var k = 0; k < dims[2]; k++) {
          for (var j = 0; j < dims[1]; j++) {
            var bsIdx = (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = sliceDepth;
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = sliceDepth;
        ptsArray[4] = spatialExt[3];
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = sliceDepth;
        ptsArray[7] = spatialExt[2];
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = sliceDepth;
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        var _id = 0;
        for (var _k = 0; _k < dims[2]; _k++) {
          for (var _i9 = 0; _i9 < dims[0]; _i9++) {
            var _bsIdx = (_i9 + sliceOffset * dims[0] + _k * dims[0] * dims[1]) * numComp;
            _id = (_k * dims[0] + _i9) * numComp;
            scalars.set(basicScalars.subarray(_bsIdx, _bsIdx + numComp), _id);
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = sliceDepth;
        ptsArray[2] = spatialExt[4];
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = sliceDepth;
        ptsArray[5] = spatialExt[4];
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = sliceDepth;
        ptsArray[8] = spatialExt[5];
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = sliceDepth;
        ptsArray[11] = spatialExt[5];
      } else if (ijkMode === SlicingMode2.K || ijkMode === SlicingMode2.NONE) {
        scalars = basicScalars.subarray(sliceOffset * sliceSize, (sliceOffset + 1) * sliceSize);
        ptsArray[0] = spatialExt[0];
        ptsArray[1] = spatialExt[2];
        ptsArray[2] = sliceDepth;
        ptsArray[3] = spatialExt[1];
        ptsArray[4] = spatialExt[2];
        ptsArray[5] = sliceDepth;
        ptsArray[6] = spatialExt[0];
        ptsArray[7] = spatialExt[3];
        ptsArray[8] = sliceDepth;
        ptsArray[9] = spatialExt[1];
        ptsArray[10] = spatialExt[3];
        ptsArray[11] = sliceDepth;
      } else {
        vtkErrorMacro12("Reformat slicing not yet supported.");
      }
      model.openGLTexture.create2DFromRaw(dims[0], dims[1], numComp, imgScalars.getDataType(), scalars);
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var tcoords = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: tcoordArray
      });
      tcoords.setName("tcoords");
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        tcoords,
        cellOffset: 0
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
}
function extend23(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  model.tris = vtkHelper.newInstance();
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.pwfTexture = vtkOpenGLTexture$1.newInstance();
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  setGet(publicAPI, model, []);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkOpenGLImageMapper(publicAPI, model);
}
var vtkErrorMacro12, SlicingMode2, DEFAULT_VALUES23, newInstance25, vtkImageMapper;
var init_ImageMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageMapper.js"() {
    init_esm();
    init_Constants7();
    init_macros();
    init_DataArray();
    init_Constants2();
    init_Helper();
    init_Math();
    init_Texture();
    init_ShaderProgram();
    init_ViewNode();
    init_Constants9();
    init_Constants10();
    init_Constants11();
    init_vtkPolyDataVS_glsl();
    init_vtkPolyDataFS_glsl();
    init_ReplacementShaderMapper();
    init_ViewNodeFactory2();
    vtkErrorMacro12 = vtkErrorMacro;
    SlicingMode2 = Constants6.SlicingMode;
    DEFAULT_VALUES23 = {
      VBOBuildTime: 0,
      VBOBuildString: null,
      openGLTexture: null,
      tris: null,
      imagemat: null,
      imagematinv: null,
      colorTexture: null,
      pwfTexture: null,
      lastHaveSeenDepthRequest: false,
      haveSeenDepthRequest: false,
      lastTextureComponents: 0
    };
    newInstance25 = newInstance(extend23, "vtkOpenGLImageMapper");
    vtkImageMapper = {
      newInstance: newInstance25,
      extend: extend23
    };
    registerOverride("vtkImageMapper", newInstance25);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js
var ImageSlice_exports = {};
__export(ImageSlice_exports, {
  default: () => vtkImageSlice,
  extend: () => extend24,
  newInstance: () => newInstance26
});
function vtkOpenGLImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaqueZBufferPass = function(renderPass) {
    publicAPI.traverseOpaquePass(renderPass);
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    return publicAPI.opaquePass(prepass, renderPass);
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
function extend24(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLImageSlice(publicAPI, model);
}
var DEFAULT_VALUES24, newInstance26, vtkImageSlice;
var init_ImageSlice = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ImageSlice.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    DEFAULT_VALUES24 = {
      context: null,
      keyMatrixTime: null,
      keyMatrices: null
    };
    newInstance26 = newInstance(extend24, "vtkOpenGLImageSlice");
    vtkImageSlice = {
      newInstance: newInstance26,
      extend: extend24
    };
    registerOverride("vtkImageSlice", newInstance26);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js
var Volume_exports2 = {};
__export(Volume_exports2, {
  default: () => vtkVolume2,
  extend: () => extend25,
  newInstance: () => newInstance27
});
function vtkOpenGLVolume(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };
  publicAPI.traverseVolumePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.volumePass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    model.context.depthMask(!prepass);
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.MCWCMatrix, model.renderable.getMatrix());
      mat4_exports.transpose(model.MCWCMatrix, model.MCWCMatrix);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.normalMatrix, model.MCWCMatrix);
        mat3_exports.invert(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
}
function extend25(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16);
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolume(publicAPI, model);
}
var DEFAULT_VALUES25, newInstance27, vtkVolume2;
var init_Volume2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Volume.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    DEFAULT_VALUES25 = {};
    newInstance27 = newInstance(extend25, "vtkOpenGLVolume");
    vtkVolume2 = {
      newInstance: newInstance27,
      extend: extend25
    };
    registerOverride("vtkVolume", newInstance27);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js
function vtkFramebuffer(publicAPI, model) {
  model.classHierarchy.push("vtkFramebuffer");
  publicAPI.getBothMode = function() {
    return model.context.FRAMEBUFFER;
  };
  publicAPI.saveCurrentBindingsAndBuffers = function(modeIn) {
    var mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };
  publicAPI.saveCurrentBindings = function(modeIn) {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling saveCurrentBindings");
      return;
    }
    var gl = model.context;
    model.previousDrawBinding = gl.getParameter(model.context.FRAMEBUFFER_BINDING);
    model.previousActiveFramebuffer = model._openGLRenderWindow.getActiveFramebuffer();
  };
  publicAPI.saveCurrentBuffers = function(modeIn) {
  };
  publicAPI.restorePreviousBindingsAndBuffers = function(modeIn) {
    var mode = typeof modeIn !== "undefined" ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };
  publicAPI.restorePreviousBindings = function(modeIn) {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling restorePreviousBindings");
      return;
    }
    var gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model._openGLRenderWindow.setActiveFramebuffer(model.previousActiveFramebuffer);
  };
  publicAPI.restorePreviousBuffers = function(modeIn) {
  };
  publicAPI.bind = function() {
    var modeArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var mode = modeArg;
    if (mode === null) {
      mode = model.context.FRAMEBUFFER;
    }
    model.context.bindFramebuffer(mode, model.glFramebuffer);
    for (var i = 0; i < model.colorBuffers.length; i++) {
      model.colorBuffers[i].bind();
    }
    model._openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };
  publicAPI.create = function(width, height) {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling create");
      return;
    }
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };
  publicAPI.setColorBuffer = function(texture) {
    var attachment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var gl = model.context;
    if (!gl) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling setColorBuffer");
      return;
    }
    var glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    model.colorBuffers[attachment] = texture;
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, texture.getHandle(), 0);
  };
  publicAPI.removeColorBuffer = function() {
    var attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var gl = model.context;
    if (!gl) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling removeColorBuffer");
      return;
    }
    var glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model._openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtkErrorMacro("Using multiple framebuffer attachments requires WebGL 2");
        return;
      }
    }
    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, gl.TEXTURE_2D, null, 0);
    model.colorBuffers = model.colorBuffers.splice(attachment, 1);
  };
  publicAPI.setDepthBuffer = function(texture) {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling setDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      var gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, texture.getHandle(), 0);
    } else {
      vtkErrorMacro("Attaching depth buffer textures to fbo requires WebGL 2");
    }
  };
  publicAPI.removeDepthBuffer = function() {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling removeDepthBuffer");
      return;
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      var gl = model.context;
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, null, 0);
    } else {
      vtkErrorMacro("Attaching depth buffer textures to framebuffers requires WebGL 2");
    }
  };
  publicAPI.getGLFramebuffer = function() {
    return model.glFramebuffer;
  };
  publicAPI.setOpenGLRenderWindow = function(rw) {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
  };
  publicAPI.getSize = function() {
    var size = [0, 0];
    if (model.glFramebuffer !== null) {
      size[0] = model.glFramebuffer.width;
      size[1] = model.glFramebuffer.height;
    }
    return size;
  };
  publicAPI.populateFramebuffer = function() {
    if (!model.context) {
      vtkErrorMacro("you must set the OpenGLRenderWindow before calling populateFrameBuffer");
      return;
    }
    publicAPI.bind();
    var gl = model.context;
    var texture = vtkOpenGLTexture$1.newInstance();
    texture.setOpenGLRenderWindow(model._openGLRenderWindow);
    texture.setMinificationFilter(Filter.LINEAR);
    texture.setMagnificationFilter(Filter.LINEAR);
    texture.create2DFromRaw(model.glFramebuffer.width, model.glFramebuffer.height, 4, VtkDataTypes.UNSIGNED_CHAR, null);
    publicAPI.setColorBuffer(texture);
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, model.glFramebuffer.width, model.glFramebuffer.height);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, model.depthTexture);
  };
  publicAPI.getColorTexture = function() {
    return model.colorBuffers[0];
  };
}
function extend26(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  obj(publicAPI, model);
  if (model.colorBuffers) {
    vtkErrorMacro("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead.");
  }
  model.colorBuffers = [];
  getArray(publicAPI, model, ["colorBuffers"]);
  vtkFramebuffer(publicAPI, model);
}
var DEFAULT_VALUES26, newInstance28, vtkOpenGLFramebuffer;
var init_Framebuffer = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Framebuffer.js"() {
    init_macros();
    init_Texture();
    init_Constants2();
    init_Constants10();
    DEFAULT_VALUES26 = {
      glFramebuffer: null,
      colorBuffers: null,
      depthTexture: null,
      previousDrawBinding: 0,
      previousReadBinding: 0,
      previousDrawBuffer: 0,
      previousReadBuffer: 0,
      previousActiveFramebuffer: null
    };
    newInstance28 = newInstance(extend26, "vtkFramebuffer");
    vtkOpenGLFramebuffer = {
      newInstance: newInstance28,
      extend: extend26
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js
var vtkVolumeVS;
var init_vtkVolumeVS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeVS.glsl.js"() {
    vtkVolumeVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n";
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js
var vtkVolumeFS;
var init_vtkVolumeFS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkVolumeFS.glsl.js"() {
    vtkVolumeFS = `//VTK::System::Dec

/*=========================================================================

  Program:   Visualization Toolkit
  Module:    vtkVolumeFS.glsl

  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/
// Template for the volume mappers fragment shader

// the output of this shader
//VTK::Output::Dec

varying vec3 vertexVCVSOutput;

// first declare the settings from the mapper
// that impact the code paths in here

// always set vtkNumComponents 1,2,3,4
//VTK::NumComponents

// possibly define vtkTrilinearOn
//VTK::TrilinearOn

// possibly define vtkIndependentComponents
//VTK::IndependentComponentsOn

// possibly define any "proportional" components
//VTK::vtkProportionalComponents

// Define the blend mode to use
#define vtkBlendMode //VTK::BlendMode

// Possibly define vtkImageLabelOutlineOn
//VTK::ImageLabelOutlineOn

#ifdef vtkImageLabelOutlineOn
uniform int outlineThickness;
uniform float vpWidth;
uniform float vpHeight;
uniform float vpOffsetX;
uniform float vpOffsetY;
uniform mat4 PCWCMatrix;
uniform mat4 vWCtoIDX;
#endif

// define vtkLightComplexity
//VTK::LightComplexity
#if vtkLightComplexity > 0
uniform float vSpecularPower;
uniform float vAmbient;
uniform float vDiffuse;
uniform float vSpecular;
//VTK::Light::Dec
#endif

// possibly define vtkGradientOpacityOn
//VTK::GradientOpacityOn
#ifdef vtkGradientOpacityOn
uniform float goscale0;
uniform float goshift0;
uniform float gomin0;
uniform float gomax0;
#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
uniform float goscale1;
uniform float goshift1;
uniform float gomin1;
uniform float gomax1;
#if vtkNumComponents >= 3
uniform float goscale2;
uniform float goshift2;
uniform float gomin2;
uniform float gomax2;
#endif
#if vtkNumComponents >= 4
uniform float goscale3;
uniform float goshift3;
uniform float gomin3;
uniform float gomax3;
#endif
#endif
#endif

// if you want to see the raw tiled
// data in webgl1 uncomment the following line
// #define debugtile

// camera values
uniform float camThick;
uniform float camNear;
uniform float camFar;
uniform int cameraParallel;

// values describing the volume geometry
uniform vec3 vOriginVC;
uniform vec3 vSpacing;
uniform ivec3 volumeDimensions; // 3d texture dimensions
uniform vec3 vPlaneNormal0;
uniform float vPlaneDistance0;
uniform vec3 vPlaneNormal1;
uniform float vPlaneDistance1;
uniform vec3 vPlaneNormal2;
uniform float vPlaneDistance2;
uniform vec3 vPlaneNormal3;
uniform float vPlaneDistance3;
uniform vec3 vPlaneNormal4;
uniform float vPlaneDistance4;
uniform vec3 vPlaneNormal5;
uniform float vPlaneDistance5;

//VTK::ClipPlane::Dec

// opacity and color textures
uniform sampler2D otexture;
uniform float oshift0;
uniform float oscale0;
uniform sampler2D ctexture;
uniform float cshift0;
uniform float cscale0;

// jitter texture
uniform sampler2D jtexture;

// some 3D texture values
uniform float sampleDistance;
uniform vec3 vVCToIJK;

// the heights defined below are the locations
// for the up to four components of the tfuns
// the tfuns have a height of 2XnumComps pixels so the
// values are computed to hit the middle of the two rows
// for that component
#ifdef vtkIndependentComponentsOn
#if vtkNumComponents == 2
uniform float mix0;
uniform float mix1;
#define height0 0.25
#define height1 0.75
#endif
#if vtkNumComponents == 3
uniform float mix0;
uniform float mix1;
uniform float mix2;
#define height0 0.17
#define height1 0.5
#define height2 0.83
#endif
#if vtkNumComponents == 4
uniform float mix0;
uniform float mix1;
uniform float mix2;
uniform float mix3;
#define height0 0.125
#define height1 0.375
#define height2 0.625
#define height3 0.875
#endif
#endif

#if vtkNumComponents >= 2
uniform float oshift1;
uniform float oscale1;
uniform float cshift1;
uniform float cscale1;
#endif
#if vtkNumComponents >= 3
uniform float oshift2;
uniform float oscale2;
uniform float cshift2;
uniform float cscale2;
#endif
#if vtkNumComponents >= 4
uniform float oshift3;
uniform float oscale3;
uniform float cshift3;
uniform float cscale3;
#endif

uniform vec4 ipScalarRangeMin;
uniform vec4 ipScalarRangeMax;

// declaration for intermixed geometry
//VTK::ZBuffer::Dec

// Lighting values
//VTK::Light::Dec

//=======================================================================
// Webgl2 specific version of functions
#if __VERSION__ == 300

uniform highp sampler3D texture1;

vec4 getTextureValue(vec3 pos)
{
  vec4 tmp = texture(texture1, pos);
#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.a = tmp.g;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
  return tmp;
}

//=======================================================================
// WebGL1 specific version of functions
#else

uniform sampler2D texture1;

uniform float texWidth;
uniform float texHeight;
uniform int xreps;
uniform int xstride;
uniform int ystride;

// if computing trilinear values from multiple z slices
#ifdef vtkTrilinearOn
vec4 getTextureValue(vec3 ijk)
{
  float zoff = 1.0/float(volumeDimensions.z);
  vec4 val1 = getOneTextureValue(ijk);
  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));

  float indexZ = float(volumeDimensions)*ijk.z;
  float zmix =  indexZ - floor(indexZ);

  return mix(val1, val2, zmix);
}

vec4 getOneTextureValue(vec3 ijk)
#else // nearest or fast linear
vec4 getTextureValue(vec3 ijk)
#endif
{
  vec3 tdims = vec3(volumeDimensions);

#ifdef debugtile
  vec2 tpos = vec2(ijk.x, ijk.y);
  vec4 tmp = texture2D(texture1, tpos);
  tmp.a = 1.0;

#else
  int z = int(ijk.z * tdims.z);
  int yz = z / xreps;
  int xz = z - yz*xreps;

  int tileWidth = volumeDimensions.x/xstride;
  int tileHeight = volumeDimensions.y/ystride;

  xz *= tileWidth;
  yz *= tileHeight;

  float ni = float(xz) + (ijk.x*float(tileWidth));
  float nj = float(yz) + (ijk.y*float(tileHeight));

  vec2 tpos = vec2(ni/texWidth, nj/texHeight);

  vec4 tmp = texture2D(texture1, tpos);

#if vtkNumComponents == 1
  tmp.a = tmp.r;
#endif
#if vtkNumComponents == 2
  tmp.g = tmp.a;
#endif
#if vtkNumComponents == 3
  tmp.a = length(tmp.rgb);
#endif
#endif

  return tmp;
}

// End of Webgl1 specific code
//=======================================================================
#endif

//=======================================================================
// compute the normal and gradient magnitude for a position
vec4 computeNormal(vec3 pos, float scalar, vec3 tstep)
{
  vec4 result;

  result.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a - scalar;
  result.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a - scalar;
  result.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a - scalar;

  // divide by spacing
  result.xyz /= vSpacing;

  result.w = length(result.xyz);

  // rotate to View Coords
  result.xyz =
    result.x * vPlaneNormal0 +
    result.y * vPlaneNormal2 +
    result.z * vPlaneNormal4;

  if (result.w > 0.0)
  {
    result.xyz /= result.w;
  }
  return result;
}

#ifdef vtkImageLabelOutlineOn
vec3 fragCoordToIndexSpace(vec4 fragCoord) {
  vec4 pcPos = vec4(
    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,
    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,
    (fragCoord.z - 0.5) * 2.0,
    1.0);

  vec4 worldCoord = PCWCMatrix * pcPos;
  vec4 vertex = (worldCoord/worldCoord.w);

  vec3 index = (vWCtoIDX * vertex).xyz;

  // half voxel fix for labelmapOutline 
  return (index + vec3(0.5)) / vec3(volumeDimensions);
}
#endif

//=======================================================================
// compute the normals and gradient magnitudes for a position
// for independent components
mat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)
{
  mat4 result;
  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;
  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;
  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;

  // divide by spacing
  distX /= vSpacing.x;
  distY /= vSpacing.y;
  distZ /= vSpacing.z;

  mat3 rot;
  rot[0] = vPlaneNormal0;
  rot[1] = vPlaneNormal2;
  rot[2] = vPlaneNormal4;

#if !defined(vtkComponent0Proportional)
  result[0].xyz = vec3(distX.r, distY.r, distZ.r);
  result[0].a = length(result[0].xyz);
  result[0].xyz *= rot;
  if (result[0].w > 0.0)
  {
    result[0].xyz /= result[0].w;
  }
#endif

// optionally compute the 2nd component
#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)
  result[1].xyz = vec3(distX.g, distY.g, distZ.g);
  result[1].a = length(result[1].xyz);
  result[1].xyz *= rot;
  if (result[1].w > 0.0)
  {
    result[1].xyz /= result[1].w;
  }
#endif

// optionally compute the 3rd component
#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)
  result[2].xyz = vec3(distX.b, distY.b, distZ.b);
  result[2].a = length(result[2].xyz);
  result[2].xyz *= rot;
  if (result[2].w > 0.0)
  {
    result[2].xyz /= result[2].w;
  }
#endif

// optionally compute the 4th component
#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)
  result[3].xyz = vec3(distX.a, distY.a, distZ.a);
  result[3].a = length(result[3].xyz);
  result[3].xyz *= rot;
  if (result[3].w > 0.0)
  {
    result[3].xyz /= result[3].w;
  }
#endif

  return result;
}

//=======================================================================
// Given a normal compute the gradient opacity factors
//
float computeGradientOpacityFactor(
  vec4 normal, float goscale, float goshift, float gomin, float gomax)
{
#if defined(vtkGradientOpacityOn)
  return clamp(normal.a*goscale + goshift, gomin, gomax);
#else
  return 1.0;
#endif
}

#if vtkLightComplexity > 0
void applyLighting(inout vec3 tColor, vec4 normal)
{
  vec3 diffuse = vec3(0.0, 0.0, 0.0);
  vec3 specular = vec3(0.0, 0.0, 0.0);
  //VTK::Light::Impl
  tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;
}
#endif

//=======================================================================
// Given a texture value compute the color and opacity
//
vec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)
{
#ifdef vtkImageLabelOutlineOn
  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space
  vec4 centerValue = getTextureValue(centerPosIS);
  bool pixelOnBorder = false;
  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));

  // Get alpha of segment from opacity function.
  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;

  // Only perform outline check on fragments rendering voxels that aren't invisible.
  // Saves a bunch of needless checks on the background.
  // TODO define epsilon when building shader?
  if (float(tColor.a) > 0.01) {
    for (int i = -outlineThickness; i <= outlineThickness; i++) {
      for (int j = -outlineThickness; j <= outlineThickness; j++) {
        if (i == 0 || j == 0) {
          continue;
        }

        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),
          gl_FragCoord.y + float(j),
          gl_FragCoord.z, gl_FragCoord.w);

        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);
        vec4 value = getTextureValue(neighborPosIS);

        // If any of my neighbours are not the same value as I
        // am, this means I am on the border of the segment.
        // We can break the loops
        if (any(notEqual(value, centerValue))) {
          pixelOnBorder = true;
          break;
        }
      }

      if (pixelOnBorder == true) {
        break;
      }
    }

    // If I am on the border, I am displayed at full opacity
    if (pixelOnBorder == true) {
      tColor.a = 1.0;
    }
  }

#else
  // compute the normal and gradient magnitude if needed
  // We compute it as a vec4 if possible otherwise a mat4
  //
  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);

  // compute the normal vectors as needed
  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);
      #if !defined(vtkComponent0Proportional)
        vec4 normal0 = normalMat[0];
      #endif
      #if !defined(vtkComponent1Proportional)
        vec4 normal1 = normalMat[1];
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          vec4 normal2 = normalMat[2];
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            vec4 normal3 = normalMat[3];
          #endif
        #endif
      #endif
    #else
      vec4 normal0 = computeNormal(posIS, tValue.a, tstep);
    #endif
  #endif

  // compute gradient opacity factors as needed
  #if defined(vtkGradientOpacityOn)
    #if !defined(vtkComponent0Proportional)
      goFactor.x =
        computeGradientOpacityFactor(normal0, goscale0, goshift0, gomin0, gomax0);
    #endif
    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)
      #if !defined(vtkComponent1Proportional)
        goFactor.y =
          computeGradientOpacityFactor(normal1, goscale1, goshift1, gomin1, gomax1);
      #endif
      #if vtkNumComponents > 2
        #if !defined(vtkComponent2Proportional)
          goFactor.z =
            computeGradientOpacityFactor(normal2, goscale2, goshift2, gomin2, gomax2);
        #endif
        #if vtkNumComponents > 3
          #if !defined(vtkComponent3Proportional)
            goFactor.w =
              computeGradientOpacityFactor(normal3, goscale3, goshift3, gomin3, gomax3);
          #endif
        #endif
      #endif
    #endif
  #endif

  // single component is always independent
  #if vtkNumComponents == 1
    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;
  #endif

  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));
    #if !defined(vtkComponent0Proportional)
      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;
      tColor *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));
    #endif

    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;
    #if !defined(vtkComponent1Proportional)
      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
    #else
      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;
      tColor1 *= pwfValue;
      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));
    #endif

    #if vtkNumComponents >= 3
      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;
      #if !defined(vtkComponent2Proportional)
        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
      #else
        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;
        tColor2 *= pwfValue;
        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));
      #endif

      #if vtkNumComponents >= 4
        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;
        #if !defined(vtkComponent3Proportional)
          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
        #else
          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;
          tColor3 *= pwfValue;
          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));
        #endif
      #endif
    #endif
  #else // then not independent

  #if vtkNumComponents == 2
    float lum = tValue.r * cscale0 + cshift0;
    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;
    vec4 tColor = vec4(lum, lum, lum, alpha);
  #endif
  #if vtkNumComponents == 3
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;
  #endif
  #if vtkNumComponents == 4
    vec4 tColor;
    tColor.r = tValue.r * cscale0 + cshift0;
    tColor.g = tValue.g * cscale1 + cshift1;
    tColor.b = tValue.b * cscale2 + cshift2;
    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;
  #endif
  #endif // dependent

  // apply lighting if requested as appropriate
  #if vtkLightComplexity > 0
    #if !defined(vtkComponent0Proportional)
      applyLighting(tColor.rgb, normal0);
    #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
    #if !defined(vtkComponent1Proportional)
      applyLighting(tColor1, normal1);
    #endif
  #if vtkNumComponents >= 3
    #if !defined(vtkComponent2Proportional)
      applyLighting(tColor2, normal2);
    #endif
  #if vtkNumComponents >= 4
    #if !defined(vtkComponent3Proportional)
      applyLighting(tColor3, normal3);
    #endif
  #endif
  #endif
  #endif
#endif

// perform final independent blend as needed
#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2
  tColor.rgb += tColor1;
#if vtkNumComponents >= 3
  tColor.rgb += tColor2;
#if vtkNumComponents >= 4
  tColor.rgb += tColor3;
#endif
#endif
#endif

#endif







return tColor;
}

bool valueWithinScalarRange(vec4 val, vec4 min, vec4 max) {
  bool withinRange = false;
  #if vtkNumComponents == 1
    if (val.r >= min.r && val.r <= max.r) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents == 2
     if (val.r >= min.r && val.r <= max.r &&
        val.g >= min.g && val.g <= max.g) {
      withinRange = true;
    }
  #endif
  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 3
    if (all(greaterThanEqual(val, ipScalarRangeMin)) &&
        all(lessThanEqual(val, ipScalarRangeMax))) {
      withinRange = true;
    }
  #endif
  return withinRange;
}

//=======================================================================
// Apply the specified blend mode operation along the ray's path.
//
void applyBlend(vec3 posIS, vec3 endIS, float sampleDistanceIS, vec3 tdims)
{
  vec3 tstep = 1.0/tdims;

  // start slightly inside and apply some jitter
  vec3 delta = endIS - posIS;
  vec3 stepIS = normalize(delta)*sampleDistanceIS;
  float raySteps = length(delta)/sampleDistanceIS;

  // avoid 0.0 jitter
  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;
  float stepsTraveled = jitter;

  // local vars for the loop
  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);
  vec4 tValue;
  vec4 tColor;

  // if we have less than one step then pick the middle point
  // as our value
  // if (raySteps <= 1.0)
  // {
  //   posIS = (posIS + endIS)*0.5;
  // }

  // Perform initial step at the volume boundary
  // compute the scalar
  tValue = getTextureValue(posIS);

  #if vtkBlendMode == 0 // COMPOSITE_BLEND
    // now map through opacity and color
    tColor = getColorForValue(tValue, posIS, tstep);

    // handle very thin volumes
    if (raySteps <= 1.0)
    {
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);
      gl_FragData[0] = tColor;
      return;
    }

    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);
    color = vec4(tColor.rgb*tColor.a, tColor.a);
    posIS += (jitter*stepIS);

    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);

      float mix = (1.0 - color.a);

      // this line should not be needed but nvidia seems to not handle
      // the break correctly on windows/chrome 58 angle
      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));

      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
      stepsTraveled++;
      posIS += stepIS;
      if (color.a > 0.99) { color.a = 1.0; break; }
    }

    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)
    {
      posIS = endIS;

      // compute the scalar
      tValue = getTextureValue(posIS);

      // now map through opacity and color
      tColor = getColorForValue(tValue, posIS, tstep);
      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);

      float mix = (1.0 - color.a);
      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;
    }

    gl_FragData[0] = vec4(color.rgb/color.a, color.a);
  #endif
  #if vtkBlendMode == 1 || vtkBlendMode == 2
    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND
    // Find maximum/minimum intensity along the ray.

    // Define the operation we will use (min or max)
    #if vtkBlendMode == 1
    #define OP max
    #else
    #define OP min
    #endif

    // If the clipping range is shorter than the sample distance
    // we can skip the sampling loop along the ray.
    if (raySteps <= 1.0)
    {
      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);
      return;
    }

    vec4 value = tValue;
    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // Update the maximum value if necessary
      value = OP(tValue, value);

      // Otherwise, continue along the ray
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;
    tValue = getTextureValue(posIS);
    value = OP(tValue, value);

    // Now map through opacity and color
    gl_FragData[0] = getColorForValue(value, posIS, tstep);
  #endif
  #if vtkBlendMode == 3 || vtkBlendMode == 4 //AVERAGE_INTENSITY_BLEND || ADDITIVE_BLEND
    vec4 sum = vec4(0.);

    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;
    }

    if (raySteps <= 1.0) {
      gl_FragData[0] = getColorForValue(sum, posIS, tstep);
      return;
    }

    posIS += (jitter*stepIS);

    // Sample along the ray until MaximumSamplesValue,
    // ending slightly inside the total distance
    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)
    {
      // If we have reached the last step, break
      if (stepsTraveled + 1.0 >= raySteps) { break; }

      // compute the scalar
      tValue = getTextureValue(posIS);

      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.
      // Notes:
      // - We are comparing all values in the texture to see if any of them
      //   are outside of the scalar range. In the future we might want to allow
      //   scalar ranges for each component.
      if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
        // Sum the values across each step in the path
        sum += tValue;
      }
      stepsTraveled++;
      posIS += stepIS;
    }

    // Perform the last step along the ray using the
    // residual distance
    posIS = endIS;

    // compute the scalar
    tValue = getTextureValue(posIS);

    // One can control the scalar range by setting the IPScalarRange to disregard scalar values, not in the range of interest, from the average computation
    if (valueWithinScalarRange(tValue, ipScalarRangeMin, ipScalarRangeMax)) {
      sum += tValue;

      stepsTraveled++;
    }

    #if vtkBlendMode == 3 // Average
      sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);
    #endif

    gl_FragData[0] = getColorForValue(sum, posIS, tstep);
  #endif
}

//=======================================================================
// Compute a new start and end point for a given ray based
// on the provided bounded clipping plane (aka a rectangle)
void getRayPointIntersectionBounds(
  vec3 rayPos, vec3 rayDir,
  vec3 planeDir, float planeDist,
  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,
  float vSize1, float vSize2)
{
  float result = dot(rayDir, planeDir);
  if (abs(result) < 1e-6)
  {
    return;
  }
  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;
  vec3 xposVC = rayPos + rayDir*result;
  vec3 vxpos = xposVC - vOriginVC;
  vec2 vpos = vec2(
    dot(vxpos, vPlaneX),
    dot(vxpos, vPlaneY));

  // on some apple nvidia systems this does not work
  // if (vpos.x < 0.0 || vpos.x > vSize1 ||
  //     vpos.y < 0.0 || vpos.y > vSize2)
  // even just
  // if (vpos.x < 0.0 || vpos.y < 0.0)
  // fails
  // so instead we compute a value that represents in and out
  //and then compute the return using this value
  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds
  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out

  tbounds = mix(
   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value
   tbounds, // out value
   check);  // 0 in 1 out
}

//=======================================================================
// given a
// - ray direction (rayDir)
// - starting point (vertexVCVSOutput)
// - bounding planes of the volume
// - optionally depth buffer values
// - far clipping plane
// compute the start/end distances of the ray we need to cast
vec2 computeRayDistances(vec3 rayDir, vec3 tdims)
{
  vec2 dists = vec2(100.0*camFar, -1.0);

  vec3 vSize = vSpacing*tdims;

  // all this is in View Coordinates
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,
    vSize.y, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,
    vSize.x, vSize.z);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);
  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,
    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,
    vSize.x, vSize.y);

  //VTK::ClipPlane::Impl

  // do not go behind front clipping plane
  dists.x = max(0.0,dists.x);

  // do not go PAST far clipping plane
  float farDist = -camThick/rayDir.z;
  dists.y = min(farDist,dists.y);

  // Do not go past the zbuffer value if set
  // This is used for intermixing opaque geometry
  //VTK::ZBuffer::Impl

  return dists;
}

//=======================================================================
// Compute the index space starting position (pos) and end
// position
//
void computeIndexSpaceValues(out vec3 pos, out vec3 endPos, out float sampleDistanceIS, vec3 rayDir, vec2 dists)
{
  // compute starting and ending values in volume space
  pos = vertexVCVSOutput + dists.x*rayDir;
  pos = pos - vOriginVC;
  // convert to volume basis and origin
  pos = vec3(
    dot(pos, vPlaneNormal0),
    dot(pos, vPlaneNormal2),
    dot(pos, vPlaneNormal4));

  endPos = vertexVCVSOutput + dists.y*rayDir;
  endPos = endPos - vOriginVC;
  endPos = vec3(
    dot(endPos, vPlaneNormal0),
    dot(endPos, vPlaneNormal2),
    dot(endPos, vPlaneNormal4));

  float delta = length(endPos - pos);

  pos *= vVCToIJK;
  endPos *= vVCToIJK;

  float delta2 = length(endPos - pos);
  sampleDistanceIS = sampleDistance*delta2/delta;
}

void main()
{

  vec3 rayDirVC;

  if (cameraParallel == 1)
  {
    // Camera is parallel, so the rayDir is just the direction of the camera.
    rayDirVC = vec3(0.0, 0.0, -1.0);
  } else {
    // camera is at 0,0,0 so rayDir for perspective is just the vc coord
    rayDirVC = normalize(vertexVCVSOutput);
  }

  vec3 tdims = vec3(volumeDimensions);

  // compute the start and end points for the ray
  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);

  // do we need to composite? aka does the ray have any length
  // If not, bail out early
  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)
  {
    discard;
  }

  // IS = Index Space
  vec3 posIS;
  vec3 endIS;
  float sampleDistanceIS;
  computeIndexSpaceValues(posIS, endIS, sampleDistanceIS, rayDirVC, rayStartEndDistancesVC);

  // Perform the blending operation along the ray
  applyBlend(posIS, endIS, sampleDistanceIS, tdims);
}
`;
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js
var VolumeMapper_exports = {};
__export(VolumeMapper_exports, {
  default: () => vtkVolumeMapper,
  extend: () => extend27,
  newInstance: () => newInstance29
});
function ownKeys11(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread11(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys11(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys11(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function arrayEquals(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; ++i) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function vtkOpenGLVolumeMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVolumeMapper");
  publicAPI.buildPass = function() {
    model.zBufferTexture = null;
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    if (prepass) {
      var zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };
  publicAPI.volumePass = function(prepass, renderPass) {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.scalarTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.opacityTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLVolume = publicAPI.getFirstAncestorOfType("vtkOpenGLVolume");
      var actor = model.openGLVolume.getRenderable();
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
      publicAPI.renderPiece(ren, actor);
    }
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkVolumeVS;
    shaders.Fragment = vtkVolumeFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType.LINEAR) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TrilinearOn", "#define vtkTrilinearOn").result;
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ImageLabelOutlineOn", "#define vtkImageLabelOutlineOn").result;
    }
    var numComp = model.scalarTexture.getComponents();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::NumComponents", "#define vtkNumComponents ".concat(numComp)).result;
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::IndependentComponentsOn", "#define vtkIndependentComponentsOn").result;
      var proportionalComponents = [];
      for (var nc = 0; nc < numComp; nc++) {
        if (actor.getProperty().getOpacityMode(nc) === OpacityMode.PROPORTIONAL) {
          proportionalComponents.push("#define vtkComponent".concat(nc, "Proportional"));
        }
      }
      if (proportionalComponents.length > 0) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::vtkProportionalComponents", proportionalComponents.join("\n")).result;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::MaximumSamplesValue", "".concat(Math.ceil(maxSamples))).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::LightComplexity", "#define vtkLightComplexity ".concat(model.lastLightComplexity)).result;
    model.gopacity = actor.getProperty().getUseGradientOpacity(0);
    for (var _nc = 1; iComps && !model.gopacity && _nc < numComp; ++_nc) {
      if (actor.getProperty().getUseGradientOpacity(_nc)) {
        model.gopacity = true;
      }
    }
    if (model.gopacity) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::GradientOpacityOn", "#define vtkGradientOpacityOn").result;
    }
    if (model.zBufferTexture !== null) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", ["uniform sampler2D zBufferTexture;", "uniform float vpWidth;", "uniform float vpHeight;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));", "float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;", "zdepth = zdepth * 2.0 - 1.0;", "zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;", "zdepth = -zdepth/rayDir.z;", "dists.y = min(zdepth,dists.y);"]).result;
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::BlendMode", "".concat(model.renderable.getBlendMode())).result;
    shaders.Fragment = FSSource;
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderClippingPlane(shaders, ren, actor);
  };
  publicAPI.replaceShaderLight = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    var shadowFactor = "";
    switch (model.lastLightComplexity) {
      case 1:
      case 2:
      case 3: {
        var lightNum = 0;
        ren.getLights().forEach(function(light) {
          var status = light.getSwitch();
          if (status > 0) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", [
              "uniform vec3 lightColor".concat(lightNum, ";"),
              "uniform vec3 lightDirectionVC".concat(lightNum, "; // normalized"),
              "uniform vec3 lightHalfAngleVC".concat(lightNum, "; // normalized"),
              "//VTK::Light::Dec"
            ], false).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", [
              "  float df = abs(dot(normal.rgb, -lightDirectionVC".concat(lightNum, "));"),
              "  diffuse += ((df".concat(shadowFactor, ") * lightColor").concat(lightNum, ");"),
              "    float sf = pow( abs(dot(lightHalfAngleVC".concat(lightNum, ",normal.rgb)), vSpecularPower);"),
              "    specular += ((sf".concat(shadowFactor, ") * lightColor").concat(lightNum, ");"),
              "  //VTK::Light::Impl"
            ], false).result;
            lightNum++;
          }
        });
        break;
      }
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderClippingPlane = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    if (model.renderable.getClippingPlanes().length > 0) {
      var clipPlaneSize = model.renderable.getClippingPlanes().length;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Dec", ["uniform vec3 vClipPlaneNormals[6];", "uniform float vClipPlaneDistances[6];", "//VTK::ClipPlane::Dec"], false).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ClipPlane::Impl", ["for(int i = 0; i < ".concat(clipPlaneSize, "; i++) {"), "  float rayDirRatio = dot(rayDir, vClipPlaneNormals[i]);", "  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];", "  if (rayDirRatio == 0.0)", "  {", "    if (equationResult < 0.0) dists.x = dists.y;", "    continue;", "  }", "  float result = -1.0 * equationResult / rayDirRatio;", "  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);", "  else dists.x = max(dists.x, result);", "}", "//VTK::ClipPlane::Impl"], false).result;
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var lightComplexity = 0;
    if (actor.getProperty().getShade() && model.renderable.getBlendMode() === BlendMode.COMPOSITE_BLEND) {
      lightComplexity = 0;
      model.numberOfLights = 0;
      ren.getLights().forEach(function(light) {
        var status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (model.numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }
    var needRebuild = false;
    if (model.lastLightComplexity !== lightComplexity) {
      model.lastLightComplexity = lightComplexity;
      needRebuild = true;
    }
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    var usesProportionalComponents = false;
    var proportionalComponents = [];
    if (iComps) {
      for (var nc = 0; nc < numComp; nc++) {
        proportionalComponents.push(actor.getProperty().getOpacityMode(nc));
      }
      if (proportionalComponents.length > 0) {
        usesProportionalComponents = true;
      }
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    var state = {
      interpolationType: actor.getProperty().getInterpolationType(),
      useLabelOutline: actor.getProperty().getUseLabelOutline(),
      numComp,
      usesProportionalComponents,
      iComps,
      maxSamples,
      useGradientOpacity: actor.getProperty().getUseGradientOpacity(0),
      blendMode: model.renderable.getBlendMode(),
      proportionalComponents
    };
    if (!model.previousState || model.previousState.interpolationType !== state.interpolationType || model.previousState.useLabelOutline !== state.useLabelOutline || model.previousState.numComp !== state.numComp || model.previousState.usesProportionalComponents !== state.usesProportionalComponents || model.previousState.iComps !== state.iComps || model.previousState.maxSamples !== state.maxSamples || model.previousState.useGradientOpacity !== state.useGradientOpacity || model.previousState.blendMode !== state.blendMode || !arrayEquals(model.previousState.proportionalComponents, state.proportionalComponents)) {
      model.previousState = _objectSpread11({}, state);
      return true;
    }
    if (cellBO.getProgram() === 0 || needRebuild || model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || !!model.lastZBufferTexture !== !!model.zBufferTexture || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime()) {
      model.lastZBufferTexture = model.zBufferTexture;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.getClippingPlaneShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (program.isAttributeUsed("vertexDC")) {
        if (!cellBO.getVAO().addAttributeArray(program, cellBO.getCABO(), "vertexDC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro13("Error setting vertexDC in shader VAO.");
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    program.setUniformi("texture1", model.scalarTexture.getTextureUnit());
    program.setUniformf("sampleDistance", model.renderable.getSampleDistance());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var ipScalarRange = model.renderable.getIpScalarRange();
    var minVals = [];
    var maxVals = [];
    for (var i = 0; i < 4; i++) {
      minVals[i] = ipScalarRange[0] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      maxVals[i] = ipScalarRange[1] * volInfo.dataComputedScale[i] + volInfo.dataComputedOffset[i];
      minVals[i] = (minVals[i] - volInfo.offset[i]) / volInfo.scale[i];
      maxVals[i] = (maxVals[i] - volInfo.offset[i]) / volInfo.scale[i];
    }
    program.setUniform4f("ipScalarRangeMin", minVals[0], minVals[1], minVals[2], minVals[3]);
    program.setUniform4f("ipScalarRangeMax", maxVals[0], maxVals[1], maxVals[2], maxVals[3]);
    if (model.zBufferTexture !== null) {
      program.setUniformi("zBufferTexture", model.zBufferTexture.getTextureUnit());
      var size = publicAPI.getRenderTargetSize();
      program.setUniformf("vpWidth", size[0]);
      program.setUniformf("vpHeight", size[1]);
    }
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    var actMats = model.openGLVolume.getKeyMatrices();
    mat4_exports.multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);
    var program = cellBO.getProgram();
    var cam = model.openGLCamera.getRenderable();
    var crange = cam.getClippingRange();
    program.setUniformf("camThick", crange[1] - crange[0]);
    program.setUniformf("camNear", crange[0]);
    program.setUniformf("camFar", crange[1]);
    var bounds = model.currentInput.getBounds();
    var dims = model.currentInput.getDimensions();
    var pos = new Float64Array(3);
    var dir = new Float64Array(3);
    var dcxmin = 1;
    var dcxmax = -1;
    var dcymin = 1;
    var dcymax = -1;
    for (var i = 0; i < 8; ++i) {
      vec3_exports.set(pos, bounds[i % 2], bounds[2 + Math.floor(i / 2) % 2], bounds[4 + Math.floor(i / 4)]);
      vec3_exports.transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        vec3_exports.normalize(dir, pos);
        var t = -crange[0] / pos[2];
        vec3_exports.scale(pos, dir, t);
      }
      vec3_exports.transformMat4(pos, pos, keyMats.vcpc);
      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }
    program.setUniformf("dcxmin", dcxmin);
    program.setUniformf("dcxmax", dcxmax);
    program.setUniformf("dcymin", dcymin);
    program.setUniformf("dcymax", dcymax);
    if (program.isUniformUsed("cameraParallel")) {
      program.setUniformi("cameraParallel", cam.getParallelProjection());
    }
    var ext = model.currentInput.getSpatialExtent();
    var spc = model.currentInput.getSpacing();
    var vsize = new Float64Array(3);
    vec3_exports.set(vsize, (ext[1] - ext[0]) * spc[0], (ext[3] - ext[2]) * spc[1], (ext[5] - ext[4]) * spc[2]);
    program.setUniform3f("vSpacing", spc[0], spc[1], spc[2]);
    vec3_exports.set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);
    vec3_exports.transformMat4(pos, pos, model.modelToView);
    program.setUniform3f("vOriginVC", pos[0], pos[1], pos[2]);
    var i2wmat4 = model.currentInput.getIndexToWorld();
    mat4_exports.multiply(model.idxToView, model.modelToView, i2wmat4);
    mat3_exports.multiply(model.idxNormalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    mat3_exports.multiply(model.idxNormalMatrix, model.idxNormalMatrix, model.currentInput.getDirection());
    var maxSamples = vec3_exports.length(vsize) / model.renderable.getSampleDistance();
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro5("The number of steps required ".concat(Math.ceil(maxSamples), " is larger than the\n        specified maximum number of steps ").concat(model.renderable.getMaximumSamplesPerRay(), ".\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples."));
    }
    var vctoijk = new Float64Array(3);
    vec3_exports.set(vctoijk, 1, 1, 1);
    vec3_exports.divide(vctoijk, vctoijk, vsize);
    program.setUniform3f("vVCToIJK", vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i("volumeDimensions", dims[0], dims[1], dims[2]);
    if (!model._openGLRenderWindow.getWebgl2()) {
      var volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf("texWidth", model.scalarTexture.getWidth());
      program.setUniformf("texHeight", model.scalarTexture.getHeight());
      program.setUniformi("xreps", volInfo.xreps);
      program.setUniformi("xstride", volInfo.xstride);
      program.setUniformi("ystride", volInfo.ystride);
    }
    var normal = new Float64Array(3);
    var pos2 = new Float64Array(3);
    for (var _i = 0; _i < 6; ++_i) {
      switch (_i) {
        case 1:
          vec3_exports.set(normal, -1, 0, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          vec3_exports.set(normal, 0, 1, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          vec3_exports.set(normal, 0, -1, 0);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          vec3_exports.set(normal, 0, 0, 1);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          vec3_exports.set(normal, 0, 0, -1);
          vec3_exports.set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 0:
        default:
          vec3_exports.set(normal, 1, 0, 0);
          vec3_exports.set(pos2, ext[1], ext[3], ext[5]);
          break;
      }
      vec3_exports.transformMat3(normal, normal, model.idxNormalMatrix);
      vec3_exports.transformMat4(pos2, pos2, model.idxToView);
      var dist = -1 * vec3_exports.dot(pos2, normal);
      program.setUniform3f("vPlaneNormal".concat(_i), normal[0], normal[1], normal[2]);
      program.setUniformf("vPlaneDistance".concat(_i), dist);
      if (actor.getProperty().getUseLabelOutline()) {
        var image = model.currentInput;
        var worldToIndex = image.getWorldToIndex();
        program.setUniformMatrix("vWCtoIDX", worldToIndex);
        mat4_exports.invert(model.projectionToWorld, keyMats.wcpc);
        program.setUniformMatrix("PCWCMatrix", model.projectionToWorld);
        var size = publicAPI.getRenderTargetSize();
        program.setUniformf("vpWidth", size[0]);
        program.setUniformf("vpHeight", size[1]);
        var offset = publicAPI.getRenderTargetOffset();
        program.setUniformf("vpOffsetX", offset[0] / size[0]);
        program.setUniformf("vpOffsetY", offset[1] / size[1]);
      }
    }
    mat4_exports.invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix("PCVCMatrix", model.projectionToView);
    switch (model.lastLightComplexity) {
      case 1:
      case 2:
      case 3: {
        var lightNum = 0;
        var lightColor = [];
        ren.getLights().forEach(function(light) {
          var status = light.getSwitch();
          if (status > 0) {
            var dColor = light.getColor();
            var intensity = light.getIntensity();
            lightColor[0] = dColor[0] * intensity;
            lightColor[1] = dColor[1] * intensity;
            lightColor[2] = dColor[2] * intensity;
            program.setUniform3fArray("lightColor".concat(lightNum), lightColor);
            var ldir = light.getDirection();
            vec3_exports.set(normal, ldir[0], ldir[1], ldir[2]);
            vec3_exports.transformMat3(normal, normal, keyMats.normalMatrix);
            program.setUniform3f("lightDirectionVC".concat(lightNum), normal[0], normal[1], normal[2]);
            var halfAngle = [-0.5 * normal[0], -0.5 * normal[1], -0.5 * (normal[2] - 1)];
            program.setUniform3fArray("lightHalfAngleVC".concat(lightNum), halfAngle);
            lightNum++;
          }
        });
        break;
      }
    }
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    program.setUniformi("ctexture", model.colorTexture.getTextureUnit());
    program.setUniformi("otexture", model.opacityTexture.getTextureUnit());
    program.setUniformi("jtexture", model.jitterTexture.getTextureUnit());
    var volInfo = model.scalarTexture.getVolumeInfo();
    var vprop = actor.getProperty();
    var numComp = model.scalarTexture.getComponents();
    var iComps = actor.getProperty().getIndependentComponents();
    if (iComps && numComp >= 2) {
      for (var i = 0; i < numComp; i++) {
        program.setUniformf("mix".concat(i), actor.getProperty().getComponentWeight(i));
      }
    }
    for (var _i2 = 0; _i2 < numComp; _i2++) {
      var target = iComps ? _i2 : 0;
      var sscale = volInfo.scale[_i2];
      var ofun = vprop.getScalarOpacity(target);
      var oRange = ofun.getRange();
      var oscale = sscale / (oRange[1] - oRange[0]);
      var oshift = (volInfo.offset[_i2] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf("oshift".concat(_i2), oshift);
      program.setUniformf("oscale".concat(_i2), oscale);
      var cfun = vprop.getRGBTransferFunction(target);
      var cRange = cfun.getRange();
      program.setUniformf("cshift".concat(_i2), (volInfo.offset[_i2] - cRange[0]) / (cRange[1] - cRange[0]));
      program.setUniformf("cscale".concat(_i2), sscale / (cRange[1] - cRange[0]));
    }
    if (model.gopacity) {
      if (iComps) {
        for (var nc = 0; nc < numComp; ++nc) {
          var _sscale = volInfo.scale[nc];
          var useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            var gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            var gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf("gomin".concat(nc), gomin);
            program.setUniformf("gomax".concat(nc), gomax);
            var goRange = [vprop.getGradientOpacityMinimumValue(nc), vprop.getGradientOpacityMaximumValue(nc)];
            program.setUniformf("goscale".concat(nc), _sscale * (gomax - gomin) / (goRange[1] - goRange[0]));
            program.setUniformf("goshift".concat(nc), -goRange[0] * (gomax - gomin) / (goRange[1] - goRange[0]) + gomin);
          } else {
            program.setUniformf("gomin".concat(nc), 1);
            program.setUniformf("gomax".concat(nc), 1);
            program.setUniformf("goscale".concat(nc), 0);
            program.setUniformf("goshift".concat(nc), 1);
          }
        }
      } else {
        var _sscale2 = volInfo.scale[numComp - 1];
        var _gomin = vprop.getGradientOpacityMinimumOpacity(0);
        var _gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf("gomin0", _gomin);
        program.setUniformf("gomax0", _gomax);
        var _goRange = [vprop.getGradientOpacityMinimumValue(0), vprop.getGradientOpacityMaximumValue(0)];
        program.setUniformf("goscale0", _sscale2 * (_gomax - _gomin) / (_goRange[1] - _goRange[0]));
        program.setUniformf("goshift0", -_goRange[0] * (_gomax - _gomin) / (_goRange[1] - _goRange[0]) + _gomin);
      }
    }
    var vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      var labelOutlineThickness = actor.getProperty().getLabelOutlineThickness();
      program.setUniformi("outlineThickness", labelOutlineThickness);
    }
    if (model.lastLightComplexity > 0) {
      program.setUniformf("vAmbient", vprop.getAmbient());
      program.setUniformf("vDiffuse", vprop.getDiffuse());
      program.setUniformf("vSpecular", vprop.getSpecular());
      program.setUniformf("vSpecularPower", vprop.getSpecularPower());
    }
  };
  publicAPI.getClippingPlaneShaderParameters = function(cellBO, ren, actor) {
    if (model.renderable.getClippingPlanes().length > 0) {
      var keyMats = model.openGLCamera.getKeyMatrices(ren);
      var clipPlaneNormals = [];
      var clipPlaneDistances = [];
      var clipPlanes = model.renderable.getClippingPlanes();
      var clipPlaneSize = clipPlanes.length;
      for (var i = 0; i < clipPlaneSize; ++i) {
        var clipPlaneNormal = clipPlanes[i].getNormal();
        var clipPlanePos = clipPlanes[i].getOrigin();
        vec3_exports.transformMat3(clipPlaneNormal, clipPlaneNormal, keyMats.normalMatrix);
        vec3_exports.transformMat4(clipPlanePos, clipPlanePos, keyMats.wcvc);
        var clipPlaneDist = -1 * vec3_exports.dot(clipPlanePos, clipPlaneNormal);
        clipPlaneNormals.push(clipPlaneNormal[0]);
        clipPlaneNormals.push(clipPlaneNormal[1]);
        clipPlaneNormals.push(clipPlaneNormal[2]);
        clipPlaneDistances.push(clipPlaneDist);
      }
      var program = cellBO.getProgram();
      program.setUniform3fv("vClipPlaneNormals", clipPlaneNormals);
      program.setUniformfv("vClipPlaneDistances", clipPlaneDistances);
    }
  };
  publicAPI.delete = chain(function() {
    if (model._animationRateSubscription) {
      model._animationRateSubscription.unsubscribe();
      model._animationRateSubscription = null;
    }
  }, publicAPI.delete);
  publicAPI.getRenderTargetSize = function() {
    if (model._useSmallViewport) {
      return [model._smallViewportWidth, model._smallViewportHeight];
    }
    var _model$openGLRenderer = model.openGLRenderer.getTiledSizeAndOrigin(), usize = _model$openGLRenderer.usize, vsize = _model$openGLRenderer.vsize;
    return [usize, vsize];
  };
  publicAPI.getRenderTargetOffset = function() {
    var _model$openGLRenderer2 = model.openGLRenderer.getTiledSizeAndOrigin(), lowerLeftU = _model$openGLRenderer2.lowerLeftU, lowerLeftV = _model$openGLRenderer2.lowerLeftV;
    return [lowerLeftU, lowerLeftV];
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    var rwi = ren.getVTKWindow().getInteractor();
    model._useSmallViewport = false;
    if (rwi.isAnimating() && model._lastScale > 1.5) {
      model._useSmallViewport = true;
    }
    if (!model._animationRateSubscription) {
      model._animationRateSubscription = rwi.onAnimationFrameRateUpdate(function() {
        if (model.renderable.getAutoAdjustSampleDistances()) {
          var frate = rwi.getRecentAnimationFrameRate();
          var adjustment = rwi.getDesiredUpdateRate() / frate;
          if (adjustment > 1.15 || adjustment < 0.85) {
            model._lastScale *= adjustment;
          }
          if (model._lastScale > 400) {
            model._lastScale = 400;
          }
          if (model._lastScale < 1.5) {
            model._lastScale = 1.5;
          }
        } else {
          model._lastScale = model.renderable.getImageSampleDistance() * model.renderable.getImageSampleDistance();
        }
        var size2 = model._openGLRenderWindow.getFramebufferSize();
        model._smallViewportWidth = Math.ceil(size2[0] / Math.sqrt(model._lastScale));
        model._smallViewportHeight = Math.ceil(size2[1] / Math.sqrt(model._lastScale));
      });
    }
    if (model._useSmallViewport) {
      var size = model._openGLRenderWindow.getFramebufferSize();
      if (model._smallViewportHeight > size[1]) {
        model._smallViewportHeight = size[1];
      }
      if (model._smallViewportWidth > size[0]) {
        model._smallViewportWidth = size[0];
      }
      model.framebuffer.saveCurrentBindingsAndBuffers();
      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        var fbSize = model.framebuffer.getSize();
        if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
          model.framebuffer.create(size[0], size[1]);
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      var gl = model.context;
      gl.clearColor(0, 0, 0, 0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, model._smallViewportWidth, model._smallViewportHeight);
      model.fvp = [model._smallViewportWidth / size[0], model._smallViewportHeight / size[1]];
    }
    model.context.disable(model.context.DEPTH_TEST);
    publicAPI.updateBufferObjects(ren, actor);
    var iType = actor.getProperty().getInterpolationType();
    if (iType === InterpolationType.NEAREST) {
      model.scalarTexture.setMinificationFilter(Filter.NEAREST);
      model.scalarTexture.setMagnificationFilter(Filter.NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(Filter.LINEAR);
      model.scalarTexture.setMagnificationFilter(Filter.LINEAR);
    }
    model.lastBoundBO = null;
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var gl = model.context;
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();
    publicAPI.updateShaders(model.tris, ren, actor);
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();
    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.jitterTexture.deactivate();
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }
    if (model._useSmallViewport) {
      model.framebuffer.restorePreviousBindingsAndBuffers();
      if (model.copyShader === null) {
        model.copyShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "uniform vec2 tfactor;", "varying vec2 tcoord;", "void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"), ["//VTK::System::Dec", "//VTK::Output::Dec", "uniform sampler2D texture1;", "varying vec2 tcoord;", "void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"), "");
        var program = model.copyShader;
        model.copyVAO = vtkVertexArrayObject.newInstance();
        model.copyVAO.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.tris.getCABO().bind();
        if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
          vtkErrorMacro13("Error setting vertexDC in copy shader VAO.");
        }
      } else {
        model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.copyShader);
      }
      var size = model._openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);
      var tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi("texture", tex.getTextureUnit());
      model.copyShader.setUniform2f("tfactor", model.fvp[0], model.fvp[1]);
      var gl = model.context;
      gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      tex.deactivate();
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    }
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    if (!model.currentInput) {
      vtkErrorMacro13("No input!");
      return;
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime() || model.VBOBuildTime.getMTime() < actor.getMTime() || model.VBOBuildTime.getMTime() < model.renderable.getMTime() || model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() || model.VBOBuildTime.getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var image = model.currentInput;
    if (!image) {
      return;
    }
    var scalars = image.getPointData() && image.getPointData().getScalars();
    if (!scalars) {
      return;
    }
    var vprop = actor.getProperty();
    if (!model.jitterTexture.getHandle()) {
      var oTable = new Uint8Array(32 * 32);
      for (var i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(Filter.LINEAR);
      model.jitterTexture.setMagnificationFilter(Filter.LINEAR);
      model.jitterTexture.create2DFromRaw(32, 32, 1, VtkDataTypes.UNSIGNED_CHAR, oTable);
    }
    var numComp = scalars.getNumberOfComponents();
    var iComps = vprop.getIndependentComponents();
    var numIComps = iComps ? numComp : 1;
    var toString = "".concat(vprop.getMTime());
    if (model.opacityTextureString !== toString) {
      var oWidth = 1024;
      var oSize = oWidth * 2 * numIComps;
      var ofTable = new Float32Array(oSize);
      var tmpTable = new Float32Array(oWidth);
      for (var c = 0; c < numIComps; ++c) {
        var ofun = vprop.getScalarOpacity(c);
        var opacityFactor = model.renderable.getSampleDistance() / vprop.getScalarOpacityUnitDistance(c);
        var oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        for (var _i3 = 0; _i3 < oWidth; ++_i3) {
          ofTable[c * oWidth * 2 + _i3] = 1 - Math.pow(1 - tmpTable[_i3], opacityFactor);
          ofTable[c * oWidth * 2 + _i3 + oWidth] = ofTable[c * oWidth * 2 + _i3];
        }
      }
      model.opacityTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.opacityTexture.setMinificationFilter(Filter.LINEAR);
      model.opacityTexture.setMagnificationFilter(Filter.LINEAR);
      if (model._openGLRenderWindow.getWebgl2() || model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.FLOAT, ofTable);
      } else {
        var _oTable = new Uint8Array(oSize);
        for (var _i4 = 0; _i4 < oSize; ++_i4) {
          _oTable[_i4] = 255 * ofTable[_i4];
        }
        model.opacityTexture.create2DFromRaw(oWidth, 2 * numIComps, 1, VtkDataTypes.UNSIGNED_CHAR, _oTable);
      }
      model.opacityTextureString = toString;
    }
    toString = "".concat(vprop.getMTime());
    if (model.colorTextureString !== toString) {
      var cWidth = 1024;
      var cSize = cWidth * 2 * numIComps * 3;
      var cTable = new Uint8Array(cSize);
      var _tmpTable = new Float32Array(cWidth * 3);
      for (var _c = 0; _c < numIComps; ++_c) {
        var cfun = vprop.getRGBTransferFunction(_c);
        var cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, _tmpTable, 1);
        for (var _i5 = 0; _i5 < cWidth * 3; ++_i5) {
          cTable[_c * cWidth * 6 + _i5] = 255 * _tmpTable[_i5];
          cTable[_c * cWidth * 6 + _i5 + cWidth * 3] = 255 * _tmpTable[_i5];
        }
      }
      model.colorTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.colorTexture.setMinificationFilter(Filter.LINEAR);
      model.colorTexture.setMagnificationFilter(Filter.LINEAR);
      model.colorTexture.create2DFromRaw(cWidth, 2 * numIComps, 3, VtkDataTypes.UNSIGNED_CHAR, cTable);
      model.colorTextureString = toString;
    }
    toString = "".concat(image.getMTime());
    if (model.scalarTextureString !== toString) {
      var dims = image.getDimensions();
      model.scalarTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromRaw(dims[0], dims[1], dims[2], numComp, scalars.getDataType(), scalars.getData(), model.renderable.getPreferSizeOverAccuracy());
      model.scalarTextureString = toString;
    }
    if (!model.tris.getCABO().getElementCount()) {
      var ptsArray = new Float32Array(12);
      for (var _i6 = 0; _i6 < 4; _i6++) {
        ptsArray[_i6 * 3] = _i6 % 2 * 2 - 1;
        ptsArray[_i6 * 3 + 1] = _i6 > 1 ? 1 : -1;
        ptsArray[_i6 * 3 + 2] = -1;
      }
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    model.VBOBuildTime.modified();
  };
}
function extend27(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  model.scalarTexture = vtkOpenGLTexture$1.newInstance();
  model.opacityTexture = vtkOpenGLTexture$1.newInstance();
  model.colorTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture = vtkOpenGLTexture$1.newInstance();
  model.jitterTexture.setWrapS(Wrap.REPEAT);
  model.jitterTexture.setWrapT(Wrap.REPEAT);
  model.framebuffer = vtkOpenGLFramebuffer.newInstance();
  model.idxToView = mat4_exports.identity(new Float64Array(16));
  model.idxNormalMatrix = mat3_exports.identity(new Float64Array(9));
  model.modelToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToView = mat4_exports.identity(new Float64Array(16));
  model.projectionToWorld = mat4_exports.identity(new Float64Array(16));
  model._lastScale = 1;
  setGet(publicAPI, model, ["context"]);
  vtkOpenGLVolumeMapper(publicAPI, model);
}
var vtkWarningMacro5, vtkErrorMacro13, DEFAULT_VALUES27, newInstance29, vtkVolumeMapper;
var init_VolumeMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/VolumeMapper.js"() {
    init_defineProperty();
    init_macros();
    init_esm();
    init_DataArray();
    init_Constants2();
    init_Helper();
    init_Math();
    init_Framebuffer();
    init_Texture();
    init_ShaderProgram();
    init_VertexArrayObject();
    init_ViewNode();
    init_Constants9();
    init_Constants10();
    init_Constants6();
    init_Constants();
    init_vtkVolumeVS_glsl();
    init_vtkVolumeFS_glsl();
    init_ViewNodeFactory2();
    vtkWarningMacro5 = vtkWarningMacro;
    vtkErrorMacro13 = vtkErrorMacro;
    DEFAULT_VALUES27 = {
      context: null,
      VBOBuildTime: null,
      scalarTexture: null,
      scalarTextureString: null,
      opacityTexture: null,
      opacityTextureString: null,
      colorTexture: null,
      colorTextureString: null,
      jitterTexture: null,
      tris: null,
      framebuffer: null,
      copyShader: null,
      copyVAO: null,
      lastXYF: 1,
      targetXYF: 1,
      zBufferTexture: null,
      lastZBufferTexture: null,
      lastLightComplexity: 0,
      fullViewportTime: 1,
      idxToView: null,
      idxNormalMatrix: null,
      modelToView: null,
      projectionToView: null,
      avgWindowArea: 0,
      avgFrameTime: 0
    };
    newInstance29 = newInstance(extend27, "vtkOpenGLVolumeMapper");
    vtkVolumeMapper = {
      newInstance: newInstance29,
      extend: extend27
    };
    registerOverride("vtkVolumeMapper", newInstance29);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var PixelSpaceCallbackMapper_exports = {};
__export(PixelSpaceCallbackMapper_exports, {
  default: () => vtkPixelSpaceCallbackMapper,
  extend: () => extend28,
  newInstance: () => newInstance30
});
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = function(prepass, renderPass) {
    model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model.openGLRenderer.getParent();
    var aspectRatio = model.openGLRenderer.getAspectRatio();
    var camera = model.openGLRenderer ? model.openGLRenderer.getRenderable().getActiveCamera() : null;
    var tsize = model.openGLRenderer.getTiledSizeAndOrigin();
    var texels = null;
    if (model.renderable.getUseZValues()) {
      var zbt = renderPass.getZBufferTexture();
      var width = Math.floor(zbt.getWidth());
      var height = Math.floor(zbt.getHeight());
      var gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      var fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro7("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
function extend28(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var vtkDebugMacro7, DEFAULT_VALUES28, newInstance30, vtkPixelSpaceCallbackMapper;
var init_PixelSpaceCallbackMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js"() {
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    vtkDebugMacro7 = vtkDebugMacro;
    DEFAULT_VALUES28 = {};
    newInstance30 = newInstance(extend28, "vtkOpenGLPixelSpaceCallbackMapper");
    vtkPixelSpaceCallbackMapper = {
      newInstance: newInstance30,
      extend: extend28
    };
    registerOverride("vtkPixelSpaceCallbackMapper", newInstance30);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
function registerOverride2(className, fn) {
  CLASS_MAPPING2[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
function extend29(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  model.overrides = CLASS_MAPPING2;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
var CLASS_MAPPING2, DEFAULT_VALUES29, newInstance31;
var init_ViewNodeFactory3 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js"() {
    init_macros();
    init_ViewNodeFactory();
    CLASS_MAPPING2 = /* @__PURE__ */ Object.create(null);
    DEFAULT_VALUES29 = {};
    newInstance31 = macro.newInstance(extend29, "vtkWebGPUViewNodeFactory");
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = function(outMat, aspect, cRange, windowCenter) {
    mat4_exports.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      var parallelScale = model.renderable.getParallelScale();
      var width = parallelScale * aspect;
      var height = parallelScale;
      var xmin = (windowCenter[0] - 1) * width;
      var xmax = (windowCenter[0] + 1) * width;
      var ymin = (windowCenter[1] - 1) * height;
      var ymax = (windowCenter[1] + 1) * height;
      var xr = 1 / (xmax - xmin);
      var yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      var tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      var _width;
      var _height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        _width = cRange[0] * tmp;
        _height = cRange[0] * tmp / aspect;
      } else {
        _width = cRange[0] * tmp * aspect;
        _height = cRange[0] * tmp;
      }
      var _xmin = (windowCenter[0] - 1) * _width;
      var _xmax = (windowCenter[0] + 1) * _width;
      var _ymin = (windowCenter[1] - 1) * _height;
      var _ymax = (windowCenter[1] + 1) * _height;
      outMat[0] = 2 * cRange[0] / (_xmax - _xmin);
      outMat[5] = 2 * cRange[0] / (_ymax - _ymin);
      outMat[12] = (_xmin + _xmax) / (_xmax - _xmin);
      outMat[13] = (_ymin + _ymax) / (_ymax - _ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = function(val) {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    var cRange = model.renderable.getClippingRangeByReference();
    var zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = function(webGPURenderer) {
    var ren = webGPURenderer.getRenderable();
    var webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      var wcvc = model.renderable.getViewMatrix();
      mat4_exports.copy(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, wcvc);
      var center = webGPURenderer.getStabilizedCenterByReference();
      mat4_exports.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      var aspectRatio = webGPURenderer.getAspectRatio();
      var cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      mat4_exports.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      mat4_exports.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
function extend30(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var DEFAULT_VALUES30, newInstance32;
var init_Camera3 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory3();
    DEFAULT_VALUES30 = {
      keyMatrixTime: null,
      keyMatrices: null
    };
    newInstance32 = macro.newInstance(extend30);
    registerOverride2("vtkCamera", newInstance32);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = function(bindables) {
    if (model.bindables.length === bindables.length) {
      var allMatch = true;
      for (var i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = function(device) {
    var entries = [];
    for (var i = 0; i < model.bindables.length; i++) {
      var entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = function(device) {
    var mtime = publicAPI.getMTime();
    for (var i = 0; i < model.bindables.length; i++) {
      var tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    var entries = [];
    for (var _i = 0; _i < model.bindables.length; _i++) {
      var entry = model.bindables[_i].getBindGroupEntry();
      entry.binding = _i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = function(pipeline) {
    var lines = [];
    var bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (var i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join("\n");
  };
}
function extend31(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation", "sourceTime"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var DEFAULT_VALUES31, newInstance33, vtkWebGPUBindGroup$1;
var init_BindGroup = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js"() {
    init_macros();
    DEFAULT_VALUES31 = {
      device: null,
      handle: null,
      label: null
    };
    newInstance33 = macro.newInstance(extend31);
    vtkWebGPUBindGroup$1 = {
      newInstance: newInstance33,
      extend: extend31
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = function(device, shaderDesc) {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
function extend32(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var DEFAULT_VALUES32, newInstance34, vtkWebGPUShaderModule$1;
var init_ShaderModule = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js"() {
    init_macros();
    DEFAULT_VALUES32 = {
      device: null,
      handle: null
    };
    newInstance34 = macro.newInstance(extend32, "vtkWebGPUShaderModule");
    vtkWebGPUShaderModule$1 = {
      newInstance: newInstance34,
      extend: extend32
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
function substitute2(source, search, replace) {
  var all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  var replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  var gflag = "";
  if (all) {
    gflag = "g";
  }
  var regex = new RegExp(search, gflag);
  var resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = function(shaderDesc) {
    var sType = shaderDesc.getType();
    var sHash = shaderDesc.getHash();
    var keys = model._shaderModules.keys();
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    var sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
function extend33(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES33, initialValues);
  model._shaderModules = /* @__PURE__ */ new Map();
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var DEFAULT_VALUES33, newInstance35, vtkWebGPUShaderCache$1;
var init_ShaderCache = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js"() {
    init_macros();
    init_ShaderModule();
    DEFAULT_VALUES33 = {
      shaderModules: null,
      device: null,
      window: null
    };
    newInstance35 = macro.newInstance(extend33, "vtkWebGPUShaderCache");
    vtkWebGPUShaderCache$1 = {
      newInstance: newInstance35,
      extend: extend33,
      substitute: substitute2
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = function() {
    return model.shaderDescriptions;
  };
  publicAPI.initialize = function(device, hash) {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    var bindGroupLayouts = [];
    for (var i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (var _i = 0; _i < model.shaderDescriptions.length; _i++) {
      var sd = model.shaderDescriptions[_i];
      var sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = function(stype) {
    for (var i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype)
        return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = function(bindGroup) {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = function(idx) {
    return model.layouts[idx].layout;
  };
  publicAPI.getBindGroupLayoutCount = function(llabel) {
    for (var i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = function(renderEncoder, vInput) {
    vInput.bindBuffers(renderEncoder);
  };
}
function extend34(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES34, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var DEFAULT_VALUES34, newInstance36, vtkWebGPUPipeline$1;
var init_Pipeline = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js"() {
    init_macros();
    DEFAULT_VALUES34 = {
      handle: null,
      layouts: null,
      renderEncoder: null,
      shaderDescriptions: null,
      vertexState: null,
      topology: null,
      pipelineDescription: null
    };
    newInstance36 = newInstance(extend34, "vtkWebGPUPipeline");
    vtkWebGPUPipeline$1 = {
      newInstance: newInstance36,
      extend: extend34
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = function(name) {
    return model.outputNames.includes(name);
  };
  publicAPI.addOutput = function(type, name) {
    var interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = function(type, name) {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = function(type, name) {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = function(priorStage, vertexInput) {
    var inputImpl = [];
    var iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      var inputStruct = [];
      inputStruct.push("struct ".concat(model.type, "Input\n{"));
      if (priorStage) {
        var inputNames = priorStage.getOutputNamesByReference();
        var inputTypes = priorStage.getOutputTypesByReference();
        var inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (var i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== void 0) {
            inputStruct.push("  @location(".concat(i, ") @interpolate(").concat(inputInterpolations[i], ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ";"));
          } else {
            inputStruct.push("  @location(".concat(i, ") ").concat(inputNames[i], " : ").concat(inputTypes[i], ";"));
          }
        }
      }
      for (var _i = 0; _i < model.builtinInputNames.length; _i++) {
        inputStruct.push("  ".concat(model.builtinInputNames[_i], " : ").concat(model.builtinInputTypes[_i], ";"));
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push("input: ".concat(model.type, "Input"));
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      var outputStruct = ["struct ".concat(model.type, "Output\n{")];
      for (var _i2 = 0; _i2 < model.outputNames.length; _i2++) {
        if (model.outputInterpolations[_i2] !== void 0) {
          outputStruct.push("  @location(".concat(_i2, ") @interpolate(").concat(model.outputInterpolations[_i2], ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ";"));
        } else {
          outputStruct.push("  @location(".concat(_i2, ") ").concat(model.outputNames[_i2], " : ").concat(model.outputTypes[_i2], ";"));
        }
      }
      for (var _i3 = 0; _i3 < model.builtinOutputNames.length; _i3++) {
        outputStruct.push("  ".concat(model.builtinOutputNames[_i3], " : ").concat(model.builtinOutputTypes[_i3], ";"));
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", ["-> ".concat(model.type, "Output")]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
function extend35(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES35, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var DEFAULT_VALUES35, newInstance37, vtkWebGPUShaderDescription$1;
var init_ShaderDescription = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js"() {
    init_macros();
    init_ShaderCache();
    DEFAULT_VALUES35 = {
      type: null,
      hash: null,
      code: null,
      outputNames: null,
      outputTypes: null
    };
    newInstance37 = macro.newInstance(extend35, "vtkWebGPUShaderDescription");
    vtkWebGPUShaderDescription$1 = {
      newInstance: newInstance37,
      extend: extend35
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
function getDetailsFromTextureFormat(format) {
  if (!format || format.length < 6)
    return 0;
  if (format in textureDetails === true) {
    return textureDetails[format];
  }
  vtkErrorMacro("unknown format ".concat(format));
  return null;
}
function getByteStrideFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = format[format.length - 1];
  }
  var sizeStart = numComp === 1 ? format.length - 1 : format.length - 3;
  var num = Number(format[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro("unknown format ".concat(format));
    return 0;
  }
  var typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = format[format.length - 1];
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format) {
  if (!format || format.length < 5)
    return 0;
  var result;
  if (format[0] === "f") {
    result = "Float";
  } else if (format[0] === "s") {
    result = "Int";
  } else if (format[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  var base = format.split("x")[0];
  var num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format) {
  var dataType;
  if (format[0] === "f" || format[1] === "n") {
    dataType = "f32";
  } else if (format[0] === "s" && format[1] === "i") {
    dataType = "i32";
  } else if (format[0] === "u" && format[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro("unknown format ".concat(format));
    return void 0;
  }
  var numComp = 1;
  if (format[format.length - 2] === "x") {
    numComp = Number(format[format.length - 1]);
  }
  if (numComp === 4)
    return "vec4<".concat(dataType, ">");
  if (numComp === 3)
    return "vec3<".concat(dataType, ">");
  if (numComp === 2)
    return "vec2<".concat(dataType, ">");
  return dataType;
}
function getByteStrideFromShaderFormat(format) {
  if (!format)
    return 0;
  var numComp = 1;
  if (format.substring(0, 3) === "vec") {
    numComp = format[3];
  } else if (format.substring(0, 3) === "mat") {
    numComp = format[3] * format[5];
  }
  var typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format) {
  if (!format)
    return void 0;
  if (format.includes("f32"))
    return "Float32Array";
  if (format.includes("i32"))
    return "Int32Array";
  if (format.includes("u32"))
    return "Uint32Array";
  vtkErrorMacro("unknown format ".concat(format));
  return void 0;
}
var textureDetails, vtkWebGPUTypes;
var init_Types = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js"() {
    init_macros();
    textureDetails = {
      r8unorm: {
        numComponents: 1,
        nativeType: Uint8Array,
        stride: 1,
        elementSize: 1,
        sampleType: "float"
      },
      r8snorm: {
        numComponents: 1,
        nativeType: Int8Array,
        stride: 1,
        elementSize: 1,
        sampleType: "float"
      },
      r8uint: {
        numComponents: 1,
        nativeType: Uint8Array,
        stride: 1,
        elementSize: 1,
        sampleType: "uint"
      },
      r8sint: {
        numComponents: 1,
        nativeType: Int8Array,
        stride: 1,
        elementSize: 1,
        sampleType: "sint"
      },
      r16uint: {
        numComponents: 1,
        nativeType: Uint16Array,
        stride: 2,
        elementSize: 2,
        sampleType: "uint"
      },
      r16sint: {
        numComponents: 1,
        nativeType: Int16Array,
        stride: 2,
        elementSize: 2,
        sampleType: "sint"
      },
      r16float: {
        numComponents: 1,
        nativeType: Float32Array,
        stride: 2,
        elementSize: 2,
        sampleType: "float"
      },
      rg8unorm: {
        numComponents: 2,
        nativeType: Uint8Array,
        stride: 2,
        elementSize: 1,
        sampleType: "float"
      },
      rg8snorm: {
        numComponents: 2,
        nativeType: Int8Array,
        stride: 2,
        elementSize: 1,
        sampleType: "float"
      },
      rg8uint: {
        numComponents: 2,
        nativeType: Uint8Array,
        stride: 2,
        elementSize: 1,
        sampleType: "uint"
      },
      rg8sint: {
        numComponents: 2,
        nativeType: Int8Array,
        stride: 2,
        elementSize: 1,
        sampleType: "sint"
      },
      r32uint: {
        numComponents: 1,
        nativeType: Uint32Array,
        stride: 4,
        elementSize: 4,
        sampleType: "uint"
      },
      r32sint: {
        numComponents: 1,
        nativeType: Int32Array,
        stride: 4,
        elementSize: 4,
        sampleType: "sint"
      },
      r32float: {
        numComponents: 1,
        nativeType: Float32Array,
        stride: 4,
        elementSize: 4,
        sampleType: "unfilterable-float"
      },
      rg16uint: {
        numComponents: 2,
        nativeType: Uint16Array,
        stride: 4,
        elementSize: 2,
        sampleType: "uint"
      },
      rg16sint: {
        numComponents: 2,
        nativeType: Int16Array,
        stride: 4,
        elementSize: 2,
        sampleType: "sint"
      },
      rg16float: {
        numComponents: 2,
        nativeType: Float32Array,
        stride: 4,
        elementSize: 2,
        sampleType: "float"
      },
      rgba8unorm: {
        numComponents: 4,
        nativeType: Uint8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "float"
      },
      "rgba8unorm-srgb": {
        numComponents: 4,
        nativeType: Uint8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "float"
      },
      rgba8snorm: {
        numComponents: 4,
        nativeType: Int8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "float"
      },
      rgba8uint: {
        numComponents: 4,
        nativeType: Uint8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "uint"
      },
      rgba8sint: {
        numComponents: 4,
        nativeType: Int8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "sint"
      },
      bgra8unorm: {
        numComponents: 4,
        nativeType: Uint8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "float"
      },
      "bgra8unorm-srgb": {
        numComponents: 4,
        nativeType: Uint8Array,
        stride: 4,
        elementSize: 1,
        sampleType: "float"
      },
      rgb9e5ufloat: {
        numComponents: 4,
        nativeType: Uint32Array,
        stride: 4,
        sampleType: "float"
      },
      rgb10a2unorm: {
        numComponents: 4,
        nativeType: Uint32Array,
        stride: 4,
        sampleType: "float"
      },
      rg11b10ufloat: {
        numComponents: 4,
        nativeType: Float32Array,
        stride: 4,
        sampleType: "float"
      },
      rg32uint: {
        numComponents: 2,
        nativeType: Uint32Array,
        stride: 8,
        elementSize: 4,
        sampleType: "uint"
      },
      rg32sint: {
        numComponents: 2,
        nativeType: Int32Array,
        stride: 8,
        elementSize: 4,
        sampleType: "sint"
      },
      rg32float: {
        numComponents: 2,
        nativeType: Float32Array,
        stride: 8,
        elementSize: 4,
        sampleType: "unfilterable-float"
      },
      rgba16uint: {
        numComponents: 4,
        nativeType: Uint16Array,
        stride: 8,
        elementSize: 2,
        sampleType: "uint"
      },
      rgba16sint: {
        numComponents: 4,
        nativeType: Int16Array,
        stride: 8,
        elementSize: 2,
        sampleType: "sint"
      },
      rgba16float: {
        numComponents: 4,
        nativeType: Float32Array,
        stride: 8,
        elementSize: 2,
        sampleType: "float"
      },
      rgba32uint: {
        numComponents: 4,
        nativeType: Uint32Array,
        stride: 16,
        elementSize: 4,
        sampleType: "uint"
      },
      rgba32sint: {
        numComponents: 4,
        nativeType: Int32Array,
        stride: 16,
        elementSize: 4,
        sampleType: "sint"
      },
      rgba32float: {
        numComponents: 4,
        nativeType: Float32Array,
        stride: 16,
        elementSize: 4,
        sampleType: "unfilterable-float"
      },
      stencil8: {
        numComponents: 1,
        nativeType: Uint8Array,
        stride: 1,
        elementSize: 1,
        sampleType: "uint"
      },
      depth16unorm: {
        numComponents: 1,
        nativeType: Uint16Array,
        stride: 2,
        elementSize: 2,
        sampleType: "depth"
      },
      depth24plus: {
        numComponents: 1,
        nativeType: Uint32Array,
        stride: 4,
        elementSize: 3,
        sampleType: "depth"
      },
      "depth24plus-stencil8": {
        numComponents: 2,
        nativeType: Uint32Array,
        stride: 4,
        sampleType: "mixed"
      },
      depth32float: {
        numComponents: 1,
        nativeType: Float32Array,
        stride: 4,
        elementSize: 4,
        sampleType: "depth"
      }
    };
    vtkWebGPUTypes = {
      getDetailsFromTextureFormat,
      getByteStrideFromBufferFormat,
      getNumberOfComponentsFromBufferFormat,
      getNativeTypeFromBufferFormat,
      getShaderTypeFromBufferFormat,
      getByteStrideFromShaderFormat,
      getNativeTypeFromShaderFormat
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
function arraysEqual(a, b) {
  if (a === b)
    return true;
  if (a == null || b == null)
    return false;
  if (a.length !== b.length)
    return false;
  for (var i = 0; i < a.length; ++i) {
    if (!b.includes(a[i]))
      return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    var stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
    var names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (var i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort(function(v1, v2) {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = function(name) {
    for (var i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = function() {
    var result = "";
    var nameCount = 0;
    for (var i = 0; i < model.inputs.length; i++) {
      for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
        var arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        var type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ",\n";
        }
        result = "".concat(result, "  @location(").concat(nameCount, ") ").concat(model.inputs[i].names[nm], " : ").concat(type);
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = function() {
    var info = {};
    if (model.inputs.length) {
      var vertexBuffers = [];
      var nameCount = 0;
      for (var i = 0; i < model.inputs.length; i++) {
        var buf = model.inputs[i].buffer;
        var buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        var arrayInfo = buf.getArrayInformation();
        for (var nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = function(renderEncoder) {
    for (var i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
  };
  publicAPI.getReady = function() {
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
function extend36(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES36, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var DEFAULT_VALUES36, newInstance38, vtkWebGPUVertexInput$1;
var init_VertexInput = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js"() {
    init_macros();
    init_Types();
    DEFAULT_VALUES36 = {
      inputs: null,
      bindingDescriptions: false,
      attributeDescriptions: null
    };
    newInstance38 = newInstance(extend36, "vtkWebGPUVertexInput");
    vtkWebGPUVertexInput$1 = {
      newInstance: newInstance38,
      extend: extend36
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/MapperHelper.js
function vtkWebGPUMapperHelper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUMapperHelper");
  publicAPI.generateShaderDescriptions = function(hash, pipeline, vertexInput) {
    var vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    var fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    var sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    var scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    var re = new RegExp("//VTK::[^:]*::", "g");
    var unique = scode.match(re).filter(function(v, i2, a) {
      return a.indexOf(v) === i2;
    });
    var fnames = unique.map(function(v) {
      return "replaceShader".concat(v.substring(7, v.length - 2));
    });
    for (var i = 0; i < fnames.length; i++) {
      var fname = fnames[i];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = function(hash, pipeline, vertexInput) {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = function(hash, pipeline, vertexInput) {
    if (!model.WebGPURenderer) {
      return;
    }
    var ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = function(hash, pipeline, vertexInput) {
    var ubocode = model.bindGroup.getShaderCode(pipeline);
    var vDesc = pipeline.getShaderDescription("vertex");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    var fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = function(view) {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.renderForPipeline = function(renderEncoder) {
    var pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
  };
  publicAPI.registerToDraw = function() {
    if (model.pipeline) {
      model.WebGPURenderer.registerPipelineCallback(model.pipeline, publicAPI.renderForPipeline);
    }
  };
  publicAPI.render = function(renderEncoder, device) {
    publicAPI.build(renderEncoder, device);
    renderEncoder.setPipeline(model.pipeline);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    publicAPI.renderForPipeline(renderEncoder);
  };
  publicAPI.getBindables = function() {
    var bindables = _toConsumableArray(model.additionalBindables);
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (var t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      var samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.build = function(renderEncoder, device) {
    model.renderEncoder = renderEncoder;
    model.pipeline = device.getPipeline(model.pipelineHash);
    model.bindGroup.setBindables(publicAPI.getBindables());
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
function extend37(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES37, initialValues);
  macro.obj(publicAPI, model);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUMapperHelperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUMapperHelperVS;
  model.shaderReplacements = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUMapperHelper(publicAPI, model);
}
var vtkWebGPUMapperHelperVS, vtkWebGPUMapperHelperFS, DEFAULT_VALUES37, newInstance39, vtkWebGPUMapperHelper$1;
var init_MapperHelper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/MapperHelper.js"() {
    init_toConsumableArray();
    init_macros();
    init_BindGroup();
    init_Pipeline();
    init_ShaderCache();
    init_ShaderDescription();
    init_VertexInput();
    vtkWebGPUMapperHelperVS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(vertex)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n";
    vtkWebGPUMapperHelperFS = "\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(fragment)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
    DEFAULT_VALUES37 = {
      additionalBindables: void 0,
      bindGroup: null,
      device: null,
      fragmentShaderTemplate: null,
      numberOfInstances: 1,
      numberOfVertices: 0,
      pipelineHash: null,
      shaderReplacements: null,
      SSBO: null,
      textureViews: null,
      topology: "triangle-list",
      UBO: null,
      vertexShaderTemplate: null,
      WebGPURenderer: null
    };
    newInstance39 = macro.newInstance(extend37, "vtkWebGPUMapperHelper");
    vtkWebGPUMapperHelper$1 = {
      newInstance: newInstance39,
      extend: extend37
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  var superclassBuild = publicAPI.build;
  publicAPI.build = function(renderEncoder, device) {
    var buff = device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
    superclassBuild(renderEncoder, device);
  };
}
function extend38(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES38, initialValues);
  vtkWebGPUMapperHelper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var DEFAULT_VALUES38, newInstance40, vtkWebGPUFullScreenQuad$1;
var init_FullScreenQuad = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js"() {
    init_macros();
    init_ShaderCache();
    init_MapperHelper();
    DEFAULT_VALUES38 = {};
    newInstance40 = macro.newInstance(extend38, "vtkWebGPUFullScreenQuad");
    vtkWebGPUFullScreenQuad$1 = {
      newInstance: newInstance40,
      extend: extend38
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
var BufferUsage, PrimitiveTypes, Constants9;
var init_Constants12 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js"() {
    BufferUsage = {
      Verts: 0,
      Lines: 1,
      Triangles: 2,
      Strips: 3,
      LinesFromStrips: 4,
      LinesFromTriangles: 5,
      Points: 6,
      UniformArray: 7,
      PointArray: 8,
      NormalsFromPoints: 9,
      Texture: 10,
      RawVertex: 11,
      Storage: 12,
      CellIndex: 13
    };
    PrimitiveTypes = {
      Start: 0,
      Points: 0,
      Lines: 1,
      Triangles: 2,
      TriangleStrips: 3,
      TriangleEdges: 4,
      TriangleStripEdges: 5,
      End: 6
    };
    Constants9 = {
      BufferUsage,
      PrimitiveTypes
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
function ownKeys12(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread12(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys12(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys12(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  var byteCount = srcArrayBuffer.byteLength;
  var srcBuffer = device.createBuffer({
    size: byteCount,
    usage: GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  var arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  var encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  var commandBuffer = encoder.finish();
  var queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = function(sizeInBytes, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = function(data) {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = function(data, usage) {
    model.handle = model.device.getHandle().createBuffer({
      size: data.byteLength,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = data.byteLength;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  var _loop = function _loop2(i2) {
    publicAPI[forwarded[i2]] = function() {
      var _model$handle;
      return (_model$handle = model.handle)[forwarded[i2]].apply(_model$handle, arguments);
    };
  };
  for (var i = 0; i < forwarded.length; i++) {
    _loop(i);
  }
}
function extend39(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES39, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var forwarded, DEFAULT_VALUES39, newInstance41, vtkWebGPUBuffer$1;
var init_Buffer = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js"() {
    init_defineProperty();
    init_macros();
    init_Constants12();
    forwarded = ["getMappedRange", "mapAsync", "unmap"];
    DEFAULT_VALUES39 = {
      device: null,
      handle: null,
      sizeInBytes: 0,
      strideInBytes: 0,
      arrayInformation: null,
      usage: null,
      label: null,
      sourceTime: null
    };
    newInstance41 = macro.newInstance(extend39);
    vtkWebGPUBuffer$1 = _objectSpread12({
      newInstance: newInstance41,
      extend: extend39
    }, Constants9);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Property.js
function ownKeys13(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread13(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys13(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys13(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function notImplemented3(method) {
  return function() {
    return macro.vtkErrorMacro("vtkProperty::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = function(r, g, b) {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented3("ComputeCompositeColor");
  publicAPI.getColor = function() {
    var norm2 = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm2 = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (var i = 0; i < 3; i++) {
      model.color[i] = norm2 * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.addShaderVariable = notImplemented3("AddShaderVariable");
  publicAPI.setInterpolationToFlat = function() {
    return publicAPI.setInterpolation(Interpolation2.FLAT);
  };
  publicAPI.setInterpolationToGouraud = function() {
    return publicAPI.setInterpolation(Interpolation2.GOURAUD);
  };
  publicAPI.setInterpolationToPhong = function() {
    return publicAPI.setInterpolation(Interpolation2.PHONG);
  };
  publicAPI.getInterpolationAsString = function() {
    return macro.enumToString(Interpolation2, model.interpolation);
  };
  publicAPI.setRepresentationToWireframe = function() {
    return publicAPI.setRepresentation(Representation2.WIREFRAME);
  };
  publicAPI.setRepresentationToSurface = function() {
    return publicAPI.setRepresentation(Representation2.SURFACE);
  };
  publicAPI.setRepresentationToPoints = function() {
    return publicAPI.setRepresentation(Representation2.POINTS);
  };
  publicAPI.getRepresentationAsString = function() {
    return macro.enumToString(Representation2, model.representation);
  };
}
function extend40(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES40, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var Representation2, Interpolation2, DEFAULT_VALUES40, newInstance42, vtkProperty$1;
var init_Property = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Property.js"() {
    init_defineProperty();
    init_macros();
    init_Constants9();
    Representation2 = PropertyConst.Representation;
    Interpolation2 = PropertyConst.Interpolation;
    DEFAULT_VALUES40 = {
      color: [1, 1, 1],
      ambientColor: [1, 1, 1],
      diffuseColor: [1, 1, 1],
      specularColor: [1, 1, 1],
      edgeColor: [0, 0, 0],
      ambient: 0,
      diffuse: 1,
      specular: 0,
      specularPower: 1,
      opacity: 1,
      interpolation: Interpolation2.GOURAUD,
      representation: Representation2.SURFACE,
      edgeVisibility: false,
      backfaceCulling: false,
      frontfaceCulling: false,
      pointSize: 1,
      lineWidth: 1,
      lighting: true,
      shading: false,
      materialName: null
    };
    newInstance42 = macro.newInstance(extend40, "vtkProperty");
    vtkProperty$1 = _objectSpread13({
      newInstance: newInstance42,
      extend: extend40
    }, PropertyConst);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
function ownKeys14(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread14(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys14(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys14(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes2.Points:
      return "points";
    case PrimitiveTypes2.Lines:
      return "lines";
    case PrimitiveTypes2.Triangles:
    case PrimitiveTypes2.TriangleEdges:
      return "polys";
    case PrimitiveTypes2.TriangleStripEdges:
    case PrimitiveTypes2.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function getOutputSize(cellArray, representation, inRepName) {
  var countFunc = null;
  if (representation === Representation3.POINTS || inRepName === "points") {
    countFunc = cellCounters.anythingToPoints;
  } else if (representation === Representation3.WIREFRAME || inRepName === "lines") {
    countFunc = cellCounters["".concat(inRepName, "ToWireframe")];
  } else {
    countFunc = cellCounters["".concat(inRepName, "ToSurface")];
  }
  var array = cellArray.getData();
  var size = array.length;
  var caboCount = 0;
  for (var index = 0; index < size; ) {
    caboCount += countFunc(array[index], array);
    index += array[index] + 1;
  }
  return caboCount;
}
function packArray(cellArray, primType, representation, inArray, outputType, options) {
  var result = {
    elementCount: 0,
    blockSize: 0,
    stride: 0
  };
  if (!cellArray.getData() || !cellArray.getData().length) {
    return result;
  }
  var shift = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  var scale = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale = options.scale;
    } else {
      scale.fill(options.scale);
    }
  }
  var packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  var pointData = inArray.getData();
  var addAPoint;
  var cellBuilders = {
    anythingToPoints: function anythingToPoints2(numPoints2, cellPts, offset, cellId2) {
      for (var i = 0; i < numPoints2; ++i) {
        addAPoint(cellPts[offset + i], cellId2);
      }
    },
    linesToWireframe: function linesToWireframe2(numPoints2, cellPts, offset, cellId2) {
      for (var i = 0; i < numPoints2 - 1; ++i) {
        addAPoint(cellPts[offset + i], cellId2);
        addAPoint(cellPts[offset + i + 1], cellId2);
      }
    },
    polysToWireframe: function polysToWireframe2(numPoints2, cellPts, offset, cellId2) {
      if (numPoints2 > 2) {
        for (var i = 0; i < numPoints2; ++i) {
          addAPoint(cellPts[offset + i], cellId2);
          addAPoint(cellPts[offset + (i + 1) % numPoints2], cellId2);
        }
      }
    },
    stripsToWireframe: function stripsToWireframe2(numPoints2, cellPts, offset, cellId2) {
      if (numPoints2 > 2) {
        for (var i = 0; i < numPoints2 - 1; ++i) {
          addAPoint(cellPts[offset + i], cellId2);
          addAPoint(cellPts[offset + i + 1], cellId2);
        }
        for (var _i = 0; _i < numPoints2 - 2; _i++) {
          addAPoint(cellPts[offset + _i], cellId2);
          addAPoint(cellPts[offset + _i + 2], cellId2);
        }
      }
    },
    polysToSurface: function polysToSurface2(npts, cellPts, offset, cellId2) {
      for (var i = 0; i < npts - 2; i++) {
        addAPoint(cellPts[offset + 0], cellId2);
        addAPoint(cellPts[offset + i + 1], cellId2);
        addAPoint(cellPts[offset + i + 2], cellId2);
      }
    },
    stripsToSurface: function stripsToSurface2(npts, cellPts, offset, cellId2) {
      for (var i = 0; i < npts - 2; i++) {
        addAPoint(cellPts[offset + i], cellId2);
        addAPoint(cellPts[offset + i + 1 + i % 2], cellId2);
        addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellId2);
      }
    }
  };
  var inRepName = getPrimitiveName(primType);
  var func = null;
  if (representation === Representation3.POINTS || primType === PrimitiveTypes2.Points) {
    func = cellBuilders.anythingToPoints;
  } else if (representation === Representation3.WIREFRAME || primType === PrimitiveTypes2.Lines) {
    func = cellBuilders["".concat(inRepName, "ToWireframe")];
  } else {
    func = cellBuilders["".concat(inRepName, "ToSurface")];
  }
  var array = cellArray.getData();
  var size = array.length;
  var caboCount = getOutputSize(cellArray, representation, inRepName);
  var vboidx = 0;
  var numComp = inArray.getNumberOfComponents();
  var packedVBO = newTypedArray(outputType, caboCount * (numComp + (packExtra ? 1 : 0)));
  var getData = function getData2(ptId, cellId2) {
    return pointData[ptId];
  };
  if (options.cellData) {
    getData = function getData2(ptId, cellId2) {
      return pointData[cellId2];
    };
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i, cellid) {
      packedVBO[vboidx++] = scale[0] * getData(i, cellid) + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i, cellid) {
      packedVBO[vboidx++] = scale[0] * getData(i * 2, cellid * 2) + shift[0];
      packedVBO[vboidx++] = scale[1] * getData(i * 2 + 1, cellid * 2 + 1) + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i, cellid) {
      packedVBO[vboidx++] = scale[0] * getData(i * 3, cellid * 3) + shift[0];
      packedVBO[vboidx++] = scale[1] * getData(i * 3 + 1, cellid * 3 + 1) + shift[1];
      packedVBO[vboidx++] = scale[2] * getData(i * 3 + 2, cellid * 3 + 2) + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i, cellid) {
      packedVBO[vboidx++] = scale[0] * getData(i * 3, cellid * 3) + shift[0];
      packedVBO[vboidx++] = scale[1] * getData(i * 3 + 1, cellid * 3 + 1) + shift[1];
      packedVBO[vboidx++] = scale[2] * getData(i * 3 + 2, cellid * 3 + 2) + shift[2];
      packedVBO[vboidx++] = scale[3] * 1 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i, cellid) {
      packedVBO[vboidx++] = scale[0] * getData(i * 4, cellid * 4) + shift[0];
      packedVBO[vboidx++] = scale[1] * getData(i * 4 + 1, cellid * 4 + 1) + shift[1];
      packedVBO[vboidx++] = scale[2] * getData(i * 4 + 2, cellid * 4 + 2) + shift[2];
      packedVBO[vboidx++] = scale[3] * getData(i * 4 + 3, cellid * 4 + 3) + shift[3];
    };
  }
  var cellId = options.cellOffset;
  for (var index = 0; index < size; ) {
    func(array[index], array, index + 1, cellId);
    index += array[index] + 1;
    cellId++;
  }
  result.nativeArray = packedVBO;
  result.elementCount = caboCount;
  return result;
}
function getNormal(pointData, i0, i1, i2) {
  var v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  var v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  var result = [];
  cross(v1, v2, result);
  normalize(result);
  return result;
}
function generateNormals(cellArray, primType, representation, inArray) {
  if (!cellArray.getData() || !cellArray.getData().length) {
    return null;
  }
  var pointData = inArray.getData();
  var addAPoint;
  var cellBuilders = {
    polysToPoints: function polysToPoints(numPoints2, cellPts, offset) {
      var normal = getNormal(pointData, cellPts[offset], cellPts[offset + 1], cellPts[offset + 2]);
      for (var i = 0; i < numPoints2; ++i) {
        addAPoint(normal);
      }
    },
    polysToWireframe: function polysToWireframe2(numPoints2, cellPts, offset) {
      var normal = getNormal(pointData, cellPts[offset], cellPts[offset + 1], cellPts[offset + 2]);
      for (var i = 0; i < numPoints2; ++i) {
        addAPoint(normal);
        addAPoint(normal);
      }
    },
    polysToSurface: function polysToSurface2(npts, cellPts, offset) {
      if (npts < 3) {
        vtkDebugMacro8("skipping degenerate triangle");
      } else {
        var normal = getNormal(pointData, cellPts[offset], cellPts[offset + 1], cellPts[offset + 2]);
        for (var i = 0; i < npts - 2; i++) {
          addAPoint(normal);
          addAPoint(normal);
          addAPoint(normal);
        }
      }
    }
  };
  var primName = getPrimitiveName(primType);
  var func = null;
  if (representation === Representation3.POINTS) {
    func = cellBuilders["".concat(primName, "ToPoints")];
  } else if (representation === Representation3.WIREFRAME) {
    func = cellBuilders["".concat(primName, "ToWireframe")];
  } else {
    func = cellBuilders["".concat(primName, "ToSurface")];
  }
  var caboCount = getOutputSize(cellArray, representation, primName);
  var vboidx = 0;
  var packedVBO = new Int8Array(caboCount * 4);
  addAPoint = function addAPointFunc(normal) {
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
  };
  var array = cellArray.getData();
  var size = array.length;
  for (var index = 0; index < size; ) {
    func(array[index], array, index + 1);
    index += array[index] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    var buffer = vtkWebGPUBuffer$1.newInstance({
      label: req.label
    });
    buffer.setDevice(model.device);
    var gpuUsage = null;
    if (req.usage === BufferUsage2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      var result = packArray(req.cells, req.primitiveType, req.representation, req.dataArray, arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    if (req.usage === BufferUsage2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      var normals = generateNormals(req.cells, req.primitiveType, req.representation, req.dataArray);
      buffer.createAndWrite(normals, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    if (req.usage === BufferUsage2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = function(req) {
    if (req.owner) {
      var hash = req.time + req.format + req.usage + req.hash;
      return model.device.hasCachedObject(req.owner, hash);
    }
    return false;
  };
  publicAPI.getBuffer = function(req) {
    if (req.owner) {
      var hash = req.time + req.format + req.usage + req.hash;
      return model.device.getCachedObject(req.owner, hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getFullScreenQuadBuffer = function() {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    var array = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
function extend41(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES41, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var BufferUsage2, PrimitiveTypes2, Representation3, vtkDebugMacro8, STATIC5, cellCounters, DEFAULT_VALUES41, newInstance43, vtkWebGPUBufferManager$1;
var init_BufferManager = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js"() {
    init_defineProperty();
    init_macros();
    init_Math();
    init_Buffer();
    init_Types();
    init_Property();
    init_Constants12();
    BufferUsage2 = Constants9.BufferUsage;
    PrimitiveTypes2 = Constants9.PrimitiveTypes;
    Representation3 = vtkProperty$1.Representation;
    vtkDebugMacro8 = vtkDebugMacro;
    STATIC5 = {};
    cellCounters = {
      anythingToPoints: function anythingToPoints(numPoints2, cellPts) {
        return numPoints2;
      },
      linesToWireframe: function linesToWireframe(numPoints2, cellPts) {
        if (numPoints2 > 1) {
          return (numPoints2 - 1) * 2;
        }
        return 0;
      },
      polysToWireframe: function polysToWireframe(numPoints2, cellPts) {
        if (numPoints2 > 2) {
          return numPoints2 * 2;
        }
        return 0;
      },
      stripsToWireframe: function stripsToWireframe(numPoints2, cellPts) {
        if (numPoints2 > 2) {
          return numPoints2 * 4 - 6;
        }
        return 0;
      },
      polysToSurface: function polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface: function stripsToSurface(npts, cellPts, offset) {
        if (numPoints > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    DEFAULT_VALUES41 = {
      device: null,
      fullScreenQuadBuffer: null
    };
    newInstance43 = newInstance(extend41);
    vtkWebGPUBufferManager$1 = _objectSpread14(_objectSpread14({
      newInstance: newInstance43,
      extend: extend41
    }, STATIC5), Constants9);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro14("entry named ".concat(name, " already exists"));
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = function() {
    if (!model.sortDirty) {
      return;
    }
    var currOffset = 0;
    var newEntries = [];
    var maxAlignment = 4;
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (var _i = 0; _i < model.bufferEntries.length; _i++) {
      var _entry = model.bufferEntries[_i];
      if (_entry.packed === false && _entry.sizeInBytes % 16 === 0) {
        _entry.packed = true;
        _entry.offset = currOffset;
        newEntries.push(_entry);
        currOffset += _entry.sizeInBytes;
      }
    }
    for (var _i2 = 0; _i2 < model.bufferEntries.length; _i2++) {
      var _entry2 = model.bufferEntries[_i2];
      if (_entry2.packed === false && _entry2.sizeInBytes === 12) {
        for (var i2 = 0; i2 < model.bufferEntries.length; i2++) {
          var entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            _entry2.packed = true;
            _entry2.offset = currOffset;
            newEntries.push(_entry2);
            currOffset += _entry2.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i3 = 0; _i3 < model.bufferEntries.length; _i3++) {
      var _entry3 = model.bufferEntries[_i3];
      if (!_entry3.packed && _entry3.sizeInBytes % 8 === 0) {
        for (var _i4 = _i3 + 1; _i4 < model.bufferEntries.length; _i4++) {
          var _entry4 = model.bufferEntries[_i4];
          if (!_entry4.packed && _entry4.sizeInBytes % 8 === 0) {
            _entry3.packed = true;
            _entry3.offset = currOffset;
            newEntries.push(_entry3);
            currOffset += _entry3.sizeInBytes;
            _entry4.packed = true;
            _entry4.offset = currOffset;
            newEntries.push(_entry4);
            currOffset += _entry4.sizeInBytes;
            break;
          }
        }
      }
    }
    for (var _i5 = 0; _i5 < model.bufferEntries.length; _i5++) {
      var _entry5 = model.bufferEntries[_i5];
      if (!_entry5.packed && _entry5.sizeInBytes % 8 === 0) {
        var found = false;
        for (var _i6 = 0; !found && _i6 < model.bufferEntries.length; _i6++) {
          var _entry6 = model.bufferEntries[_i6];
          if (!_entry6.packed && _entry6.sizeInBytes === 4) {
            for (var i3 = _i6 + 1; i3 < model.bufferEntries.length; i3++) {
              var entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                _entry5.packed = true;
                _entry5.offset = currOffset;
                newEntries.push(_entry5);
                currOffset += _entry5.sizeInBytes;
                _entry6.packed = true;
                _entry6.offset = currOffset;
                newEntries.push(_entry6);
                currOffset += _entry6.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (var _i7 = 0; _i7 < model.bufferEntries.length; _i7++) {
      var _entry7 = model.bufferEntries[_i7];
      if (!_entry7.packed && _entry7.sizeInBytes > 4) {
        _entry7.packed = true;
        _entry7.offset = currOffset;
        newEntries.push(_entry7);
        currOffset += _entry7.sizeInBytes;
      }
    }
    for (var _i8 = 0; _i8 < model.bufferEntries.length; _i8++) {
      var _entry8 = model.bufferEntries[_i8];
      if (!_entry8.packed) {
        _entry8.packed = true;
        _entry8.offset = currOffset;
        newEntries.push(_entry8);
        currOffset += _entry8.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (var _i9 = 0; _i9 < model.bufferEntries.length; _i9++) {
      model._bufferEntryNames.set(model.bufferEntries[_i9].name, _i9);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = function(device) {
    if (!model.UBO) {
      var req = {
        nativeArray: model.Float32Array,
        time: 0,
        usage: BufferUsage3.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, val) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro14("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = function(name, arr) {
    publicAPI.sortBufferEntries();
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro14("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var changed = false;
    for (var i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = _toConsumableArray(arr);
    }
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = function() {
    return model.sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding, group) {
    publicAPI.sortBufferEntries();
    var lines = ["struct ".concat(model.label, "Struct\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ";"));
    }
    lines.push("};\n@binding(".concat(binding, ") @group(").concat(group, ") var<uniform> ").concat(model.label, ": ").concat(model.label, "Struct;"));
    return lines.join("\n");
  };
}
function extend42(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES42, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var BufferUsage3, vtkErrorMacro14, DEFAULT_VALUES42, newInstance44, vtkWebGPUUniformBuffer$1;
var init_UniformBuffer = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js"() {
    init_toConsumableArray();
    init_macros();
    init_BufferManager();
    init_Types();
    BufferUsage3 = vtkWebGPUBufferManager$1.BufferUsage;
    vtkErrorMacro14 = macro.vtkErrorMacro;
    DEFAULT_VALUES42 = {
      bufferEntries: null,
      bufferEntryNames: null,
      sizeInBytes: 0,
      label: null,
      bindGroupLayoutEntry: null,
      bindGroupEntry: null
    };
    newInstance44 = macro.newInstance(extend42, "vtkWebGPUUniformBuffer");
    vtkWebGPUUniformBuffer$1 = {
      newInstance: newInstance44,
      extend: extend42
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = function() {
    var clipRange = model.camera.getClippingRange();
    var pos = model.camera.getPositionByReference();
    var dop = model.camera.getDirectionOfProjectionByReference();
    var center = [];
    var offset = [];
    vec3_exports.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    vec3_exports.add(center, pos, offset);
    vec3_exports.sub(offset, center, model.stabilizedCenter);
    var length = vec3_exports.len(offset);
    if (length / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = function() {
    var count = 0;
    var lights = model.renderable.getLightsByReference();
    for (var index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0) {
        count++;
      }
    }
    if (!count) {
      vtkDebugMacro9("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count;
  };
  publicAPI.registerPipelineCallback = function(pipeline, cb) {
    for (var i = 0; i < model.pipelineCallbacks.length; i++) {
      if (model.pipelineCallbacks[i].pipeline === pipeline) {
        model.pipelineCallbacks[i].callbacks.push(cb);
        return;
      }
    }
    model.pipelineCallbacks.push({
      pipeline,
      callbacks: [cb]
    });
  };
  publicAPI.updateUBO = function() {
    var utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      var keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      var tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      var device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.scissorAndViewport = function(encoder) {
    var tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = function(renderEncoder) {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      model.pipelineCallbacks = [];
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      for (var i = 0; i < model.pipelineCallbacks.length; i++) {
        var pStruct = model.pipelineCallbacks[i];
        var pl = pStruct.pipeline;
        model.renderEncoder.setPipeline(pl);
        publicAPI.bindUBO(model.renderEncoder);
        for (var cb = 0; cb < pStruct.callbacks.length; cb++) {
          pStruct.callbacks[cb](model.renderEncoder);
        }
      }
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = function() {
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    var device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragTemplate);
      var ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
    }
    var background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.render(model.renderEncoder, device);
  };
  publicAPI.translucentPass = function(prepass) {
    if (prepass) {
      model.pipelineCallbacks = [];
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      for (var i = 0; i < model.pipelineCallbacks.length; i++) {
        var pStruct = model.pipelineCallbacks[i];
        var pl = pStruct.pipeline;
        model.renderEncoder.setPipeline(pl);
        publicAPI.bindUBO(model.renderEncoder);
        for (var cb = 0; cb < pStruct.callbacks.length; cb++) {
          pStruct.callbacks[cb](model.renderEncoder);
        }
      }
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = function(prepass) {
    if (prepass) {
      model.pipelineCallbacks = [];
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      for (var i = 0; i < model.pipelineCallbacks.length; i++) {
        var pStruct = model.pipelineCallbacks[i];
        var pl = pStruct.pipeline;
        model.renderEncoder.setPipeline(pl);
        publicAPI.bindUBO(model.renderEncoder);
        for (var cb = 0; cb < pStruct.callbacks.length; cb++) {
          pStruct.callbacks[cb](model.renderEncoder);
        }
      }
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = function() {
    var size = model._parent.getSizeByReference();
    var viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = function(val) {
    return model.webgpuCamera.convertToOpenGLDepth(val);
  };
  publicAPI.getYInvertedTiledSizeAndOrigin = function() {
    var res = publicAPI.getTiledSizeAndOrigin();
    var size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = function() {
    var vport = model.renderable.getViewportByReference();
    var tileViewPort = [0, 0, 1, 1];
    var vpu = vport[0] - tileViewPort[0];
    var vpv = vport[1] - tileViewPort[1];
    var ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    var lowerLeftU = Math.round(ndvp[0]);
    var lowerLeftV = Math.round(ndvp[1]);
    var vpu2 = vport[2] - tileViewPort[0];
    var vpv2 = vport[3] - tileViewPort[1];
    var ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    var usize = Math.round(ndvp2[0]) - lowerLeftU;
    var vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = function(id) {
    for (var i = 0; i < model.children.length; i++) {
      var res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = function() {
    return model.stabilizedTime.getMTime();
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
function extend43(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES43, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("cameraParallel", "u32");
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO]);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var vtkDebugMacro9, clearFragTemplate, DEFAULT_VALUES43, newInstance45;
var init_Renderer2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_BindGroup();
    init_FullScreenQuad();
    init_UniformBuffer();
    init_ViewNodeFactory3();
    vtkDebugMacro9 = vtkDebugMacro;
    clearFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(fragment)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n";
    DEFAULT_VALUES43 = {
      bindGroup: null,
      selector: null,
      renderEncoder: null,
      recenterThreshold: 20,
      suppressClear: false,
      stabilizedCenter: [0, 0, 0]
    };
    newInstance45 = newInstance(extend43, "vtkWebGPURenderer");
    registerOverride2("vtkRenderer", newInstance45);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = function(name, type) {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro15("entry named ".concat(name, " already exists"));
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    var sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = function(device) {
    if (!model._buffer) {
      var req = {
        nativeArray: model.Float32Array,
        time: 0,
        usage: BufferUsage4.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = function(type) {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = function(name, instance, val) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro15("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = function(name, instance, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro15("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (var i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro15("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro15("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = arr.length / model.numberOfInstances;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = function(name, arr) {
    var idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro15("entry named ".concat(name, " not found in UBO"));
      return;
    }
    var entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    var view = model[entry.nativeType];
    var numComponents = 9;
    for (var inst = 0; inst < model.numberOfInstances; inst++) {
      var ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (var j = 0; j < 3; j++) {
        for (var i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = function() {
    return model._sendTime.getMTime();
  };
  publicAPI.getShaderCode = function(binding, group) {
    var lines = ["struct ".concat(model.label, "StructEntry\n{")];
    for (var i = 0; i < model.bufferEntries.length; i++) {
      var entry = model.bufferEntries[i];
      lines.push("  ".concat(entry.name, ": ").concat(entry.type, ";"));
    }
    lines.push("\n};\nstruct ".concat(model.label, "Struct\n{\n  values: array<").concat(model.label, "StructEntry>;\n};\n@binding(").concat(binding, ") @group(").concat(group, ") var<storage, read> ").concat(model.label, ": ").concat(model.label, "Struct;\n"));
    return lines.join("\n");
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = function() {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
function extend44(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES44, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var BufferUsage4, vtkErrorMacro15, DEFAULT_VALUES44, newInstance46, vtkWebGPUStorageBuffer$1;
var init_StorageBuffer = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js"() {
    init_macros();
    init_BufferManager();
    init_Types();
    BufferUsage4 = vtkWebGPUBufferManager$1.BufferUsage;
    vtkErrorMacro15 = macro.vtkErrorMacro;
    DEFAULT_VALUES44 = {
      bufferEntries: null,
      bufferEntryNames: null,
      sizeInBytes: 0,
      label: null,
      numberOfInstances: 1
    };
    newInstance46 = macro.newInstance(extend44, "vtkWebGPUStorageBuffer");
    vtkWebGPUStorageBuffer$1 = {
      newInstance: newInstance46,
      extend: extend44
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.device = device;
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = function(binding, group) {
    var result = "@binding(".concat(binding, ") @group(").concat(group, ") var ").concat(model.label, ": sampler;");
    return result;
  };
  publicAPI.getBindGroupEntry = function() {
    var foo = {
      resource: model.handle
    };
    return foo;
  };
}
function extend45(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES45, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    sampler: {}
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var DEFAULT_VALUES45, newInstance47, vtkWebGPUSampler$1;
var init_Sampler = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js"() {
    init_macros();
    DEFAULT_VALUES45 = {
      device: null,
      handle: null,
      label: null,
      options: null
    };
    newInstance47 = macro.newInstance(extend45);
    vtkWebGPUSampler$1 = {
      newInstance: newInstance47,
      extend: extend45
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js
function computeFnToString2(property, fn, numberOfComponents) {
  var pwfun = fn.apply(property);
  if (pwfun) {
    var iComps = property.getIndependentComponents();
    return "".concat(property.getMTime(), "-").concat(iComps, "-").concat(numberOfComponents);
  }
  return "0";
}
function vtkWebGPUImageMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.WebGPUImageSlice = publicAPI.getFirstAncestorOfType("vtkWebGPUImageSlice");
      model.WebGPURenderer = model.WebGPUImageSlice.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
      var ren = model.WebGPURenderer.getRenderable();
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };
  publicAPI.translucentPass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = function() {
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    model.renderEncoder = model.WebGPURenderer.getRenderEncoder();
    publicAPI.build(model.renderEncoder, model.device);
    publicAPI.updateUBO(model.device);
  };
  publicAPI.computePipelineHash = function() {
    var ext = model.currentInput.getExtent();
    if (ext[0] === ext[1] || ext[2] === ext[3] || ext[4] === ext[5]) {
      model.dimensions = 2;
      model.pipelineHash = "img2";
    } else {
      model.dimensions = 3;
      model.pipelineHash = "img3";
    }
  };
  publicAPI.updateUBO = function(device) {
    var utime = model.UBO.getSendTime();
    var actor = model.WebGPUImageSlice.getRenderable();
    var volMapr = actor.getMapper();
    if (publicAPI.getMTime() > utime || model.renderable.getMTime() > utime || actor.getProperty().getMTime() > utime) {
      var image = volMapr.getInputData();
      var center = model.WebGPURenderer.getStabilizedCenterByReference();
      mat4_exports.identity(tmpMat4);
      mat4_exports.translate(tmpMat4, tmpMat4, center);
      var mcwcmat = actor.getMatrix();
      mat4_exports.transpose(tmp2Mat4, mcwcmat);
      mat4_exports.invert(tmp2Mat4, tmp2Mat4);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      var modelToIndex = image.getWorldToIndex();
      mat4_exports.multiply(tmpMat4, modelToIndex, tmpMat4);
      mat4_exports.invert(tmp3Mat4, tmpMat4);
      var dims = image.getDimensions();
      mat4_exports.identity(tmp2Mat4);
      mat4_exports.scale(tmp2Mat4, tmp2Mat4, [1 / dims[0], 1 / dims[1], 1 / dims[2]]);
      mat4_exports.multiply(tmpMat4, tmp2Mat4, tmpMat4);
      model.UBO.setArray("SCTCMatrix", tmpMat4);
      var ext = model.currentInput.getExtent();
      var _model$renderable$get = model.renderable.getClosestIJKAxis(), ijkMode = _model$renderable$get.ijkMode;
      var nSlice = model.renderable.getSlice();
      if (ijkMode !== model.renderable.getSlicingMode()) {
        nSlice = model.renderable.getSliceAtPosition(nSlice);
      }
      var axis0 = 2;
      var axis1 = 0;
      var axis2 = 1;
      if (ijkMode === SlicingMode3.I) {
        axis0 = 0;
        axis1 = 1;
        axis2 = 2;
      } else if (ijkMode === SlicingMode3.J) {
        axis0 = 1;
        axis1 = 2;
        axis2 = 0;
      }
      ptsArray1[axis0] = nSlice;
      ptsArray1[axis1] = ext[axis1 * 2];
      ptsArray1[axis2] = ext[axis2 * 2];
      ptsArray1[3] = 1;
      vec4_exports.transformMat4(ptsArray1, ptsArray1, tmp3Mat4);
      model.UBO.setArray("Origin", ptsArray1);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2 + 1];
      ptsArray2[axis2] = ext[axis2 * 2];
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis1", ptsArray2);
      ptsArray2[axis0] = nSlice;
      ptsArray2[axis1] = ext[axis1 * 2];
      ptsArray2[axis2] = ext[axis2 * 2 + 1];
      ptsArray2[3] = 1;
      vec4_exports.transformMat4(ptsArray2, ptsArray2, tmp3Mat4);
      vec4_exports.subtract(ptsArray2, ptsArray2, ptsArray1);
      ptsArray2[3] = 1;
      model.UBO.setArray("Axis2", ptsArray2);
      var cScale = [1, 1, 1, 1];
      var cShift = [0, 0, 0, 0];
      var tView = model.helper.getTextureViews()[0];
      var tScale = tView.getTexture().getScale();
      var numComp = tView.getTexture().getNumberOfComponents();
      var iComps = false;
      for (var i = 0; i < numComp; i++) {
        var cw = actor.getProperty().getColorWindow();
        var cl = actor.getProperty().getColorLevel();
        var target = iComps ? i : 0;
        var cfun = actor.getProperty().getRGBTransferFunction(target);
        if (cfun && actor.getProperty().getUseLookupTableScalarRange()) {
          var cRange = cfun.getRange();
          cw = cRange[1] - cRange[0];
          cl = 0.5 * (cRange[1] + cRange[0]);
        }
        cScale[i] = tScale / cw;
        cShift[i] = -cl / cw + 0.5;
      }
      model.UBO.setArray("cScale", cScale);
      model.UBO.setArray("cShift", cShift);
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateLUTImage = function(device) {
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var tView = model.helper.getTextureViews()[0];
    tView.getTexture().getNumberOfComponents();
    var numIComps = 1;
    var cfunToString = computeFnToString2(actorProperty, actorProperty.getRGBTransferFunction, numIComps);
    if (model.colorTextureString !== cfunToString) {
      model.numRows = numIComps;
      var colorArray = new Uint8Array(model.numRows * 2 * model.rowLength * 4);
      var cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        var tmpTable = new Float32Array(model.rowLength * 3);
        for (var c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          var cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], model.rowLength, tmpTable, 1);
          {
            for (var _i = 0; _i < model.rowLength; _i++) {
              var _idx = c * model.rowLength * 8 + _i * 4;
              colorArray[_idx] = 255 * tmpTable[_i * 3];
              colorArray[_idx + 1] = 255 * tmpTable[_i * 3 + 1];
              colorArray[_idx + 2] = 255 * tmpTable[_i * 3 + 2];
              colorArray[_idx + 3] = 255;
              for (var _j = 0; _j < 4; _j++) {
                colorArray[_idx + model.rowLength * 4 + _j] = colorArray[_idx + _j];
              }
            }
          }
        }
      } else {
        for (var _i2 = 0; _i2 < model.rowLength; ++_i2) {
          var grey = 255 * _i2 / (model.rowLength - 1);
          colorArray[_i2 * 4] = grey;
          colorArray[_i2 * 4 + 1] = grey;
          colorArray[_i2 * 4 + 2] = grey;
          colorArray[_i2 * 4 + 3] = 255;
          for (var _j2 = 0; _j2 < 4; _j2++) {
            colorArray[_i2 * 4 + model.rowLength * 4 + _j2] = colorArray[_i2 * 4 + _j2];
          }
        }
      }
      {
        var treq = {
          nativeArray: colorArray,
          width: model.rowLength,
          height: model.numRows * 2,
          depth: 1,
          format: "rgba8unorm"
        };
        var newTex = device.getTextureManager().getTexture(treq);
        var tview = newTex.createView("tfunTexture");
        var tViews = model.helper.getTextureViews();
        tViews[1] = tview;
      }
      model.colorTextureString = cfunToString;
    }
  };
  publicAPI.updateBuffers = function(device) {
    var treq = {
      imageData: model.currentInput,
      owner: model.currentInput.getPointData().getScalars()
    };
    var newTex = device.getTextureManager().getTexture(treq);
    var tViews = model.helper.getTextureViews();
    if (!tViews[0] || tViews[0].getTexture() !== newTex) {
      var tview = newTex.createView("imgTexture");
      tViews[0] = tview;
    }
    publicAPI.updateLUTImage(device);
  };
  publicAPI.build = function(renderEncoder, device) {
    publicAPI.computePipelineHash();
    model.helper.setPipelineHash(model.pipelineHash);
    publicAPI.updateBuffers(device);
    var actorProperty = model.WebGPUImageSlice.getRenderable().getProperty();
    var iType = actorProperty.getInterpolationType() === InterpolationType3.NEAREST ? "nearest" : "linear";
    if (!model.clampSampler || iType !== model.clampSampler.getOptions().minFilter) {
      model.clampSampler = vtkWebGPUSampler$1.newInstance({
        label: "clampSampler"
      });
      model.clampSampler.create(device, {
        minFilter: iType,
        magFilter: iType
      });
    }
    model.helper.setAdditionalBindables(publicAPI.getBindables());
    model.helper.setWebGPURenderer(model.WebGPURenderer);
    model.helper.build(renderEncoder, device);
    model.helper.registerToDraw();
  };
  publicAPI.getBindables = function() {
    var bindables = [];
    bindables.push(model.clampSampler);
    return bindables;
  };
  var sr = model.helper.getShaderReplacements();
  publicAPI.replaceShaderPosition = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    var code = vDesc.getCode();
    var lines = ["var pos: vec4<f32> = mapperUBO.Origin +", "   (vertexBC.x * 0.5 + 0.5) * mapperUBO.Axis1 + (vertexBC.y * 0.5 + 0.5) * mapperUBO.Axis2;", "pos.w = 1.0;"];
    if (model.dimensions === 2) {
      lines.push("var tcoord : vec2<f32> = (mapperUBO.SCTCMatrix * pos).xy;");
    } else {
      lines.push("var tcoord : vec3<f32> = (mapperUBO.SCTCMatrix * pos).xyz;");
    }
    lines.push("output.tcoordVS = tcoord;", "output.Position = rendererUBO.SCPCMatrix * pos;");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", lines).result;
    vDesc.setCode(code);
  };
  sr.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = function(hash, pipeline, vertexInput) {
    var vDesc = pipeline.getShaderDescription("vertex");
    if (model.dimensions === 2) {
      vDesc.addOutput("vec2<f32>", "tcoordVS");
    } else {
      vDesc.addOutput("vec3<f32>", "tcoordVS");
    }
  };
  sr.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderImage = function(hash, pipeline, vertexInput) {
    var fDesc = pipeline.getShaderDescription("fragment");
    var code = fDesc.getCode();
    if (model.dimensions === 3) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var computedColor: vec4<f32> =", "      textureSampleLevel(imgTexture, clampSampler, input.tcoordVS, 0.0);", "//VTK::Image::Sample"]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Image::Sample", ["    var coord: vec2<f32> =", "      vec2<f32>(computedColor.r * mapperUBO.cScale.r + mapperUBO.cShift.r, 0.5);", "    computedColor = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);"]).result;
    fDesc.setCode(code);
  };
  sr.set("replaceShaderImage", publicAPI.replaceShaderImage);
}
function extend46(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES46, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.helper = vtkWebGPUFullScreenQuad$1.newInstance();
  model.helper.setFragmentShaderTemplate(imgFragTemplate);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("SCTCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("Origin", "vec4<f32>");
  model.UBO.addEntry("Axis2", "vec4<f32>");
  model.UBO.addEntry("Axis1", "vec4<f32>");
  model.UBO.addEntry("cScale", "vec4<f32>");
  model.UBO.addEntry("cShift", "vec4<f32>");
  model.helper.setUBO(model.UBO);
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "volumeSSBO"
  });
  model.componentSSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "componentSSBO"
  });
  model.lutBuildTime = {};
  obj(model.lutBuildTime, {
    mtime: 0
  });
  model.imagemat = mat4_exports.identity(new Float64Array(16));
  model.imagematinv = mat4_exports.identity(new Float64Array(16));
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime);
  vtkWebGPUImageMapper(publicAPI, model);
}
var SlicingMode3, imgFragTemplate, tmpMat4, tmp2Mat4, tmp3Mat4, ptsArray1, ptsArray2, DEFAULT_VALUES46, newInstance48;
var init_ImageMapper2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageMapper.js"() {
    init_esm();
    init_Constants7();
    init_macros();
    init_ShaderCache();
    init_StorageBuffer();
    init_FullScreenQuad();
    init_UniformBuffer();
    init_Sampler();
    init_ViewNode();
    init_Constants11();
    init_ViewNodeFactory3();
    SlicingMode3 = Constants6.SlicingMode;
    imgFragTemplate = "\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Image::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@stage(fragment)\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  //VTK::Image::Sample\n\n  // var computedColor: vec4<f32> = vec4<f32>(1.0,0.7, 0.5, 1.0);\n\n//VTK::RenderEncoder::Impl\n\n  return output;\n}\n";
    tmpMat4 = new Float64Array(16);
    tmp2Mat4 = new Float64Array(16);
    tmp3Mat4 = new Float64Array(16);
    ptsArray1 = new Float64Array(4);
    ptsArray2 = new Float64Array(4);
    DEFAULT_VALUES46 = {
      rowLength: 1024
    };
    newInstance48 = newInstance(extend46, "vtkWebGPUImageMapper");
    registerOverride2("vtkImageMapper", newInstance48);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js
function vtkWebGPUImageSlice(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUImageSlice");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children.forEach(function(child) {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = function(wgpuRen) {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      model.bufferShift[0] = mcwc[3] - center[0];
      model.bufferShift[1] = mcwc[7] - center[1];
      model.bufferShift[2] = mcwc[11] - center[2];
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
function extend47(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES47, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  model.bufferShift = [0, 0, 0, 0];
  get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUImageSlice(publicAPI, model);
}
var DEFAULT_VALUES47, newInstance49;
var init_ImageSlice2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/ImageSlice.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory3();
    DEFAULT_VALUES47 = {
      bufferShift: void 0,
      keyMatrixTime: null,
      keyMatrices: null,
      propID: void 0
    };
    newInstance49 = newInstance(extend47, "vtkWebGPUImageSlice");
    registerOverride2("vtkImageSlice", newInstance49);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js
function vtkWebGPUVolume(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVolume");
  publicAPI.buildPass = function(prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      model.renderable.getMapper().update();
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      var bds = model.renderable.getMapper().getBounds();
      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }
      renderPass.addVolume(publicAPI);
    }
  };
  var idx = new Float64Array(3);
  var vout = new Float64Array(3);
  publicAPI.getBoundingCubePoints = function(result, offset) {
    var input = model.renderable.getMapper().getInputData();
    if (!input) {
      return;
    }
    var extent = input.getExtent();
    var m = model.renderable.getMatrix();
    var count = 0;
    for (var iz = 4; iz < 6; iz++) {
      idx[2] = extent[iz];
      for (var iy = 2; iy < 4; iy++) {
        idx[1] = extent[iy];
        for (var ix = 0; ix < 2; ix++) {
          idx[0] = extent[ix];
          input.indexToWorld(idx, vout);
          var poffset = offset + count * 3;
          result[poffset++] = m[0] * vout[0] + m[1] * vout[1] + m[2] * vout[2] + m[3];
          result[poffset++] = m[4] * vout[0] + m[5] * vout[1] + m[6] * vout[2] + m[7];
          result[poffset++] = m[8] * vout[0] + m[9] * vout[1] + m[10] * vout[2] + m[11];
          count++;
        }
      }
    }
  };
  publicAPI.traverseVolumePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.getKeyMatrices = function(wgpuRen) {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix();
      var center = wgpuRen.getStabilizedCenterByReference();
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
function extend48(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES48, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  vtkWebGPUVolume(publicAPI, model);
}
var DEFAULT_VALUES48, newInstance50;
var init_Volume3 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/Volume.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory3();
    DEFAULT_VALUES48 = {
      propID: void 0,
      keyMatricesTime: null
    };
    newInstance50 = macro.newInstance(extend48, "vtkWebGPUVolume");
    registerOverride2("vtkVolume", newInstance50);
  }
});

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = function(prepass, renderPass) {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    var aspectRatio = model.WebGPURenderer.getAspectRatio();
    var camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    var tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    var texels = null;
    if (model.renderable.getUseZValues())
      ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
function extend49(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES49, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var DEFAULT_VALUES49, newInstance51;
var init_PixelSpaceCallbackMapper2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js"() {
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory3();
    DEFAULT_VALUES49 = {};
    newInstance51 = macro.newInstance(extend49, "vtkWebGPUPixelSpaceCallbackMapper");
    registerOverride2("vtkPixelSpaceCallbackMapper", newInstance51);
  }
});

// node_modules/@kitware/vtk.js/Rendering/Profiles/Volume.js
var Volume_exports3 = {};
var init_Volume4 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Profiles/Volume.js"() {
    init_Camera2();
    init_Renderer();
    init_ImageMapper();
    init_ImageSlice();
    init_Volume2();
    init_VolumeMapper();
    init_PixelSpaceCallbackMapper();
    init_Camera3();
    init_Renderer2();
    init_ImageMapper2();
    init_ImageSlice2();
    init_Volume3();
    init_PixelSpaceCallbackMapper2();
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  var superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map(function(item) {
      return {
        data: vtk(item.data)
      };
    });
  }
  publicAPI.initialize = function() {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = function() {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = function(other) {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map(function(x) {
      return x;
    });
    model.arrays = other.arrays().map(function(x) {
      return {
        array: x
      };
    });
  };
  publicAPI.getNumberOfArrays = function() {
    return model.arrays.length;
  };
  publicAPI.getNumberOfActiveArrays = function() {
    return model.arrays.length;
  };
  publicAPI.addArray = function(arr) {
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry) {
      return arrayName !== entry.data.getName();
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
  };
  publicAPI.getArrays = function() {
    return model.arrays.map(function(entry) {
      return entry.data;
    });
  };
  publicAPI.getArray = function(arraySpec) {
    return typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  };
  publicAPI.getArrayByName = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data.getName() === arrayName ? b.data : a;
    }, null);
  };
  publicAPI.getArrayWithIndex = function(arrayName) {
    return model.arrays.reduce(function(a, b, i) {
      return b.data && b.data.getName() === arrayName ? {
        array: b.data,
        index: i
      } : a;
    }, {
      array: null,
      index: -1
    });
  };
  publicAPI.getArrayByIndex = function(idx) {
    return idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  };
  publicAPI.hasArray = function(arrayName) {
    return publicAPI.getArrayWithIndex(arrayName).index >= 0;
  };
  publicAPI.getArrayName = function(idx) {
    var arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = function() {
    return model.copyFieldFlags;
  };
  publicAPI.getFlag = function(arrayName) {
    return model.copyFieldFlags[arrayName];
  };
  publicAPI.passData = function(other) {
    var fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    var toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach(function(arr) {
      var copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        var destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
          } else {
            var ncomps = arr.getNumberOfComponents();
            var newSize = arr.getNumberOfValues();
            var tId = toId > -1 ? toId : fromId;
            if (newSize < tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: arr.getNumberOfComponents(),
              size: newSize
            });
            destArr.setTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            var _tId = toId > -1 ? toId : fromId;
            destArr.setTuple(_tId, arr.getTuple(fromId));
          } else {
            for (var i = 0; i < arr.getNumberOfTuples(); ++i) {
              destArr.setTuple(i, arr.getTuple(i));
            }
          }
        }
      }
    });
  };
  publicAPI.copyFieldOn = function(arrayName) {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = function(arrayName) {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = function() {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = function() {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = function() {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = function(other) {
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = function(other) {
    return other.getCopyFieldFlags().map(function(x) {
      return x;
    });
  };
  publicAPI.reset = function() {
    return model.arrays.forEach(function(entry) {
      return entry.data.reset();
    });
  };
  publicAPI.getMTime = function() {
    return model.arrays.reduce(function(a, b) {
      return b.data.getMTime() > a ? b.data.getMTime() : a;
    }, model.mtime);
  };
  publicAPI.getNumberOfComponents = function() {
    return model.arrays.reduce(function(a, b) {
      return a + b.data.getNumberOfComponents();
    }, 0);
  };
  publicAPI.getNumberOfTuples = function() {
    return model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  };
  publicAPI.getState = function() {
    var result = superGetState();
    if (result) {
      result.arrays = model.arrays.map(function(item) {
        return {
          data: item.data.getState()
        };
      });
    }
    return result;
  };
}
function extend50(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES50, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var DEFAULT_VALUES50, newInstance52, vtkFieldData$1;
var init_FieldData = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js"() {
    init_vtk();
    init_macros();
    init_DataArray();
    DEFAULT_VALUES50 = {
      arrays: [],
      copyFieldFlags: [],
      doCopyAllOn: true,
      doCopyAllOff: false
    };
    newInstance52 = macro.newInstance(extend50, "vtkFieldData");
    vtkFieldData$1 = {
      newInstance: newInstance52,
      extend: extend50
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes, AttributeLimitTypes, CellGhostTypes, PointGhostTypes, AttributeCopyOperations, ghostArrayName, DesiredOutputPrecision, Constants10;
var init_Constants13 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js"() {
    AttributeTypes = {
      SCALARS: 0,
      VECTORS: 1,
      NORMALS: 2,
      TCOORDS: 3,
      TENSORS: 4,
      GLOBALIDS: 5,
      PEDIGREEIDS: 6,
      EDGEFLAG: 7,
      NUM_ATTRIBUTES: 8
    };
    AttributeLimitTypes = {
      MAX: 0,
      EXACT: 1,
      NOLIMIT: 2
    };
    CellGhostTypes = {
      DUPLICATECELL: 1,
      HIGHCONNECTIVITYCELL: 2,
      LOWCONNECTIVITYCELL: 4,
      REFINEDCELL: 8,
      EXTERIORCELL: 16,
      HIDDENCELL: 32
    };
    PointGhostTypes = {
      DUPLICATEPOINT: 1,
      HIDDENPOINT: 2
    };
    AttributeCopyOperations = {
      COPYTUPLE: 0,
      INTERPOLATE: 1,
      PASSDATA: 2,
      ALLCOPY: 3
    };
    ghostArrayName = "vtkGhostType";
    DesiredOutputPrecision = {
      DEFAULT: 0,
      SINGLE: 1,
      DOUBLE: 2
    };
    Constants10 = {
      AttributeCopyOperations,
      AttributeLimitTypes,
      AttributeTypes,
      CellGhostTypes,
      DesiredOutputPrecision,
      PointGhostTypes,
      ghostArrayName
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
function ownKeys15(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread15(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys15(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys15(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkDataSetAttributes(publicAPI, model) {
  var attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    var cleanAttType = attrTypes.find(function(ee) {
      return AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase();
    });
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  publicAPI.checkNumberOfComponents = function(x) {
    return true;
  };
  publicAPI.setAttribute = function(arr, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro6("Cannot set attribute ".concat(attType, ". The attribute must be a vtkDataArray."));
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro6("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
      return -1;
    }
    var currentAttribute = model["active".concat(attType)];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model["active".concat(attType)] = currentAttribute;
    } else {
      model["active".concat(attType)] = -1;
    }
    publicAPI.modified();
    return model["active".concat(attType)];
  };
  publicAPI.setActiveAttributeByName = function(arrayName, attType) {
    return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  };
  publicAPI.setActiveAttributeByIndex = function(arrayIdx, uncleanAttType) {
    var attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        var arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro6("Cannot set attribute ".concat(attType, ". Only vtkDataArray subclasses can be set as active attributes."));
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro6("Cannot set attribute ".concat(attType, ". Incorrect number of components."));
          return -1;
        }
      }
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model["active".concat(attType)] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = function(attType) {
    var cleanAttType = cleanAttributeType(attType);
    return publicAPI["get".concat(cleanAttType)]();
  };
  publicAPI.removeAllArrays = function() {
    model.arrays = [];
    attrTypes.forEach(function(attType) {
      model["active".concat(attType)] = -1;
    });
  };
  publicAPI.removeArray = function(arrayName) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      if (arrayName === entry.data.getName()) {
        attrTypes.forEach(function(attType) {
          if (idx === model["active".concat(attType)]) {
            model["active".concat(attType)] = -1;
          }
        });
        return false;
      }
      return true;
    });
  };
  publicAPI.removeArrayByIndex = function(arrayIdx) {
    model.arrays = model.arrays.filter(function(entry, idx) {
      return idx !== arrayIdx;
    });
    attrTypes.forEach(function(attType) {
      if (arrayIdx === model["active".concat(attType)]) {
        model["active".concat(attType)] = -1;
      }
    });
  };
  attrTypes.forEach(function(value) {
    var activeVal = "active".concat(value);
    publicAPI["get".concat(value)] = function() {
      return publicAPI.getArrayByIndex(model[activeVal]);
    };
    publicAPI["set".concat(value)] = function(da) {
      return publicAPI.setAttribute(da, value);
    };
    publicAPI["setActive".concat(value)] = function(arrayName) {
      return publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    };
    publicAPI["copy".concat(value, "Off")] = function() {
      var attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
  });
  publicAPI.initializeAttributeCopyFlags = function() {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter(function(op) {
      return op !== "ALLCOPY";
    }).forEach(function(attCopyOp) {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter(function(ty) {
        return ty !== "NUM_ATTRIBUTES";
      }).reduce(function(a, b) {
        a[AttributeTypes2[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach(function(name) {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other, debug) {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map(function(arr) {
      var arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
function extend51(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES51, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var AttributeTypes2, AttributeCopyOperations2, vtkWarningMacro6, DEFAULT_VALUES51, newInstance53, vtkDataSetAttributes$1;
var init_DataSetAttributes = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js"() {
    init_defineProperty();
    init_macros();
    init_FieldData();
    init_Constants13();
    init_DataArray();
    AttributeTypes2 = Constants10.AttributeTypes;
    AttributeCopyOperations2 = Constants10.AttributeCopyOperations;
    vtkWarningMacro6 = macro.vtkWarningMacro;
    DEFAULT_VALUES51 = {
      activeScalars: -1,
      activeVectors: -1,
      activeTensors: -1,
      activeNormals: -1,
      activeTCoords: -1,
      activeGlobalIds: -1,
      activePedigreeIds: -1
    };
    newInstance53 = macro.newInstance(extend51, "vtkDataSetAttributes");
    vtkDataSetAttributes$1 = _objectSpread15({
      newInstance: newInstance53,
      extend: extend51
    }, Constants10);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes, FieldAssociations, Constants11;
var init_Constants14 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js"() {
    FieldDataTypes = {
      UNIFORM: 0,
      DATA_OBJECT_FIELD: 0,
      COORDINATE: 1,
      POINT_DATA: 1,
      POINT: 2,
      POINT_FIELD_DATA: 2,
      CELL: 3,
      CELL_FIELD_DATA: 3,
      VERTEX: 4,
      VERTEX_FIELD_DATA: 4,
      EDGE: 5,
      EDGE_FIELD_DATA: 5,
      ROW: 6,
      ROW_DATA: 6
    };
    FieldAssociations = {
      FIELD_ASSOCIATION_POINTS: 0,
      FIELD_ASSOCIATION_CELLS: 1,
      FIELD_ASSOCIATION_NONE: 2,
      FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
      FIELD_ASSOCIATION_VERTICES: 4,
      FIELD_ASSOCIATION_EDGES: 5,
      FIELD_ASSOCIATION_ROWS: 6,
      NUMBER_OF_ASSOCIATIONS: 7
    };
    Constants11 = {
      FieldDataTypes,
      FieldAssociations
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
function ownKeys16(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread16(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys16(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys16(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach(function(fieldName) {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach(function(fieldName) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}
function extend52(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES52, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  vtkDataSet(publicAPI, model);
}
var DATASET_FIELDS, DEFAULT_VALUES52, newInstance54, vtkDataSet$1;
var init_DataSet = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js"() {
    init_defineProperty();
    init_macros();
    init_vtk();
    init_DataSetAttributes();
    init_Constants14();
    DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
    DEFAULT_VALUES52 = {};
    newInstance54 = macro.newInstance(extend52, "vtkDataSet");
    vtkDataSet$1 = _objectSpread16({
      newInstance: newInstance54,
      extend: extend52
    }, Constants11);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
var StructuredType, Constants12;
var init_Constants15 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js"() {
    StructuredType = {
      UNCHANGED: 0,
      SINGLE_POINT: 1,
      X_LINE: 2,
      Y_LINE: 3,
      Z_LINE: 4,
      XY_PLANE: 5,
      YZ_PLANE: 6,
      XZ_PLANE: 7,
      XYZ_GRID: 8,
      EMPTY: 9
    };
    Constants12 = {
      StructuredType
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
function ownKeys17(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread17(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys17(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys17(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getDataDescriptionFromExtent(inExt) {
  var dataDim = 0;
  for (var i = 0; i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType2.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType2.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType2.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType2.XZ_PLANE;
    }
    return StructuredType2.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType2.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType2.Y_LINE;
    }
    return StructuredType2.Z_LINE;
  }
  return StructuredType2.SINGLE_POINT;
}
var StructuredType2, vtkStructuredData;
var init_StructuredData = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js"() {
    init_defineProperty();
    init_Constants15();
    StructuredType2 = Constants12.StructuredType;
    vtkStructuredData = _objectSpread17({
      getDataDescriptionFromExtent
    }, Constants12);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var ImageData_exports = {};
__export(ImageData_exports, {
  default: () => vtkImageData$1,
  extend: () => extend53,
  newInstance: () => newInstance55
});
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro16("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    var extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    var changeDetected = false;
    model.extent.forEach(function(item, index) {
      if (item !== extentArray[index]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    var i;
    var j;
    var k;
    if (model.deleted) {
      vtkErrorMacro16("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      var array = arguments.length <= 0 ? void 0 : arguments[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? void 0 : arguments[0];
      j = arguments.length <= 1 ? void 0 : arguments[1];
      k = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      vtkErrorMacro16("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = function() {
    return [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  };
  publicAPI.getNumberOfCells = function() {
    var dims = publicAPI.getDimensions();
    var nCells = 1;
    for (var i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = function() {
    var dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = function(index) {
    var dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro16("Requesting a point from an empty image.");
      return null;
    }
    var ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType.EMPTY:
        return null;
      case StructuredType.SINGLE_POINT:
        break;
      case StructuredType.X_LINE:
        ijk[0] = index;
        break;
      case StructuredType.Y_LINE:
        ijk[1] = index;
        break;
      case StructuredType.Z_LINE:
        ijk[2] = index;
        break;
      case StructuredType.XY_PLANE:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0];
        break;
      case StructuredType.YZ_PLANE:
        ijk[1] = index % dims[1];
        ijk[2] = index / dims[1];
        break;
      case StructuredType.XZ_PLANE:
        ijk[0] = index % dims[0];
        ijk[2] = index / dims[0];
        break;
      case StructuredType.XYZ_GRID:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0] % dims[1];
        ijk[2] = index / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro16("Invalid dataDescription");
        break;
    }
    var coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = function() {
    return publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  };
  publicAPI.extentToBounds = function(ex) {
    var corners = [ex[0], ex[2], ex[4], ex[1], ex[2], ex[4], ex[0], ex[3], ex[4], ex[1], ex[3], ex[4], ex[0], ex[2], ex[5], ex[1], ex[2], ex[5], ex[0], ex[3], ex[5], ex[1], ex[3], ex[5]];
    var idx = new Float64Array([corners[0], corners[1], corners[2]]);
    var vout = new Float64Array(3);
    publicAPI.indexToWorld(idx, vout);
    var bounds = [vout[0], vout[0], vout[1], vout[1], vout[2], vout[2]];
    for (var i = 3; i < 24; i += 3) {
      vec3_exports.set(idx, corners[i], corners[i + 1], corners[i + 2]);
      publicAPI.indexToWorld(idx, vout);
      if (vout[0] < bounds[0]) {
        bounds[0] = vout[0];
      }
      if (vout[1] < bounds[2]) {
        bounds[2] = vout[1];
      }
      if (vout[2] < bounds[4]) {
        bounds[4] = vout[2];
      }
      if (vout[0] > bounds[1]) {
        bounds[1] = vout[0];
      }
      if (vout[1] > bounds[3]) {
        bounds[3] = vout[1];
      }
      if (vout[2] > bounds[5]) {
        bounds[5] = vout[2];
      }
    }
    return bounds;
  };
  publicAPI.getSpatialExtent = function() {
    var boundingBox = vtkBoundingBox.newInstance();
    boundingBox.setBounds(model.extent);
    boundingBox.inflate(0.5);
    return boundingBox.getBounds();
  };
  publicAPI.computeTransforms = function() {
    mat4_exports.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    mat4_exports.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    mat4_exports.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.setDirection = function() {
    if (model.deleted) {
      vtkErrorMacro16("instance deleted - cannot call any method");
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    var array = args;
    if (array.length === 1 && (Array.isArray(array[0]) || array[0].constructor === Float32Array || array[0].constructor === Float64Array)) {
      array = array[0];
    }
    if (array.length !== 9) {
      throw new RangeError("Invalid number of values for array setter");
    }
    var changeDetected = false;
    model.direction.forEach(function(item, index) {
      if (item !== array[index]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });
    if (changeDetected) {
      for (var i = 0; i < 9; ++i) {
        model.direction[i] = array[i];
      }
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.indexToWorld = function(ain) {
    var aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    var aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin) {
    var bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var in1 = [0, 0, 0];
    var in2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bin, in1, in2);
    var out1 = [0, 0, 0];
    var out2 = [0, 0, 0];
    vec3_exports.transformMat4(out1, in1, model.indexToWorld);
    vec3_exports.transformMat4(out2, in2, model.indexToWorld);
    return computeBoundsFromPoints(out1, out2, bout);
  };
  publicAPI.worldToIndexBounds = function(bin) {
    var bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var in1 = [0, 0, 0];
    var in2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bin, in1, in2);
    var out1 = [0, 0, 0];
    var out2 = [0, 0, 0];
    vec3_exports.transformMat4(out1, in1, model.worldToIndex);
    vec3_exports.transformMat4(out2, in2, model.worldToIndex);
    return computeBoundsFromPoints(out1, out2, bout);
  };
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();
  publicAPI.getCenter = function() {
    var bounds = publicAPI.getBounds();
    var center = [];
    for (var i = 0; i < 3; i++) {
      center[i] = (bounds[2 * i + 1] + bounds[2 * i]) / 2;
    }
    return center;
  };
  publicAPI.computeHistogram = function(worldBounds) {
    var voxelFunc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    var point1 = [0, 0, 0];
    var point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    var dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    var yStride = dimensions[0];
    var zStride = dimensions[0] * dimensions[1];
    var pixels = publicAPI.getPointData().getScalars().getData();
    var maximum = -Infinity;
    var minimum = Infinity;
    var sumOfSquares = 0;
    var isum = 0;
    var inum = 0;
    for (var z = point1[2]; z <= point2[2]; z++) {
      for (var y = point1[1]; y <= point2[1]; y++) {
        var index = point1[0] + y * yStride + z * zStride;
        for (var x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {
            var pixel = pixels[index];
            if (pixel > maximum)
              maximum = pixel;
            if (pixel < minimum)
              minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index;
        }
      }
    }
    var average = inum > 0 ? isum / inum : 0;
    var variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    var sigma = Math.sqrt(variance);
    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent) {
    var numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var increments = [];
    var incr = numberOfComponents;
    for (var idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = function(_ref) {
    var _ref2 = _slicedToArray(_ref, 3), i = _ref2[0], j = _ref2[1], k = _ref2[2];
    var extent = publicAPI.getExtent();
    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    var increments = publicAPI.computeIncrements(extent, numberOfComponents);
    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = function(xyz) {
    var extent = publicAPI.getExtent();
    var index = publicAPI.worldToIndex(xyz);
    for (var idx = 0; idx < 3; ++idx) {
      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro16("GetScalarPointer: Pixel ".concat(index, " is not in memory. Current extent = ").concat(extent));
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    var comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro16("GetScalarPointer: Scalar Component ".concat(comp, " is not within bounds. Current Scalar numberOfComponents: ").concat(numberOfComponents));
      return NaN;
    }
    var offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
}
function extend53(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES53, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = mat3_exports.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["direction", "indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var vtkErrorMacro16, DEFAULT_VALUES53, newInstance55, vtkImageData$1;
var init_ImageData = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js"() {
    init_slicedToArray();
    init_macros();
    init_Math();
    init_BoundingBox();
    init_DataSet();
    init_StructuredData();
    init_Constants15();
    init_esm();
    vtkErrorMacro16 = macro.vtkErrorMacro;
    DEFAULT_VALUES53 = {
      direction: null,
      indexToWorld: null,
      worldToIndex: null,
      spacing: [1, 1, 1],
      origin: [0, 0, 0],
      extent: [0, -1, 0, -1, 0, -1],
      dataDescription: StructuredType.EMPTY
    };
    newInstance55 = macro.newInstance(extend53, "vtkImageData");
    vtkImageData$1 = {
      newInstance: newInstance55,
      extend: extend53
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = function() {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = function(plane) {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = function() {
    return model.clippingPlanes.length;
  };
  publicAPI.removeAllClippingPlanes = function() {
    model.clippingPlanes.length = 0;
  };
  publicAPI.removeClippingPlane = function(clippingPlane) {
    var i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = function() {
    return model.clippingPlanes;
  };
  publicAPI.setClippingPlanes = function(planes) {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      var nbPlanes = planes.length;
      for (var i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = function(propMatrix, i, hnormal) {
    var clipPlanes = model.clippingPlanes;
    var mat = propMatrix;
    if (clipPlanes) {
      var n = clipPlanes.length;
      if (i >= 0 && i < n) {
        var plane = clipPlanes[i];
        var normal = plane.getNormal();
        var origin = plane.getOrigin();
        var v1 = normal[0];
        var v2 = normal[1];
        var v3 = normal[2];
        var v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro("Clipping plane index ".concat(i, " is out of range."));
  };
}
function extend54(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES54, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var DEFAULT_VALUES54, vtkAbstractMapper$1;
var init_AbstractMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js"() {
    init_macros();
    DEFAULT_VALUES54 = {
      clippingPlanes: []
    };
    vtkAbstractMapper$1 = {
      extend: extend54
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js
var VolumeMapper_exports2 = {};
__export(VolumeMapper_exports2, {
  default: () => vtkVolumeMapper$1,
  extend: () => extend55,
  newInstance: () => newInstance56
});
function vtkVolumeMapper2(publicAPI, model) {
  model.classHierarchy.push("vtkVolumeMapper");
  publicAPI.getBounds = function() {
    var input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.update = function() {
    publicAPI.getInputData();
  };
  publicAPI.setBlendModeToComposite = function() {
    publicAPI.setBlendMode(BlendMode2.COMPOSITE_BLEND);
  };
  publicAPI.setBlendModeToMaximumIntensity = function() {
    publicAPI.setBlendMode(BlendMode2.MAXIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToMinimumIntensity = function() {
    publicAPI.setBlendMode(BlendMode2.MINIMUM_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAverageIntensity = function() {
    publicAPI.setBlendMode(BlendMode2.AVERAGE_INTENSITY_BLEND);
  };
  publicAPI.setBlendModeToAdditiveIntensity = function() {
    publicAPI.setBlendMode(BlendMode2.ADDITIVE_INTENSITY_BLEND);
  };
  publicAPI.getBlendModeAsString = function() {
    return macro.enumToString(BlendMode2, model.blendMode);
  };
  publicAPI.setAverageIPScalarRange = function(min2, max2) {
    console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange");
    publicAPI.setIpScalarRange(min2, max2);
  };
  publicAPI.getFilterModeAsString = function() {
    return macro.enumToString(FilterMode2, model.filterMode);
  };
  publicAPI.setFilterModeToOff = function() {
    publicAPI.setFilterMode(FilterMode2.OFF);
  };
  publicAPI.setFilterModeToNormalized = function() {
    publicAPI.setFilterMode(FilterMode2.NORMALIZED);
  };
  publicAPI.setFilterModeToRaw = function() {
    publicAPI.setFilterMode(FilterMode2.RAW);
  };
}
function extend55(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES55, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["sampleDistance", "imageSampleDistance", "maximumSamplesPerRay", "autoAdjustSampleDistances", "blendMode", "filterMode", "preferSizeOverAccuracy"]);
  macro.setGetArray(publicAPI, model, ["ipScalarRange"], 2);
  macro.event(publicAPI, model, "lightingActivated");
  vtkVolumeMapper2(publicAPI, model);
}
var BlendMode2, FilterMode2, DEFAULT_VALUES55, newInstance56, vtkVolumeMapper$1;
var init_VolumeMapper2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/VolumeMapper.js"() {
    init_macros();
    init_Math();
    init_Constants();
    init_AbstractMapper();
    BlendMode2 = Constants.BlendMode;
    FilterMode2 = Constants.FilterMode;
    DEFAULT_VALUES55 = {
      bounds: [1, -1, 1, -1, 1, -1],
      sampleDistance: 1,
      imageSampleDistance: 1,
      maximumSamplesPerRay: 1e3,
      autoAdjustSampleDistances: true,
      blendMode: BlendMode2.COMPOSITE_BLEND,
      ipScalarRange: [-1e6, 1e6],
      filterMode: FilterMode2.OFF,
      preferSizeOverAccuracy: false
    };
    newInstance56 = macro.newInstance(extend55, "vtkVolumeMapper");
    vtkVolumeMapper$1 = {
      newInstance: newInstance56,
      extend: extend55
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js
var MatrixBuilder_exports = {};
__export(MatrixBuilder_exports, {
  default: () => vtkMatrixBuilder
});
function buildFromDegree() {
  return new Transform(true);
}
function buildFromRadian() {
  return new Transform(false);
}
var NoOp, IDENTITY, EPSILON, Transform, vtkMatrixBuilder;
var init_MatrixBuilder = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/MatrixBuilder.js"() {
    init_toConsumableArray();
    init_classCallCheck();
    init_createClass();
    init_esm();
    init_Math();
    NoOp = function NoOp2(v) {
      return v;
    };
    IDENTITY = mat4_exports.identity(new Float64Array(16));
    EPSILON = 1e-6;
    Transform = function() {
      function Transform2() {
        var useDegree = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        _classCallCheck(this, Transform2);
        this.matrix = mat4_exports.identity(new Float64Array(16));
        this.tmp = new Float64Array(3);
        this.angleConv = useDegree ? common_exports.toRadian : NoOp;
      }
      _createClass(Transform2, [{
        key: "rotateFromDirections",
        value: function rotateFromDirections(originDirection, targetDirection) {
          var src = new Float64Array(3);
          var dst = new Float64Array(3);
          var transf = new Float64Array(16);
          vec3_exports.set(src, originDirection[0], originDirection[1], originDirection[2]);
          vec3_exports.set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
          vec3_exports.normalize(src, src);
          vec3_exports.normalize(dst, dst);
          var cosAlpha = vec3_exports.dot(src, dst);
          if (cosAlpha >= 1) {
            return this;
          }
          vec3_exports.cross(this.tmp, src, dst);
          if (vec3_exports.length(this.tmp) < EPSILON) {
            vec3_exports.cross(this.tmp, [1, 0, 0], originDirection);
            if (vec3_exports.length(this.tmp) < EPSILON) {
              vec3_exports.cross(this.tmp, [0, 1, 0], originDirection);
            }
          }
          mat4_exports.fromRotation(transf, Math.acos(cosAlpha), this.tmp);
          mat4_exports.multiply(this.matrix, this.matrix, transf);
          return this;
        }
      }, {
        key: "rotate",
        value: function rotate(angle, axis) {
          vec3_exports.set.apply(vec3_exports, [this.tmp].concat(_toConsumableArray(axis)));
          vec3_exports.normalize(this.tmp, this.tmp);
          mat4_exports.rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
          return this;
        }
      }, {
        key: "rotateX",
        value: function rotateX(angle) {
          mat4_exports.rotateX(this.matrix, this.matrix, this.angleConv(angle));
          return this;
        }
      }, {
        key: "rotateY",
        value: function rotateY(angle) {
          mat4_exports.rotateY(this.matrix, this.matrix, this.angleConv(angle));
          return this;
        }
      }, {
        key: "rotateZ",
        value: function rotateZ(angle) {
          mat4_exports.rotateZ(this.matrix, this.matrix, this.angleConv(angle));
          return this;
        }
      }, {
        key: "translate",
        value: function translate(x, y, z) {
          vec3_exports.set(this.tmp, x, y, z);
          mat4_exports.translate(this.matrix, this.matrix, this.tmp);
          return this;
        }
      }, {
        key: "scale",
        value: function scale(sx, sy, sz) {
          vec3_exports.set(this.tmp, sx, sy, sz);
          mat4_exports.scale(this.matrix, this.matrix, this.tmp);
          return this;
        }
      }, {
        key: "multiply",
        value: function multiply(mat4x4) {
          mat4_exports.multiply(this.matrix, this.matrix, mat4x4);
          return this;
        }
      }, {
        key: "identity",
        value: function identity() {
          mat4_exports.identity(this.matrix);
          return this;
        }
      }, {
        key: "apply",
        value: function apply(typedArray) {
          var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          var nbIterations = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
          if (areMatricesEqual(IDENTITY, this.matrix)) {
            return this;
          }
          var size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
          for (var i = offset; i < size; i += 3) {
            vec3_exports.set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
            vec3_exports.transformMat4(this.tmp, this.tmp, this.matrix);
            typedArray[i] = this.tmp[0];
            typedArray[i + 1] = this.tmp[1];
            typedArray[i + 2] = this.tmp[2];
          }
          return this;
        }
      }, {
        key: "getMatrix",
        value: function getMatrix() {
          return this.matrix;
        }
      }, {
        key: "setMatrix",
        value: function setMatrix(mat4x4) {
          if (!!mat4x4 && mat4x4.length === 16) {
            mat4_exports.copy(this.matrix, mat4x4);
          }
          return this;
        }
      }]);
      return Transform2;
    }();
    vtkMatrixBuilder = {
      buildFromDegree,
      buildFromRadian
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Light.js
function vtkLight(publicAPI, model) {
  model.classHierarchy.push("vtkLight");
  publicAPI.getTransformedPosition = function() {
    if (model.transformMatrix) {
      return [];
    }
    return [].concat(model.position);
  };
  publicAPI.getTransformedFocalPoint = function() {
    if (model.transformMatrix) {
      return [];
    }
    return [].concat(model.focalPoint);
  };
  publicAPI.getDirection = function() {
    if (model.directionMTime < model.mtime) {
      model.direction[0] = model.focalPoint[0] - model.position[0];
      model.direction[1] = model.focalPoint[1] - model.position[1];
      model.direction[2] = model.focalPoint[2] - model.position[2];
      normalize(model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };
  publicAPI.setDirectionAngle = function(elevation, azimuth) {
    var elevationRadians = radiansFromDegrees(elevation);
    var azimuthRadians = radiansFromDegrees(azimuth);
    publicAPI.setPosition(Math.cos(elevationRadians) * Math.sin(azimuthRadians), Math.sin(elevationRadians), Math.cos(elevationRadians) * Math.cos(azimuthRadians));
    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };
  publicAPI.setLightTypeToHeadLight = function() {
    publicAPI.setLightType("HeadLight");
  };
  publicAPI.setLightTypeToCameraLight = function() {
    publicAPI.setLightType("CameraLight");
  };
  publicAPI.setLightTypeToSceneLight = function() {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType("SceneLight");
  };
  publicAPI.lightTypeIsHeadLight = function() {
    return model.lightType === "HeadLight";
  };
  publicAPI.lightTypeIsSceneLight = function() {
    return model.lightType === "SceneLight";
  };
  publicAPI.lightTypeIsCameraLight = function() {
    return model.lightType === "CameraLight";
  };
}
function extend56(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES56, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["intensity", "switch", "positional", "exponent", "coneAngle", "transformMatrix", "lightType", "shadowAttenuation"]);
  macro.setGetArray(publicAPI, model, ["color", "position", "focalPoint", "attenuationValues"], 3);
  vtkLight(publicAPI, model);
}
var LIGHT_TYPES, DEFAULT_VALUES56, newInstance57, vtkLight$1;
var init_Light = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Light.js"() {
    init_macros();
    init_Math();
    LIGHT_TYPES = ["HeadLight", "CameraLight", "SceneLight"];
    DEFAULT_VALUES56 = {
      switch: true,
      intensity: 1,
      color: [1, 1, 1],
      position: [0, 0, 1],
      focalPoint: [0, 0, 0],
      positional: false,
      exponent: 1,
      coneAngle: 30,
      attenuationValues: [1, 0, 0],
      transformMatrix: null,
      lightType: "SceneLight",
      shadowAttenuation: 1,
      direction: [0, 0, 0],
      directionMTime: 0
    };
    newInstance57 = macro.newInstance(extend56, "vtkLight");
    vtkLight$1 = {
      newInstance: newInstance57,
      extend: extend56,
      LIGHT_TYPES
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js
function notImplemented4(method) {
  return function() {
    return vtkErrorMacro17("vtkViewport::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkViewport(publicAPI, model) {
  model.classHierarchy.push("vtkViewport");
  publicAPI.getViewProps = function() {
    return model.props;
  };
  publicAPI.hasViewProp = function(prop) {
    return !!model.props.filter(function(item) {
      return item === prop;
    }).length;
  };
  publicAPI.addViewProp = function(prop) {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props = model.props.concat(prop);
    }
  };
  publicAPI.removeViewProp = function(prop) {
    var newPropList = model.props.filter(function(item) {
      return item !== prop;
    });
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };
  publicAPI.removeAllViewProps = function() {
    model.props = [];
  };
  function gatherProps(prop) {
    var allProps = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    allProps.push(prop);
    var children = prop.getNestedProps();
    if (children && children.length) {
      for (var i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }
  publicAPI.getViewPropsWithNestedProps = function() {
    var allPropsArray = [];
    for (var i = 0; i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };
  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = function(prop) {
    publicAPI.removeViewProp(prop);
  };
  publicAPI.getActors2D = function() {
    model.actors2D = [];
    model.props.forEach(function(prop) {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };
  publicAPI.displayToView = function() {
    return vtkErrorMacro17("call displayToView on your view instead");
  };
  publicAPI.viewToDisplay = function() {
    return vtkErrorMacro17("callviewtodisplay on your view instead");
  };
  publicAPI.getSize = function() {
    return vtkErrorMacro17("call getSize on your View instead");
  };
  publicAPI.normalizedDisplayToProjection = function(x, y, z) {
    var nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedDisplayToNormalizedViewport = function(x, y, z) {
    var scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [(x - model.viewport[0]) / scale[0], (y - model.viewport[1]) / scale[1], z];
  };
  publicAPI.normalizedViewportToProjection = function(x, y, z) {
    return [x * 2 - 1, y * 2 - 1, z * 2 - 1];
  };
  publicAPI.projectionToNormalizedDisplay = function(x, y, z) {
    var nvp = publicAPI.projectionToNormalizedViewport(x, y, z);
    return publicAPI.normalizedViewportToNormalizedDisplay(nvp[0], nvp[1], nvp[2]);
  };
  publicAPI.normalizedViewportToNormalizedDisplay = function(x, y, z) {
    var scale = [model.viewport[2] - model.viewport[0], model.viewport[3] - model.viewport[1]];
    return [x * scale[0] + model.viewport[0], y * scale[1] + model.viewport[1], z];
  };
  publicAPI.projectionToNormalizedViewport = function(x, y, z) {
    return [(x + 1) * 0.5, (y + 1) * 0.5, (z + 1) * 0.5];
  };
  publicAPI.PickPropFrom = notImplemented4("PickPropFrom");
}
function extend57(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES57, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  macro.setGetArray(publicAPI, model, ["viewport"], 4);
  macro.setGetArray(publicAPI, model, ["background", "background2"], 3);
  vtkViewport(publicAPI, model);
}
var vtkErrorMacro17, DEFAULT_VALUES57, newInstance58, vtkViewport$1;
var init_Viewport = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Viewport.js"() {
    init_macros();
    vtkErrorMacro17 = macro.vtkErrorMacro;
    DEFAULT_VALUES57 = {
      background: [0, 0, 0],
      background2: [0.2, 0.2, 0.2],
      gradientBackground: false,
      viewport: [0, 0, 1, 1],
      aspect: [1, 1],
      pixelAspect: [1, 1],
      props: [],
      actors2D: []
    };
    newInstance58 = macro.newInstance(extend57, "vtkViewport");
    vtkViewport$1 = {
      newInstance: newInstance58,
      extend: extend57
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js
var Renderer_exports2 = {};
__export(Renderer_exports2, {
  default: () => vtkRenderer$1,
  extend: () => extend58,
  newInstance: () => newInstance59
});
function notImplemented5(method) {
  return function() {
    return vtkErrorMacro18("vtkRenderer::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkRenderer2(publicAPI, model) {
  model.classHierarchy.push("vtkRenderer");
  var COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: "ComputeVisiblePropBoundsEvent",
    renderer: publicAPI
  };
  var RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: "ResetCameraClippingRangeEvent",
    renderer: publicAPI
  };
  var RESET_CAMERA_EVENT = {
    type: "ResetCameraEvent",
    renderer: publicAPI
  };
  publicAPI.updateCamera = function() {
    if (!model.activeCamera) {
      vtkDebugMacro10("No cameras are on, creating one.");
      publicAPI.getActiveCameraAndResetIfCreated();
    }
    model.activeCamera.render(publicAPI);
    return true;
  };
  publicAPI.updateLightsGeometryToFollowCamera = function() {
    var camera = publicAPI.getActiveCameraAndResetIfCreated();
    model.lights.forEach(function(light) {
      if (light.lightTypeIsSceneLight() || light.lightTypeIsCameraLight())
        ;
      else if (light.lightTypeIsHeadLight()) {
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else {
        vtkErrorMacro18("light has unknown light type", light.get());
      }
    });
  };
  publicAPI.updateLightGeometry = function() {
    if (model.lightFollowCamera) {
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };
  publicAPI.allocateTime = notImplemented5("allocateTime");
  publicAPI.updateGeometry = notImplemented5("updateGeometry");
  publicAPI.getVTKWindow = function() {
    return model._renderWindow;
  };
  publicAPI.setLayer = function(layer) {
    vtkDebugMacro10(publicAPI.getClassName(), publicAPI, "setting Layer to ", layer);
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };
  publicAPI.setActiveCamera = function(camera) {
    if (model.activeCamera === camera) {
      return false;
    }
    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({
      type: "ActiveCameraEvent",
      camera
    });
    return true;
  };
  publicAPI.makeCamera = function() {
    var camera = vtkCamera$1.newInstance();
    publicAPI.invokeEvent({
      type: "CreateCameraEvent",
      camera
    });
    return camera;
  };
  publicAPI.getActiveCamera = function() {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActiveCameraAndResetIfCreated = function() {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };
  publicAPI.getActors = function() {
    model.actors = [];
    model.props.forEach(function(prop) {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = function(actor) {
    model.actors = model.actors.filter(function(a) {
      return a !== actor;
    });
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = function() {
    var actors = publicAPI.getActors();
    actors.forEach(function(actor) {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };
  publicAPI.getVolumes = function() {
    model.volumes = [];
    model.props.forEach(function(prop) {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = function(volume) {
    model.volumes = model.volumes.filter(function(v) {
      return v !== volume;
    });
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = function() {
    var volumes = publicAPI.getVolumes();
    volumes.forEach(function(volume) {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };
  publicAPI.addLight = function(light) {
    model.lights = [].concat(model.lights, light);
    publicAPI.modified();
  };
  publicAPI.removeLight = function(light) {
    model.lights = model.lights.filter(function(l) {
      return l !== light;
    });
    publicAPI.modified();
  };
  publicAPI.removeAllLights = function() {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = function(lights) {
    model.lights = lights;
    publicAPI.modified();
  };
  publicAPI.makeLight = vtkLight$1.newInstance;
  publicAPI.createLight = function() {
    if (!model.automaticLightCreation) {
      return;
    }
    if (model._createdLight) {
      publicAPI.removeLight(model._createdLight);
      model._createdLight.delete();
      model._createdLight = null;
    }
    model._createdLight = publicAPI.makeLight();
    publicAPI.addLight(model._createdLight);
    model._createdLight.setLightTypeToHeadLight();
    model._createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model._createdLight.setFocalPoint(publicAPI.getActiveCamera().getFocalPoint());
  };
  publicAPI.normalizedDisplayToWorld = function(x, y, z, aspect) {
    var vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.worldToNormalizedDisplay = function(x, y, z, aspect) {
    var vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);
    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };
  publicAPI.viewToWorld = function(x, y, z) {
    if (model.activeCamera === null) {
      vtkErrorMacro18("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getViewMatrix();
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.projectionToView = function(x, y, z, aspect) {
    if (model.activeCamera === null) {
      vtkErrorMacro18("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.invert(matrix, matrix);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.worldToView = function(x, y, z) {
    if (model.activeCamera === null) {
      vtkErrorMacro18("WorldToView: no active camera, cannot compute view to world, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getViewMatrix();
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.viewToProjection = function(x, y, z, aspect) {
    if (model.activeCamera === null) {
      vtkErrorMacro18("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0");
      return [0, 0, 0];
    }
    var matrix = model.activeCamera.getProjectionMatrix(aspect, -1, 1);
    mat4_exports.transpose(matrix, matrix);
    var result = new Float64Array([x, y, z]);
    vec3_exports.transformMat4(result, result, matrix);
    return result;
  };
  publicAPI.computeVisiblePropBounds = function() {
    model.allBounds[0] = vtkBoundingBox.INIT_BOUNDS[0];
    model.allBounds[1] = vtkBoundingBox.INIT_BOUNDS[1];
    model.allBounds[2] = vtkBoundingBox.INIT_BOUNDS[2];
    model.allBounds[3] = vtkBoundingBox.INIT_BOUNDS[3];
    model.allBounds[4] = vtkBoundingBox.INIT_BOUNDS[4];
    model.allBounds[5] = vtkBoundingBox.INIT_BOUNDS[5];
    var nothingVisible = true;
    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);
    for (var index = 0; index < model.props.length; ++index) {
      var prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        var bounds = prop.getBounds();
        if (bounds && areBoundsInitialized(bounds)) {
          nothingVisible = false;
          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }
    if (nothingVisible) {
      uninitializeBounds(model.allBounds);
      vtkDebugMacro10("Can't compute bounds, no 3D props are visible");
    }
    return model.allBounds;
  };
  publicAPI.resetCamera = function() {
    var bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    var center = [0, 0, 0];
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro10("Cannot reset camera!");
      return false;
    }
    var vn = null;
    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro18("Trying to reset non-existent camera");
      return false;
    }
    model.activeCamera.setViewAngle(30);
    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2;
    var w1 = boundsToUse[1] - boundsToUse[0];
    var w2 = boundsToUse[3] - boundsToUse[2];
    var w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    var radius = w1 + w2 + w3;
    radius = radius === 0 ? 1 : radius;
    radius = Math.sqrt(radius) * 0.5;
    var angle = radiansFromDegrees(model.activeCamera.getViewAngle());
    var parallelScale = radius;
    var distance = radius / Math.sin(angle * 0.5);
    var vup = model.activeCamera.getViewUp();
    if (Math.abs(dot(vup, vn)) > 0.999) {
      vtkWarningMacro7("Resetting view-up since view plane normal is parallel");
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(center[0] + distance * vn[0], center[1] + distance * vn[1], center[2] + distance * vn[2]);
    publicAPI.resetCameraClippingRange(boundsToUse);
    model.activeCamera.setParallelScale(parallelScale);
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(-center[0], -center[1], -center[2]);
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);
    return true;
  };
  publicAPI.resetCameraClippingRange = function() {
    var bounds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    if (!areBoundsInitialized(boundsToUse)) {
      vtkDebugMacro10("Cannot reset camera clipping range!");
      return false;
    }
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro18("Trying to reset clipping range of non-existent camera");
      return false;
    }
    var range = model.activeCamera.computeClippingRange(boundsToUse);
    var minGap = 0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.2 * model.activeCamera.getParallelScale();
    } else {
      var angle = radiansFromDegrees(model.activeCamera.getViewAngle());
      minGap = 0.2 * Math.tan(angle / 2) * range[1];
    }
    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2;
      range[0] -= minGap / 2;
    }
    if (range[0] < 0) {
      range[0] = 0;
    }
    range[0] = 0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] = 1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };
  publicAPI.setRenderWindow = function(renderWindow) {
    if (renderWindow !== model._renderWindow) {
      model._vtkWindow = renderWindow;
      model._renderWindow = renderWindow;
    }
  };
  publicAPI.visibleActorCount = function() {
    return model.props.filter(function(prop) {
      return prop.getVisibility();
    }).length;
  };
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;
  publicAPI.getMTime = function() {
    var m1 = model.mtime;
    var m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    var m3 = model._createdLight ? model._createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };
  publicAPI.getTransparent = function() {
    return !!model.preserveColorBuffer;
  };
  publicAPI.isActiveCameraCreated = function() {
    return !!model.activeCamera;
  };
}
function extend58(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES58, initialValues);
  vtkViewport$1.extend(publicAPI, model, initialValues);
  if (!model.background)
    model.background = [0, 0, 0, 1];
  while (model.background.length < 3) {
    model.background.push(0);
  }
  if (model.background.length === 3)
    model.background.push(1);
  get(publicAPI, model, ["_renderWindow", "allocatedRenderTime", "timeFactor", "lastRenderTimeInSeconds", "numberOfPropsRendered", "lastRenderingUsedDepthPeeling", "selector"]);
  setGet(publicAPI, model, ["twoSidedLighting", "lightFollowCamera", "automaticLightCreation", "erase", "draw", "nearClippingPlaneTolerance", "clippingRangeExpansion", "backingStore", "interactive", "layer", "preserveColorBuffer", "preserveDepthBuffer", "useDepthPeeling", "occlusionRatio", "maximumNumberOfPeels", "delegate", "backgroundTexture", "texturedBackground", "useShadows", "pass"]);
  getArray(publicAPI, model, ["actors", "volumes", "lights"]);
  setGetArray(publicAPI, model, ["background"], 4, 1);
  moveToProtected(publicAPI, model, ["renderWindow"]);
  vtkRenderer2(publicAPI, model);
}
var vtkDebugMacro10, vtkErrorMacro18, vtkWarningMacro7, DEFAULT_VALUES58, newInstance59, vtkRenderer$1;
var init_Renderer3 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Renderer.js"() {
    init_esm();
    init_macros();
    init_Camera();
    init_Light();
    init_Math();
    init_Viewport();
    init_BoundingBox();
    vtkDebugMacro10 = vtkDebugMacro;
    vtkErrorMacro18 = vtkErrorMacro;
    vtkWarningMacro7 = vtkWarningMacro;
    DEFAULT_VALUES58 = {
      pickedProp: null,
      activeCamera: null,
      allBounds: [],
      ambient: [1, 1, 1],
      allocatedRenderTime: 100,
      timeFactor: 1,
      automaticLightCreation: true,
      twoSidedLighting: true,
      lastRenderTimeInSeconds: -1,
      renderWindow: null,
      lights: [],
      actors: [],
      volumes: [],
      lightFollowCamera: true,
      numberOfPropsRendered: 0,
      propArray: null,
      pathArray: null,
      layer: 0,
      preserveColorBuffer: false,
      preserveDepthBuffer: false,
      computeVisiblePropBounds: createUninitializedBounds(),
      interactive: true,
      nearClippingPlaneTolerance: 0,
      clippingRangeExpansion: 0.05,
      erase: true,
      draw: true,
      useShadows: false,
      useDepthPeeling: false,
      occlusionRatio: 0,
      maximumNumberOfPeels: 4,
      selector: null,
      delegate: null,
      texturedBackground: false,
      backgroundTexture: null,
      pass: 0
    };
    newInstance59 = newInstance(extend58, "vtkRenderer");
    vtkRenderer$1 = {
      newInstance: newInstance59,
      extend: extend58
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js
var RenderWindow_exports = {};
__export(RenderWindow_exports, {
  default: () => vtkRenderWindow$1,
  extend: () => extend59,
  listViewAPIs: () => listViewAPIs,
  newAPISpecificView: () => newAPISpecificView,
  newInstance: () => newInstance60,
  registerViewConstructor: () => registerViewConstructor
});
function registerViewConstructor(name, constructor) {
  VIEW_CONSTRUCTORS[name] = constructor;
}
function listViewAPIs() {
  return Object.keys(VIEW_CONSTRUCTORS);
}
function newAPISpecificView(name) {
  var initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return VIEW_CONSTRUCTORS[name] && VIEW_CONSTRUCTORS[name](initialValues);
}
function vtkRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindow");
  publicAPI.addRenderer = function(renderer) {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);
    publicAPI.modified();
  };
  publicAPI.removeRenderer = function(renderer) {
    model.renderers = model.renderers.filter(function(r) {
      return r !== renderer;
    });
    publicAPI.modified();
  };
  publicAPI.hasRenderer = function(ren) {
    return model.renderers.indexOf(ren) !== -1;
  };
  publicAPI.newAPISpecificView = function(name) {
    var initialValues = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return newAPISpecificView(name || model.defaultViewAPI, initialValues);
  };
  publicAPI.addView = function(view) {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model.views.push(view);
    publicAPI.modified();
  };
  publicAPI.removeView = function(view) {
    model.views = model.views.filter(function(r) {
      return r !== view;
    });
    publicAPI.modified();
  };
  publicAPI.hasView = function(view) {
    return model.views.indexOf(view) !== -1;
  };
  publicAPI.preRender = function() {
    model.renderers.forEach(function(ren) {
      if (!ren.isActiveCameraCreated()) {
        ren.resetCamera();
      }
    });
  };
  publicAPI.render = function() {
    publicAPI.preRender();
    if (model.interactor) {
      model.interactor.render();
    } else {
      model.views.forEach(function(view) {
        return view.traverseAllPasses();
      });
    }
  };
  publicAPI.getStatistics = function() {
    var results = {
      propCount: 0,
      invisiblePropCount: 0
    };
    model.renderers.forEach(function(ren) {
      var props = ren.getViewProps();
      props.forEach(function(prop) {
        if (prop.getVisibility()) {
          results.propCount += 1;
          var mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            var pcount = mpr.getPrimitiveCount();
            Object.keys(pcount).forEach(function(keyName) {
              if (!results[keyName]) {
                results[keyName] = 0;
              }
              results[keyName] += pcount[keyName];
            });
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results).map(function(keyName) {
      return "".concat(keyName, ": ").concat(results[keyName]);
    }).join("\n");
    return results;
  };
  publicAPI.captureImages = function() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    macro.setImmediate(publicAPI.render);
    return model.views.map(function(view) {
      return view.captureNextImage ? view.captureNextImage(format, opts) : void 0;
    }).filter(function(i) {
      return !!i;
    });
  };
}
function extend59(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES59, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["interactor", "numberOfLayers", "views", "defaultViewAPI"]);
  macro.get(publicAPI, model, ["neverRendered"]);
  macro.getArray(publicAPI, model, ["renderers"]);
  macro.event(publicAPI, model, "completion");
  vtkRenderWindow(publicAPI, model);
}
var DEFAULT_VIEW_API, VIEW_CONSTRUCTORS, DEFAULT_VALUES59, newInstance60, vtkRenderWindow$1;
var init_RenderWindow = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/RenderWindow.js"() {
    init_macros();
    DEFAULT_VIEW_API = navigator.gpu ? "WebGPU" : "WebGL";
    VIEW_CONSTRUCTORS = /* @__PURE__ */ Object.create(null);
    DEFAULT_VALUES59 = {
      defaultViewAPI: DEFAULT_VIEW_API,
      renderers: [],
      views: [],
      interactor: null,
      neverRendered: true,
      numberOfLayers: 1
    };
    newInstance60 = macro.newInstance(extend59, "vtkRenderWindow");
    vtkRenderWindow$1 = {
      newInstance: newInstance60,
      extend: extend59,
      registerViewConstructor,
      listViewAPIs,
      newAPISpecificView
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js
var Device, Input, Axis, Constants13;
var init_Constants16 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor/Constants.js"() {
    Device = {
      Unknown: 0,
      LeftController: 1,
      RightController: 2
    };
    Input = {
      Unknown: 0,
      Trigger: 1,
      TrackPad: 2,
      Grip: 3,
      Thumbstick: 4,
      A: 5,
      B: 6,
      ApplicationMenu: 7
    };
    Axis = {
      Unknown: 0,
      TouchpadX: 1,
      TouchpadY: 2,
      ThumbstickX: 3,
      ThumbstickY: 4
    };
    Constants13 = {
      Device,
      Input,
      Axis
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js
var RenderWindowInteractor_exports = {};
__export(RenderWindowInteractor_exports, {
  default: () => vtkRenderWindowInteractor$1,
  extend: () => extend60,
  newInstance: () => newInstance61
});
function ownKeys18(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread18(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys18(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys18(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function preventDefault(event2) {
  if (event2.cancelable) {
    event2.stopPropagation();
    event2.preventDefault();
  }
  return false;
}
function vtkRenderWindowInteractor(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowInteractor");
  var animationRequesters = /* @__PURE__ */ new Set();
  var activeListenerCount = 0;
  publicAPI.start = function() {
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    publicAPI.startEventLoop();
  };
  publicAPI.setRenderWindow = function(aren) {
    vtkErrorMacro19("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor");
  };
  publicAPI.setInteractorStyle = function(style) {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };
  publicAPI.initialize = function() {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };
  publicAPI.enable = function() {
    return publicAPI.setEnabled(true);
  };
  publicAPI.disable = function() {
    return publicAPI.setEnabled(false);
  };
  publicAPI.startEventLoop = function() {
    return vtkWarningMacro8("empty event loop");
  };
  function updateCurrentRenderer(x, y) {
    if (!model._forcedRenderer) {
      model.currentRenderer = publicAPI.findPokedRenderer(x, y);
    }
  }
  publicAPI.getCurrentRenderer = function() {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };
  function getScreenEventPositionFor(source) {
    var bounds = model.container.getBoundingClientRect();
    var canvas = model._view.getCanvas();
    var scaleX = canvas.width / bounds.width;
    var scaleY = canvas.height / bounds.height;
    var position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0
    };
    updateCurrentRenderer(position.x, position.y);
    return position;
  }
  function getTouchEventPositionsFor(touches) {
    var positions = {};
    for (var i = 0; i < touches.length; i++) {
      var touch = touches[i];
      positions[touch.identifier] = getScreenEventPositionFor(touch);
    }
    return positions;
  }
  function getModifierKeysFor(event2) {
    return {
      controlKey: event2.ctrlKey,
      altKey: event2.altKey,
      shiftKey: event2.shiftKey
    };
  }
  function getKeysFor(event2) {
    var modifierKeys = getModifierKeysFor(event2);
    var keys = _objectSpread18({
      key: event2.key,
      keyCode: event2.charCode
    }, modifierKeys);
    return keys;
  }
  function interactionRegistration(addListeners) {
    var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var rootElm = document;
    var method = addListeners ? "addEventListener" : "removeEventListener";
    var invMethod = addListeners ? "removeEventListener" : "addEventListener";
    if (!force && !addListeners && activeListenerCount > 0) {
      --activeListenerCount;
    }
    if (!activeListenerCount || force) {
      activeListenerCount = 0;
      if (model.container) {
        model.container[invMethod]("mousemove", publicAPI.handleMouseMove);
      }
      rootElm[method]("mouseup", publicAPI.handleMouseUp);
      rootElm[method]("mousemove", publicAPI.handleMouseMove);
      rootElm[method]("touchend", publicAPI.handleTouchEnd, false);
      rootElm[method]("touchcancel", publicAPI.handleTouchEnd, false);
      rootElm[method]("touchmove", publicAPI.handleTouchMove, false);
    }
    if (!force && addListeners) {
      ++activeListenerCount;
    }
  }
  publicAPI.bindEvents = function(container) {
    model.container = container;
    container.addEventListener("contextmenu", preventDefault);
    container.addEventListener("wheel", publicAPI.handleWheel);
    container.addEventListener("DOMMouseScroll", publicAPI.handleWheel);
    container.addEventListener("mouseenter", publicAPI.handleMouseEnter);
    container.addEventListener("mouseleave", publicAPI.handleMouseLeave);
    container.addEventListener("mousemove", publicAPI.handleMouseMove);
    container.addEventListener("mousedown", publicAPI.handleMouseDown);
    document.addEventListener("keypress", publicAPI.handleKeyPress);
    document.addEventListener("keydown", publicAPI.handleKeyDown);
    document.addEventListener("keyup", publicAPI.handleKeyUp);
    document.addEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    container.addEventListener("touchstart", publicAPI.handleTouchStart, false);
  };
  publicAPI.unbindEvents = function() {
    interactionRegistration(false, true);
    model.container.removeEventListener("contextmenu", preventDefault);
    model.container.removeEventListener("wheel", publicAPI.handleWheel);
    model.container.removeEventListener("DOMMouseScroll", publicAPI.handleWheel);
    model.container.removeEventListener("mouseenter", publicAPI.handleMouseEnter);
    model.container.removeEventListener("mouseleave", publicAPI.handleMouseLeave);
    model.container.removeEventListener("mousemove", publicAPI.handleMouseMove);
    model.container.removeEventListener("mousedown", publicAPI.handleMouseDown);
    document.removeEventListener("keypress", publicAPI.handleKeyPress);
    document.removeEventListener("keydown", publicAPI.handleKeyDown);
    document.removeEventListener("keyup", publicAPI.handleKeyUp);
    document.removeEventListener("pointerlockchange", publicAPI.handlePointerLockChange);
    model.container.removeEventListener("touchstart", publicAPI.handleTouchStart);
    model.container = null;
  };
  publicAPI.handleKeyPress = function(event2) {
    var data = getKeysFor(event2);
    publicAPI.keyPressEvent(data);
  };
  publicAPI.handleKeyDown = function(event2) {
    var data = getKeysFor(event2);
    publicAPI.keyDownEvent(data);
  };
  publicAPI.handleKeyUp = function(event2) {
    var data = getKeysFor(event2);
    publicAPI.keyUpEvent(data);
  };
  publicAPI.handleMouseDown = function(event2) {
    if (event2.button > 2) {
      return;
    }
    interactionRegistration(true);
    preventDefault(event2);
    var callData = _objectSpread18(_objectSpread18({}, getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        vtkErrorMacro19("Unknown mouse button pressed: ".concat(event2.button));
        break;
    }
  };
  publicAPI.requestPointerLock = function() {
    var canvas = publicAPI.getView().getCanvas();
    canvas.requestPointerLock();
  };
  publicAPI.exitPointerLock = function() {
    return document.exitPointerLock();
  };
  publicAPI.isPointerLocked = function() {
    return !!document.pointerLockElement;
  };
  publicAPI.handlePointerLockChange = function() {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };
  function forceRender() {
    if (model._view && model.enabled && model.enableRender) {
      model.inRender = true;
      model._view.traverseAllPasses();
      model.inRender = false;
    }
    publicAPI.invokeRenderEvent();
  }
  publicAPI.requestAnimation = function(requestor) {
    if (requestor === void 0) {
      vtkErrorMacro19("undefined requester, can not start animating");
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro8("requester is already registered for animating");
      return;
    }
    animationRequesters.add(requestor);
    if (!model.animationRequest && animationRequesters.size === 1 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.extendAnimation = function(duration) {
    var newEnd = Date.now() + duration;
    model._animationExtendedEnd = Math.max(model._animationExtendedEnd, newEnd);
    if (!model.animationRequest && animationRequesters.size === 0 && !model.xrAnimation) {
      model._animationStartTime = Date.now();
      model._animationFrameCount = 0;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };
  publicAPI.isAnimating = function() {
    return model.xrAnimation || model.animationRequest !== null;
  };
  publicAPI.cancelAnimation = function(requestor) {
    var skipWarning = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        var requestStr = requestor && requestor.getClassName ? requestor.getClassName() : requestor;
        vtkWarningMacro8("".concat(requestStr, " did not request an animation"));
      }
      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0 && Date.now() > model._animationExtendedEnd) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.switchToXRAnimation = function() {
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.xrAnimation = true;
  };
  publicAPI.returnFromXRAnimation = function() {
    model.xrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.recentAnimationFrameRate = 10;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };
  publicAPI.updateXRGamepads = function(xrSession, xrFrame, xrRefSpace) {
    xrSession.inputSources.forEach(function(inputSource) {
      var gripPose = inputSource.gripSpace == null ? null : xrFrame.getPose(inputSource.gripSpace, xrRefSpace);
      var gp = inputSource.gamepad;
      var hand = inputSource.handedness;
      if (gp) {
        if (!(gp.index in model.lastGamepadValues)) {
          model.lastGamepadValues[gp.index] = {
            left: {
              buttons: {}
            },
            right: {
              buttons: {}
            }
          };
        }
        for (var b = 0; b < gp.buttons.length; ++b) {
          if (!(b in model.lastGamepadValues[gp.index][hand].buttons)) {
            model.lastGamepadValues[gp.index][hand].buttons[b] = false;
          }
          if (model.lastGamepadValues[gp.index][hand].buttons[b] !== gp.buttons[b].pressed && gripPose != null) {
            publicAPI.button3DEvent({
              gamepad: gp,
              position: gripPose.transform.position,
              orientation: gripPose.transform.orientation,
              pressed: gp.buttons[b].pressed,
              device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController,
              input: deviceInputMap[gp.mapping] && deviceInputMap[gp.mapping][b] ? deviceInputMap[gp.mapping][b] : Input2.Trigger
            });
            model.lastGamepadValues[gp.index][hand].buttons[b] = gp.buttons[b].pressed;
          }
          if (model.lastGamepadValues[gp.index][hand].buttons[b] && gripPose != null) {
            publicAPI.move3DEvent({
              gamepad: gp,
              position: gripPose.transform.position,
              orientation: gripPose.transform.orientation,
              device: inputSource.handedness === "left" ? Device2.LeftController : Device2.RightController
            });
          }
        }
      }
    });
  };
  publicAPI.handleMouseMove = function(event2) {
    var callData = _objectSpread18(_objectSpread18({}, getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }
    model.moveTimeoutID = setTimeout(function() {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleAnimation = function() {
    var currTime = Date.now();
    model._animationFrameCount++;
    if (currTime - model._animationStartTime > 1e3 && model._animationFrameCount > 1) {
      model.recentAnimationFrameRate = 1e3 * (model._animationFrameCount - 1) / (currTime - model._animationStartTime);
      model.lastFrameTime = 1 / model.recentAnimationFrameRate;
      publicAPI.animationFrameRateUpdateEvent();
      model._animationStartTime = currTime;
      model._animationFrameCount = 1;
    }
    publicAPI.animationEvent();
    forceRender();
    if (animationRequesters.size > 0 || Date.now() < model._animationExtendedEnd) {
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    } else {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };
  publicAPI.handleWheel = function(event2) {
    preventDefault(event2);
    var callData = _objectSpread18(_objectSpread18(_objectSpread18({}, normalizeWheel2(event2)), getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }
    model.wheelTimeoutID = setTimeout(function() {
      publicAPI.extendAnimation(600);
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    }, 200);
  };
  publicAPI.handleMouseEnter = function(event2) {
    var callData = _objectSpread18(_objectSpread18({}, getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    publicAPI.mouseEnterEvent(callData);
  };
  publicAPI.handleMouseLeave = function(event2) {
    var callData = _objectSpread18(_objectSpread18({}, getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    publicAPI.mouseLeaveEvent(callData);
  };
  publicAPI.handleMouseUp = function(event2) {
    interactionRegistration(false);
    preventDefault(event2);
    var callData = _objectSpread18(_objectSpread18({}, getModifierKeysFor(event2)), {}, {
      position: getScreenEventPositionFor(event2)
    });
    switch (event2.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        vtkErrorMacro19("Unknown mouse button released: ".concat(event2.button));
        break;
    }
  };
  publicAPI.handleTouchStart = function(event2) {
    interactionRegistration(true);
    preventDefault(event2);
    if (model.recognizeGestures && event2.touches.length > 1) {
      var positions = getTouchEventPositionsFor(event2.touches);
      if (event2.touches.length === 2) {
        var touch = event2.touches[0];
        var callData = {
          position: getScreenEventPositionFor(touch),
          shiftKey: false,
          altKey: false,
          controlKey: false
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      publicAPI.recognizeGesture("TouchStart", positions);
    } else {
      var _touch = event2.touches[0];
      var _callData = {
        position: getScreenEventPositionFor(_touch),
        shiftKey: false,
        altKey: false,
        controlKey: false
      };
      publicAPI.leftButtonPressEvent(_callData);
    }
  };
  publicAPI.handleTouchMove = function(event2) {
    preventDefault(event2);
    if (model.recognizeGestures && event2.touches.length > 1) {
      var positions = getTouchEventPositionsFor(event2.touches);
      publicAPI.recognizeGesture("TouchMove", positions);
    } else {
      var touch = event2.touches[0];
      var callData = {
        position: getScreenEventPositionFor(touch),
        shiftKey: false,
        altKey: false,
        controlKey: false
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };
  publicAPI.handleTouchEnd = function(event2) {
    preventDefault(event2);
    if (model.recognizeGestures) {
      if (event2.touches.length === 0) {
        if (event2.changedTouches.length === 1) {
          var touch = event2.changedTouches[0];
          var callData = {
            position: getScreenEventPositionFor(touch),
            shiftKey: false,
            altKey: false,
            controlKey: false
          };
          publicAPI.leftButtonReleaseEvent(callData);
          interactionRegistration(false);
        } else {
          var positions = getTouchEventPositionsFor(event2.changedTouches);
          publicAPI.recognizeGesture("TouchEnd", positions);
          interactionRegistration(false);
        }
      } else if (event2.touches.length === 1) {
        var _positions = getTouchEventPositionsFor(event2.changedTouches);
        publicAPI.recognizeGesture("TouchEnd", _positions);
        var _touch2 = event2.touches[0];
        var _callData2 = {
          position: getScreenEventPositionFor(_touch2),
          shiftKey: false,
          altKey: false,
          controlKey: false
        };
        publicAPI.leftButtonPressEvent(_callData2);
      } else {
        var _positions2 = getTouchEventPositionsFor(event2.touches);
        publicAPI.recognizeGesture("TouchMove", _positions2);
      }
    } else {
      var _touch3 = event2.changedTouches[0];
      var _callData3 = {
        position: getScreenEventPositionFor(_touch3),
        shiftKey: false,
        altKey: false,
        controlKey: false
      };
      publicAPI.leftButtonReleaseEvent(_callData3);
      interactionRegistration(false);
    }
  };
  publicAPI.setView = function(val) {
    if (model._view === val) {
      return;
    }
    model._view = val;
    model._view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };
  publicAPI.getFirstRenderer = function() {
    var _model$_view, _model$_view$getRende, _model$_view$getRende2;
    return (_model$_view = model._view) === null || _model$_view === void 0 ? void 0 : (_model$_view$getRende = _model$_view.getRenderable()) === null || _model$_view$getRende === void 0 ? void 0 : (_model$_view$getRende2 = _model$_view$getRende.getRenderersByReference()) === null || _model$_view$getRende2 === void 0 ? void 0 : _model$_view$getRende2[0];
  };
  publicAPI.findPokedRenderer = function() {
    var _model$_view2, _model$_view2$getRend;
    var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!model._view) {
      return null;
    }
    var rc = (_model$_view2 = model._view) === null || _model$_view2 === void 0 ? void 0 : (_model$_view2$getRend = _model$_view2.getRenderable()) === null || _model$_view2$getRend === void 0 ? void 0 : _model$_view2$getRend.getRenderers();
    if (!rc) {
      return null;
    }
    rc.sort(function(a, b) {
      return a.getLayer() - b.getLayer();
    });
    var interactiveren = null;
    var viewportren = null;
    var currentRenderer = null;
    var count = rc.length;
    while (count--) {
      var aren = rc[count];
      if (model._view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }
      if (interactiveren === null && aren.getInteractive()) {
        interactiveren = aren;
      }
      if (viewportren === null && model._view.isInViewport(x, y, aren)) {
        viewportren = aren;
      }
    }
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }
    return currentRenderer;
  };
  publicAPI.render = function() {
    if (!publicAPI.isAnimating() && !model.inRender) {
      forceRender();
    }
  };
  handledEvents.forEach(function(eventName) {
    var lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI["".concat(lowerFirst, "Event")] = function(arg) {
      if (!model.enabled) {
        return;
      }
      var renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro2("\n          Can not forward events without a current renderer on the interactor.\n        ");
        return;
      }
      var callData = _objectSpread18({
        type: eventName,
        pokedRenderer: model.currentRenderer,
        firstRenderer: publicAPI.getFirstRenderer()
      }, arg);
      publicAPI["invoke".concat(eventName)](callData);
    };
  });
  publicAPI.recognizeGesture = function(event2, positions) {
    if (Object.keys(positions).length > 2) {
      return;
    }
    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }
    if (event2 === "TouchStart") {
      Object.keys(positions).forEach(function(key) {
        model.startingEventPositions[key] = positions[key];
      });
      model.currentGesture = "Start";
      return;
    }
    if (event2 === "TouchEnd") {
      if (model.currentGesture === "Pinch") {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === "Rotate") {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === "Pan") {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = "Start";
      model.startingEventPositions = {};
      return;
    }
    var count = 0;
    var posVals = [];
    var startVals = [];
    Object.keys(positions).forEach(function(key) {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });
    var originalDistance = Math.sqrt((startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) + (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y));
    var newDistance = Math.sqrt((posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) + (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y));
    var originalAngle = degreesFromRadians(Math.atan2(startVals[1].y - startVals[0].y, startVals[1].x - startVals[0].x));
    var newAngle = degreesFromRadians(Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x));
    var angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180 >= 360 ? newAngle - 180 : newAngle + 180;
    originalAngle = originalAngle + 180 >= 360 ? originalAngle - 180 : originalAngle + 180;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }
    var trans = [];
    trans[0] = (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2;
    trans[1] = (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2;
    if (event2 === "TouchMove") {
      if (model.currentGesture === "Start") {
        var thresh = 0.01 * Math.sqrt(model.container.clientWidth * model.container.clientWidth + model.container.clientHeight * model.container.clientHeight);
        if (thresh < 15) {
          thresh = 15;
        }
        var pinchDistance = Math.abs(newDistance - originalDistance);
        var rotateDistance = newDistance * 3.1415926 * Math.abs(angleDeviation) / 360;
        var panDistance = Math.sqrt(trans[0] * trans[0] + trans[1] * trans[1]);
        if (pinchDistance > thresh && pinchDistance > rotateDistance && pinchDistance > panDistance) {
          model.currentGesture = "Pinch";
          var callData = {
            scale: 1,
            touches: positions
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = "Rotate";
          var _callData4 = {
            rotation: 0,
            touches: positions
          };
          publicAPI.startRotateEvent(_callData4);
        } else if (panDistance > thresh) {
          model.currentGesture = "Pan";
          var _callData5 = {
            translation: [0, 0],
            touches: positions
          };
          publicAPI.startPanEvent(_callData5);
        }
      } else {
        if (model.currentGesture === "Rotate") {
          var _callData6 = {
            rotation: angleDeviation,
            touches: positions
          };
          publicAPI.rotateEvent(_callData6);
        }
        if (model.currentGesture === "Pinch") {
          var _callData7 = {
            scale: newDistance / originalDistance,
            touches: positions
          };
          publicAPI.pinchEvent(_callData7);
        }
        if (model.currentGesture === "Pan") {
          var _callData8 = {
            translation: trans,
            touches: positions
          };
          publicAPI.panEvent(_callData8);
        }
      }
    }
  };
  publicAPI.handleVisibilityChange = function() {
    model._animationStartTime = Date.now();
    model._animationFrameCount = 0;
  };
  publicAPI.setCurrentRenderer = function(r) {
    model._forcedRenderer = !!r;
    model.currentRenderer = r;
  };
  var superDelete = publicAPI.delete;
  publicAPI.delete = function() {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== "undefined") {
      document.removeEventListener("visibilitychange", publicAPI.handleVisibilityChange);
    }
    superDelete();
  };
  if (typeof document.hidden !== "undefined") {
    document.addEventListener("visibilitychange", publicAPI.handleVisibilityChange, false);
  }
}
function extend60(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES60, initialValues);
  macro.obj(publicAPI, model);
  model._animationExtendedEnd = 0;
  macro.event(publicAPI, model, "RenderEvent");
  handledEvents.forEach(function(eventName) {
    return macro.event(publicAPI, model, eventName);
  });
  macro.get(publicAPI, model, ["initialized", "container", "interactorStyle", "lastFrameTime", "recentAnimationFrameRate", "_view"]);
  macro.setGet(publicAPI, model, ["lightFollowCamera", "enabled", "enableRender", "recognizeGestures", "desiredUpdateRate", "stillUpdateRate", "picker"]);
  macro.moveToProtected(publicAPI, model, ["view"]);
  vtkRenderWindowInteractor(publicAPI, model);
}
var Device2, Input2, vtkWarningMacro8, vtkErrorMacro19, normalizeWheel2, vtkOnceErrorMacro2, deviceInputMap, handledEvents, DEFAULT_VALUES60, newInstance61, vtkRenderWindowInteractor$1;
var init_RenderWindowInteractor = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/RenderWindowInteractor.js"() {
    init_defineProperty();
    init_macros();
    init_Math();
    init_Constants16();
    Device2 = Constants13.Device;
    Input2 = Constants13.Input;
    vtkWarningMacro8 = macro.vtkWarningMacro;
    vtkErrorMacro19 = macro.vtkErrorMacro;
    normalizeWheel2 = macro.normalizeWheel;
    vtkOnceErrorMacro2 = macro.vtkOnceErrorMacro;
    deviceInputMap = {
      "xr-standard": [Input2.Trigger, Input2.Grip, Input2.TrackPad, Input2.Thumbstick, Input2.A, Input2.B]
    };
    handledEvents = ["StartAnimation", "Animation", "EndAnimation", "MouseEnter", "MouseLeave", "StartMouseMove", "MouseMove", "EndMouseMove", "LeftButtonPress", "LeftButtonRelease", "MiddleButtonPress", "MiddleButtonRelease", "RightButtonPress", "RightButtonRelease", "KeyPress", "KeyDown", "KeyUp", "StartMouseWheel", "MouseWheel", "EndMouseWheel", "StartPinch", "Pinch", "EndPinch", "StartPan", "Pan", "EndPan", "StartRotate", "Rotate", "EndRotate", "Button3D", "Move3D", "StartPointerLock", "EndPointerLock", "StartInteraction", "Interaction", "EndInteraction", "AnimationFrameRateUpdate"];
    DEFAULT_VALUES60 = {
      renderWindow: null,
      interactorStyle: null,
      picker: null,
      pickingManager: null,
      initialized: false,
      enabled: false,
      enableRender: true,
      currentRenderer: null,
      lightFollowCamera: true,
      desiredUpdateRate: 30,
      stillUpdateRate: 2,
      container: null,
      recognizeGestures: true,
      currentGesture: "Start",
      animationRequest: null,
      lastFrameTime: 0.1,
      recentAnimationFrameRate: 10,
      wheelTimeoutID: 0,
      moveTimeoutID: 0,
      lastGamepadValues: {}
    };
    newInstance61 = macro.newInstance(extend60, "vtkRenderWindowInteractor");
    vtkRenderWindowInteractor$1 = _objectSpread18({
      newInstance: newInstance61,
      extend: extend60,
      handledEvents
    }, Constants13);
  }
});

// node_modules/@kitware/vtk.js/Common/Core/Points.js
var Points_exports = {};
__export(Points_exports, {
  default: () => vtkPoints$1,
  extend: () => extend61,
  newInstance: () => newInstance62
});
function vtkPoints(publicAPI, model) {
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    var dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    var offset = idx * model.numberOfComponents;
    for (var i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = i + 1 < 1 || arguments.length <= i + 1 ? void 0 : arguments[i + 1];
    }
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.getBounds = function() {
    if (publicAPI.getNumberOfComponents() === 3) {
      var _xRange = publicAPI.getRange(0);
      model.bounds[0] = _xRange[0];
      model.bounds[1] = _xRange[1];
      var _yRange = publicAPI.getRange(1);
      model.bounds[2] = _yRange[0];
      model.bounds[3] = _yRange[1];
      var zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }
    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro20("getBounds called on an array with components of\n        ".concat(publicAPI.getNumberOfComponents()));
      return INVALID_BOUNDS;
    }
    var xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    var yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;
    return model.bounds;
  };
  publicAPI.computeBounds = publicAPI.getBounds;
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
function extend61(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES61, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}
var vtkErrorMacro20, INVALID_BOUNDS, DEFAULT_VALUES61, newInstance62, vtkPoints$1;
var init_Points = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/Points.js"() {
    init_macros();
    init_DataArray();
    init_Constants2();
    vtkErrorMacro20 = macro.vtkErrorMacro;
    INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];
    DEFAULT_VALUES61 = {
      empty: true,
      numberOfComponents: 3,
      dataType: VtkDataTypes.FLOAT,
      bounds: [1, -1, 1, -1, 1, -1]
    };
    newInstance62 = macro.newInstance(extend61, "vtkPoints");
    vtkPoints$1 = {
      newInstance: newInstance62,
      extend: extend61
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
function ownKeys19(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread19(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys19(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys19(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function extractCellSizes(cellArray) {
  var currentIdx = 0;
  return cellArray.filter(function(value, index) {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  return extractCellSizes(cellArray).length;
}
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  publicAPI.getNumberOfCells = function(recompute) {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    model.cellSizes = extractCellSizes(model.values);
    model.numberOfCells = model.cellSizes.length;
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = function(recompute) {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(model.values);
    return model.cellSizes;
  };
  var superSetData = publicAPI.setData;
  publicAPI.setData = function(typedArray) {
    superSetData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = function(loc) {
    var cellLoc = loc;
    var numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
}
function defaultValues(initialValues) {
  return _objectSpread19({
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT
  }, initialValues);
}
function extend62(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues(initialValues));
  vtkCellArray(publicAPI, model);
}
var STATIC6, newInstance63, vtkCellArray$1;
var init_CellArray = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/CellArray.js"() {
    init_defineProperty();
    init_macros();
    init_DataArray();
    init_Constants2();
    STATIC6 = {
      extractCellSizes,
      getNumberOfCells
    };
    newInstance63 = macro.newInstance(extend62, "vtkCellArray");
    vtkCellArray$1 = _objectSpread19({
      newInstance: newInstance63,
      extend: extend62
    }, STATIC6);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    var pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (var i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      var triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      var pointsData = points.getData();
      model.pointsIds.forEach(function(pointId, index) {
        var pointOffset = 3 * pointId;
        var trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = function() {
    var nbPoints = model.points.getNumberOfPoints();
    var x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];
      for (var i = 1; i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      uninitializeBounds(model.bounds);
    }
    return model.bounds;
  };
  publicAPI.getLength2 = function() {
    publicAPI.getBounds();
    var length = 0;
    var diff = 0;
    for (var i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length += diff * diff;
    }
    return length;
  };
  publicAPI.getParametricDistance = function(pcoords) {
    var pDist;
    var pDistMax = 0;
    for (var i = 0; i < 3; i++) {
      if (pcoords[i] < 0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1) {
        pDist = pcoords[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = function() {
    return model.points.getNumberOfPoints();
  };
  publicAPI.deepCopy = function(cell) {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = function() {
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, t, x, pcoords, subId) {
  };
  publicAPI.evaluatePosition = function(x, closestPoint, subId, pcoords, dist2, weights) {
  };
}
function extend63(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES62, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var DEFAULT_VALUES62, newInstance64, vtkCell$1;
var init_Cell = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/Cell.js"() {
    init_macros();
    init_Math();
    init_Points();
    DEFAULT_VALUES62 = {
      bounds: [-1, -1, -1, -1, -1, -1],
      pointsIds: []
    };
    newInstance64 = macro.newInstance(extend63, "vtkCell");
    vtkCell$1 = {
      newInstance: newInstance64,
      extend: extend63
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  var newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length) {
    model.array.push({
      ncells: 0,
      cells: null
    });
  }
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = function(data) {
    var numPts = data.getPoints().getNumberOfPoints();
    var numCells = data.getNumberOfCells();
    var linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (var cellId = 0; cellId < numCells; ++cellId) {
        var _data$getCellPoints = data.getCellPoints(cellId), cellPointIds = _data$getCellPoints.cellPointIds;
        cellPointIds.forEach(function(cellPointId) {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      var _loop = function _loop3(_cellId4) {
        var _data$getCellPoints2 = data.getCellPoints(_cellId4), cellPointIds2 = _data$getCellPoints2.cellPointIds;
        cellPointIds2.forEach(function(cellPointId) {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId4);
        });
      };
      for (var _cellId = 0; _cellId < numCells; ++_cellId) {
        _loop(_cellId);
      }
    } else {
      for (var _cellId2 = 0; _cellId2 < numCells; _cellId2++) {
        var cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach(function(cellPointId) {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      var _loop2 = function _loop22(_cellId32) {
        var cell2 = vtkCell$1.newInstance();
        cell2.getPointsIds().forEach(function(cellPointId) {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, _cellId32);
        });
      };
      for (var _cellId3 = 0; _cellId3 < numCells; ++_cellId3) {
        _loop2(_cellId3);
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    var ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(function() {
      return {
        ncells: 0,
        cells: null
      };
    });
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = function() {
    model.array = null;
  };
  publicAPI.getLink = function(ptId) {
    return model.array[ptId];
  };
  publicAPI.getNcells = function(ptId) {
    return model.array[ptId].ncells;
  };
  publicAPI.getCells = function(ptId) {
    return model.array[ptId].cells;
  };
  publicAPI.insertNextPoint = function(numLinks) {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = function(ptId, cellId) {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = function(ptId) {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = function(cellId, ptId) {
    model.array[ptId].cells = model.array[ptId].cells.filter(function(cell) {
      return cell !== cellId;
    });
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = function(cellId, ptId) {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = function(ptId, size) {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = function() {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = function() {
    model.maxId = -1;
  };
  publicAPI.deepCopy = function(src) {
    model.array = _toConsumableArray(src.array);
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = function(ptId) {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = function(n) {
    for (var i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = function(ptId, pos, cellId) {
    model.array[ptId].cells[pos] = cellId;
  };
}
function extend64(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES63, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var DEFAULT_VALUES63, newInstance65, vtkCellLinks$1;
var init_CellLinks = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js"() {
    init_toConsumableArray();
    init_macros();
    init_Cell();
    DEFAULT_VALUES63 = {
      array: null,
      maxId: 0,
      extend: 0
    };
    newInstance65 = macro.newInstance(extend64, "vtkCellLinks");
    vtkCellLinks$1 = {
      newInstance: newInstance65,
      extend: extend64
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType, CellTypesStrings;
var init_Constants17 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js"() {
    CellType = {
      VTK_EMPTY_CELL: 0,
      VTK_VERTEX: 1,
      VTK_POLY_VERTEX: 2,
      VTK_LINE: 3,
      VTK_POLY_LINE: 4,
      VTK_TRIANGLE: 5,
      VTK_TRIANGLE_STRIP: 6,
      VTK_POLYGON: 7,
      VTK_PIXEL: 8,
      VTK_QUAD: 9,
      VTK_TETRA: 10,
      VTK_VOXEL: 11,
      VTK_HEXAHEDRON: 12,
      VTK_WEDGE: 13,
      VTK_PYRAMID: 14,
      VTK_PENTAGONAL_PRISM: 15,
      VTK_HEXAGONAL_PRISM: 16,
      VTK_QUADRATIC_EDGE: 21,
      VTK_QUADRATIC_TRIANGLE: 22,
      VTK_QUADRATIC_QUAD: 23,
      VTK_QUADRATIC_POLYGON: 36,
      VTK_QUADRATIC_TETRA: 24,
      VTK_QUADRATIC_HEXAHEDRON: 25,
      VTK_QUADRATIC_WEDGE: 26,
      VTK_QUADRATIC_PYRAMID: 27,
      VTK_BIQUADRATIC_QUAD: 28,
      VTK_TRIQUADRATIC_HEXAHEDRON: 29,
      VTK_QUADRATIC_LINEAR_QUAD: 30,
      VTK_QUADRATIC_LINEAR_WEDGE: 31,
      VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
      VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
      VTK_BIQUADRATIC_TRIANGLE: 34,
      VTK_CUBIC_LINE: 35,
      VTK_CONVEX_POINT_SET: 41,
      VTK_POLYHEDRON: 42,
      VTK_PARAMETRIC_CURVE: 51,
      VTK_PARAMETRIC_SURFACE: 52,
      VTK_PARAMETRIC_TRI_SURFACE: 53,
      VTK_PARAMETRIC_QUAD_SURFACE: 54,
      VTK_PARAMETRIC_TETRA_REGION: 55,
      VTK_PARAMETRIC_HEX_REGION: 56,
      VTK_HIGHER_ORDER_EDGE: 60,
      VTK_HIGHER_ORDER_TRIANGLE: 61,
      VTK_HIGHER_ORDER_QUAD: 62,
      VTK_HIGHER_ORDER_POLYGON: 63,
      VTK_HIGHER_ORDER_TETRAHEDRON: 64,
      VTK_HIGHER_ORDER_WEDGE: 65,
      VTK_HIGHER_ORDER_PYRAMID: 66,
      VTK_HIGHER_ORDER_HEXAHEDRON: 67,
      VTK_LAGRANGE_CURVE: 68,
      VTK_LAGRANGE_TRIANGLE: 69,
      VTK_LAGRANGE_QUADRILATERAL: 70,
      VTK_LAGRANGE_TETRAHEDRON: 71,
      VTK_LAGRANGE_HEXAHEDRON: 72,
      VTK_LAGRANGE_WEDGE: 73,
      VTK_LAGRANGE_PYRAMID: 74,
      VTK_NUMBER_OF_CELL_TYPES: 75
    };
    CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function ownKeys20(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread20(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys20(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys20(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    var sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
    var ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = function(cellId, type, loc) {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = function(type, loc) {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = function(ncells, cellTypes, cellLocations) {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = function(cellId) {
    return model.locationArray[cellId];
  };
  publicAPI.deleteCell = function(cellId) {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = function() {
    return model.maxId + 1;
  };
  publicAPI.isType = function(type) {
    var numTypes = publicAPI.getNumberOfTypes();
    for (var i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = function(type) {
    return publicAPI.insertNextCell(type, -1);
  };
  publicAPI.getCellType = function(cellId) {
    return model.typeArray[cellId];
  };
  publicAPI.reset = function() {
    model.maxId = -1;
  };
  publicAPI.deepCopy = function(src) {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
function extend65(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES64, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var STATIC7, DEFAULT_VALUES64, newInstance66, vtkCellTypes$1;
var init_CellTypes = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js"() {
    init_defineProperty();
    init_macros();
    init_Constants17();
    STATIC7 = {
      getClassNameFromTypeId,
      getTypeIdFromClassName,
      isLinear
    };
    DEFAULT_VALUES64 = {
      size: 0,
      maxId: -1,
      extend: 1e3
    };
    newInstance66 = macro.newInstance(extend65, "vtkCellTypes");
    vtkCellTypes$1 = _objectSpread20({
      newInstance: newInstance66,
      extend: extend65
    }, STATIC7);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState, Constants14;
var init_Constants18 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js"() {
    IntersectionState = {
      NO_INTERSECTION: 0,
      YES_INTERSECTION: 1,
      ON_LINE: 2
    };
    Constants14 = {
      IntersectionState
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/Line.js
function ownKeys21(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread21(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys21(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys21(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function distanceToLine(x, p1, p2) {
  var closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  var outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  var p21 = [];
  var closest;
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];
  var num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  var denom = dot(p21, p21);
  var tolerance = 1e-5 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x);
  return outObj;
}
function intersection(a1, a2, b1, b2, u, v) {
  var a21 = [];
  var b21 = [];
  var b1a1 = [];
  u[0] = 0;
  v[0] = 0;
  a21[0] = a2[0] - a1[0];
  a21[1] = a2[1] - a1[1];
  a21[2] = a2[2] - a1[2];
  b21[0] = b2[0] - b1[0];
  b21[1] = b2[1] - b1[1];
  b21[2] = b2[2] - b1[2];
  b1a1[0] = b1[0] - a1[0];
  b1a1[1] = b1[1] - a1[1];
  b1a1[2] = b1[2] - a1[2];
  var A = [];
  A[0] = [dot(a21, a21), -dot(a21, b21)];
  A[1] = [A[0][1], dot(b21, b21)];
  var c = [];
  c[0] = dot(a21, b1a1);
  c[1] = -dot(b21, b1a1);
  if (solveLinearSystem(A, c, 2) === 0) {
    var minDist = Number.MAX_VALUE;
    var p = [a1, a2, b1, b2];
    var l1 = [b1, b1, a1, a1];
    var l2 = [b2, b2, a2, a2];
    var uv1 = [v[0], v[0], u[0], u[0]];
    var uv2 = [u[0], u[0], v[0], v[0]];
    var obj2;
    for (var i = 0; i < 4; i++) {
      obj2 = distanceToLine(p[i], l1[i], l2[i]);
      if (obj2.distance < minDist) {
        minDist = obj2.distance;
        uv1[i] = obj2.t;
        uv2[i] = i % 2;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];
  if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t) {
    return t >= 0 && t <= 1;
  }
  publicAPI.getCellDimension = function() {
    return 1;
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, x, pcoords) {
    var outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    var projXYZ = [];
    var a1 = [];
    var a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    var u = [];
    var v = [];
    var intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect === IntersectionState2.YES_INTERSECTION) {
      for (var i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      var outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluatePosition = function(x, closestPoint, subId, pcoords, dist2, weights) {
  };
}
function extend66(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES65, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkLine(publicAPI, model);
}
var IntersectionState2, STATIC8, DEFAULT_VALUES65, newInstance67, vtkLine$1;
var init_Line = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/Line.js"() {
    init_defineProperty();
    init_macros();
    init_Constants18();
    init_Cell();
    init_Math();
    IntersectionState2 = Constants14.IntersectionState;
    STATIC8 = {
      distanceToLine,
      intersection
    };
    DEFAULT_VALUES65 = {};
    newInstance67 = macro.newInstance(extend66, "vtkLine");
    vtkLine$1 = _objectSpread21(_objectSpread21({
      newInstance: newInstance67,
      extend: extend66
    }, STATIC8), Constants14);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = function() {
    return model.points.getNumberOfPoints();
  };
  publicAPI.getBounds = function() {
    return model.points.getBounds();
  };
  publicAPI.computeBounds = function() {
    publicAPI.getBounds();
  };
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}
function extend67(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES66, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var DEFAULT_VALUES66, newInstance68, vtkPointSet$1;
var init_PointSet = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js"() {
    init_vtk();
    init_macros();
    init_DataSet();
    init_Points();
    DEFAULT_VALUES66 = {};
    newInstance68 = macro.newInstance(extend67, "vtkPointSet");
    vtkPointSet$1 = {
      newInstance: newInstance68,
      extend: extend67
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function ownKeys22(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread22(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys22(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys22(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function computeNormalDirection(v1, v2, v3, n) {
  var ax = v3[0] - v2[0];
  var ay = v3[1] - v2[1];
  var az = v3[2] - v2[2];
  var bx = v1[0] - v2[0];
  var by = v1[1] - v2[1];
  var bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  var length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  var tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
  var coplanar = false;
  var pt1 = [];
  var pt2 = [];
  var surfaceId = [];
  var n1 = [];
  var n2 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  var s1 = -dot(n1, p1);
  var s2 = -dot(n2, p2);
  var dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  var dist2 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];
  if (dist2[0] * dist2[1] > tolerance && dist2[0] * dist2[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  var pts1 = [p1, q1, r1];
  var pts2 = [p2, q2, r2];
  var n1n2 = dot(n1, n2);
  var a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1);
  var b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  var p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  var v = cross(n1, n2, []);
  normalize(v);
  var index1 = 0;
  var index2 = 0;
  var t1 = [];
  var t2 = [];
  var ts1 = 50;
  var ts2 = 50;
  for (var i = 0; i < 3; i++) {
    var id1 = i;
    var id2 = (i + 1) % 3;
    var val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t1[index1++] = dot(val1.x, v) - dot(p, v);
    }
    var val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t2[index2++] = dot(val2.x, v) - dot(p, v);
    }
  }
  if (index1 > 2) {
    index1--;
    var t12 = t1[2];
    t1[2] = t1[ts1];
    t1[ts1] = t12;
  }
  if (index2 > 2) {
    index2--;
    var t22 = t2[2];
    t2[2] = t2[ts2];
    t2[ts2] = t22;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t1[0]) || Number.isNaN(t1[1]) || Number.isNaN(t2[0]) || Number.isNaN(t2[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] > t1[1]) {
    var t11 = t1[1];
    t1[1] = t1[0];
    t1[0] = t11;
  }
  if (t2[0] > t2[1]) {
    var t21 = t2[1];
    t2[1] = t2[0];
    t2[0] = t21;
  }
  var tt1;
  var tt2;
  if (t1[1] < t2[0] || t2[1] < t1[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t1[0] < t2[0]) {
    if (t1[1] < t2[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t2[0];
      tt2 = t1[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t2[0];
      tt2 = t2[1];
    }
  } else if (t1[1] < t2[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t1[0];
    tt2 = t1[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t1[0];
    tt2 = t2[1];
  }
  multiplyAccumulate(p, v, tt1, pt1);
  multiplyAccumulate(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = function() {
    return 2;
  };
  publicAPI.intersectWithLine = function(p1, p2, tol, x, pcoords) {
    var outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    var closestPoint = [];
    var tol2 = tol * tol;
    var pt1 = [];
    var pt2 = [];
    var pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    var n = [];
    var weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      var plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      var inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    var dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    var dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    var dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    var intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      var pt3Pt1 = [];
      var pt3Pt2 = [];
      var pt3X = [];
      for (var i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = function(x, closestPoint, pcoords, weights) {
    var outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    var i;
    var j;
    var pt1 = [];
    var pt2 = [];
    var pt3 = [];
    var n = [];
    var fabsn;
    var rhs = [];
    var c1 = [];
    var c2 = [];
    var det = 0;
    var idx = 0;
    var indices = [];
    var dist2Point;
    var dist2Line1;
    var dist2Line2;
    var closest = [];
    var closestPoint1 = [];
    var closestPoint2 = [];
    var cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);
    vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
    var maxComponent = 0;
    for (i = 0; i < 3; i++) {
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = determinant2x2(c1, c2);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c2) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      var t;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0) {
          var lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          var _lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = _lineDistance.distance;
        } else if (weights[2] < 0) {
          var _lineDistance2 = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = _lineDistance2.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = function(pcoords, x, weights) {
    var p0 = [];
    var p1 = [];
    var p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    var u3 = 1 - pcoords[0] - pcoords[1];
    for (var i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = function(pcoords) {
    var pDist;
    var pDistMax = 0;
    var pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1 - pcoords[0] - pcoords[1];
    for (var i = 0; i < 3; i++) {
      if (pc[i] < 0) {
        pDist = -pc[i];
      } else if (pc[i] > 1) {
        pDist = pc[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}
function extend68(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES67, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var STATIC9, DEFAULT_VALUES67, newInstance69, vtkTriangle$1;
var init_Triangle = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js"() {
    init_defineProperty();
    init_macros();
    init_Cell();
    init_Math();
    init_Line();
    init_Plane();
    STATIC9 = {
      computeNormalDirection,
      computeNormal,
      intersectWithTriangle
    };
    DEFAULT_VALUES67 = {};
    newInstance69 = macro.newInstance(extend68, "vtkTriangle");
    vtkTriangle$1 = _objectSpread22({
      newInstance: newInstance69,
      extend: extend68
    }, STATIC9);
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS;
var init_Constants19 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js"() {
    POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var PolyData_exports = {};
__export(PolyData_exports, {
  CELL_FACTORY: () => CELL_FACTORY,
  default: () => vtkPolyData$1,
  extend: () => extend69,
  newInstance: () => newInstance70
});
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w)/g, function(letter) {
      return letter.toUpperCase();
    }).replace(/\s+/g, "");
  }
  POLYDATA_FIELDS.forEach(function(type) {
    publicAPI["getNumberOf".concat(camelize(type))] = function() {
      return model[type].getNumberOfCells();
    };
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
  });
  publicAPI.getNumberOfCells = function() {
    return POLYDATA_FIELDS.reduce(function(num, cellType) {
      return num + model[cellType].getNumberOfCells();
    }, 0);
  };
  var superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    var debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach(function(type) {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  publicAPI.buildCells = function() {
    var nVerts = publicAPI.getNumberOfVerts();
    var nLines = publicAPI.getNumberOfLines();
    var nPolys = publicAPI.getNumberOfPolys();
    var nStrips = publicAPI.getNumberOfStrips();
    var nCells = nVerts + nLines + nPolys + nStrips;
    var types = new Uint8Array(nCells);
    var pTypes = types;
    var locs = new Uint32Array(nCells);
    var pLocs = locs;
    if (nVerts) {
      var nextCellPts = 0;
      model.verts.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = nextCellPts;
        pTypes[index] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      var _nextCellPts = 0;
      model.lines.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts;
        pTypes[index] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro9("Building VTK_LINE ", index, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        _nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      var _nextCellPts2 = 0;
      model.polys.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts2;
        switch (numCellPts) {
          case 3:
            pTypes[index] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro9("Building VTK_TRIANGLE ", index, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        _nextCellPts2 += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      var _nextCellPts3 = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach(function(numCellPts, index) {
        pLocs[index] = _nextCellPts3;
        _nextCellPts3 += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    var initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells === void 0) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = function(cellId) {
    return model.cells.getCellType(cellId);
  };
  publicAPI.getCellPoints = function(cellId) {
    var cellType = publicAPI.getCellType(cellId);
    var cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    var loc = model.cells.getCellLocation(cellId);
    var cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = function(ptId) {
    return model.links.getCells(ptId);
  };
  publicAPI.getCellEdgeNeighbors = function(cellId, point1, point2) {
    var link1 = model.links.getLink(point1);
    var link2 = model.links.getLink(point2);
    return link1.cells.filter(function(cell) {
      return cell !== cellId && link2.cells.indexOf(cell) !== -1;
    });
  };
  publicAPI.getCell = function(cellId) {
    var cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    var cellInfo = publicAPI.getCellPoints(cellId);
    var cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}
function extend69(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES68, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var _CELL_FACTORY, vtkWarningMacro9, CELL_FACTORY, DEFAULT_VALUES68, newInstance70, vtkPolyData$1;
var init_PolyData = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js"() {
    init_defineProperty();
    init_macros();
    init_vtk();
    init_CellArray();
    init_CellLinks();
    init_CellTypes();
    init_Line();
    init_PointSet();
    init_Triangle();
    init_Constants17();
    init_Constants19();
    vtkWarningMacro9 = macro.vtkWarningMacro;
    CELL_FACTORY = (_CELL_FACTORY = {}, _defineProperty(_CELL_FACTORY, CellType.VTK_LINE, vtkLine$1), _defineProperty(_CELL_FACTORY, CellType.VTK_POLY_LINE, vtkLine$1), _defineProperty(_CELL_FACTORY, CellType.VTK_TRIANGLE, vtkTriangle$1), _CELL_FACTORY);
    DEFAULT_VALUES68 = {};
    newInstance70 = macro.newInstance(extend69, "vtkPolyData");
    vtkPolyData$1 = {
      newInstance: newInstance70,
      extend: extend69
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
var Actor_exports = {};
__export(Actor_exports, {
  default: () => vtkActor$1,
  extend: () => extend70,
  newInstance: () => newInstance71
});
function ownKeys23(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread23(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys23(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys23(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkActor(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  var superClass = _objectSpread23({}, publicAPI);
  publicAPI.getActors = function() {
    return publicAPI;
  };
  publicAPI.getIsOpaque = function() {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.property) {
      publicAPI.getProperty();
    }
    var isOpaque = model.property.getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = function() {
    if (model.mapper === null) {
      return false;
    }
    if (model.property === null) {
      publicAPI.setProperty(publicAPI.makeProperty());
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getProperty = function() {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };
  publicAPI.getBounds = function() {
    if (model.mapper === null) {
      return model.bounds;
    }
    var bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat();
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || bds[0] !== model.mapperBounds[0] || bds[1] !== model.mapperBounds[1] || bds[2] !== model.mapperBounds[2] || bds[3] !== model.mapperBounds[3] || bds[4] !== model.mapperBounds[4] || bds[5] !== model.mapperBounds[5] || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      vtkDebugMacro11("Recomputing bounds...");
      model.mapperBounds = bds.concat();
      var bbox = [];
      vtkBoundingBox.getCorners(bds, bbox);
      publicAPI.computeMatrix();
      var tmp4 = new Float64Array(16);
      mat4_exports.transpose(tmp4, model.matrix);
      bbox.forEach(function(pt) {
        return vec3_exports.transformMat4(pt, pt, tmp4);
      });
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      model.bounds = model.bounds.map(function(d, i) {
        return i % 2 === 0 ? bbox.reduce(function(a, b) {
          return a > b[i / 2] ? b[i / 2] : a;
        }, d) : bbox.reduce(function(a, b) {
          return a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a;
        }, d);
      });
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getMTime = function() {
    var mt = superClass.getMTime();
    if (model.property !== null) {
      var time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }
    if (model.backfaceProperty !== null) {
      var _time = model.backfaceProperty.getMTime();
      mt = _time > mt ? _time : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = function() {
    var mt = model.mtime;
    if (model.mapper !== null) {
      var time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = function() {
    return model.mapper ? model.mapper.getSupportsSelection() : false;
  };
}
function extend70(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES69, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.set(publicAPI, model, ["property"]);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor(publicAPI, model);
}
var vtkDebugMacro11, DEFAULT_VALUES69, newInstance71, vtkActor$1;
var init_Actor = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Actor.js"() {
    init_defineProperty();
    init_esm();
    init_macros();
    init_BoundingBox();
    init_Prop3D();
    init_Property();
    vtkDebugMacro11 = macro.vtkDebugMacro;
    DEFAULT_VALUES69 = {
      mapper: null,
      property: null,
      backfaceProperty: null,
      forceOpaque: false,
      forceTranslucent: false,
      bounds: [1, -1, 1, -1, 1, -1]
    };
    newInstance71 = macro.newInstance(extend70, "vtkActor");
    vtkActor$1 = {
      newInstance: newInstance71,
      extend: extend70
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = function() {
    return 0;
  };
  publicAPI.getBounds = function(bounds) {
    publicAPI.getBounds();
    for (var i = 0; i < 6; i++) {
      bounds[i] = model.bounds[i];
    }
  };
  publicAPI.getCenter = function() {
    publicAPI.getBounds();
    for (var i = 0; i < 3; i++) {
      model.center[i] = (model.bounds[2 * i + 1] + model.bounds[2 * i]) / 2;
    }
    return model.center.slice();
  };
  publicAPI.getLength = function() {
    var diff = 0;
    var l = 0;
    publicAPI.getBounds();
    for (var i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      l += diff * diff;
    }
    return Math.sqrt(l);
  };
}
function extend71(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES70, initialValues);
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  if (!model.bounds) {
    uninitializeBounds(model.bounds);
  }
  if (!model.center) {
    model.center = [0, 0, 0];
  }
  vtkAbstractMapper3D(publicAPI, model);
}
var DEFAULT_VALUES70, vtkAbstractMapper3D$1;
var init_AbstractMapper3D = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js"() {
    init_AbstractMapper();
    init_Math();
    DEFAULT_VALUES70 = {
      bounds: [1, -1, 1, -1, 1, -1],
      center: [0, 0, 0]
    };
    vtkAbstractMapper3D$1 = {
      extend: extend71
    };
  }
});

// node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = function() {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      var opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (var i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = function() {
    return false;
  };
  publicAPI.getNumberOfAvailableColors = function() {
    return model.table.length;
  };
  publicAPI.linearIndexLookup = function(v, p) {
    var dIndex = 0;
    if (v < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (v > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (v + p.shift) * p.scale;
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = function(v, table, p) {
    var index = 0;
    if (isNan(v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    var offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.indexedLookupFunction = function(v, table, p) {
    var index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    var offset = 4 * index;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.lookupShiftAndScale = function(range, p) {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = function(input, output, outFormat, inputOffset) {
    var lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    var trange = publicAPI.getMappingRange();
    var p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    var alpha = publicAPI.getAlpha();
    var length = input.getNumberOfTuples();
    var inIncr = input.getNumberOfComponents();
    var outputV = output.getData();
    var inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (var i = 0; i < length; i++) {
          var cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (var _i = 0; _i < length; _i++) {
          var _cptr = lookupFunc(inputV[_i * inIncr + inputOffset], model.table, p);
          outputV[_i * 4] = _cptr[0];
          outputV[_i * 4 + 1] = _cptr[1];
          outputV[_i * 4 + 2] = _cptr[2];
          outputV[_i * 4 + 3] = Math.floor(_cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = function() {
    var hinc = 0;
    var sinc = 0;
    var vinc = 0;
    var ainc = 0;
    var maxIndex = model.numberOfColors - 1;
    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }
    var hsv = [];
    var rgba = [];
    for (var i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      hsv2rgb(hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;
      model.table[i * 4] = rgba[0] * 255 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = function(table) {
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro21("Expected 4 components for RGBA colors");
      return;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro21("Expected unsigned char values for RGBA colors");
      return;
    }
    model.numberOfColors = table.getNumberOfTuples();
    var data = table.getData();
    for (var i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
  };
  publicAPI.buildSpecialColors = function() {
    var numberOfColors = model.numberOfColors;
    var tptr = model.table;
    var base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = function() {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    model.insertTime.modified();
  }
}
function extend72(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES71, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var vtkErrorMacro21, BELOW_RANGE_COLOR_INDEX, ABOVE_RANGE_COLOR_INDEX, NAN_COLOR_INDEX, DEFAULT_VALUES71, newInstance72, vtkLookupTable$1;
var init_LookupTable = __esm({
  "node_modules/@kitware/vtk.js/Common/Core/LookupTable.js"() {
    init_macros();
    init_Math();
    init_ScalarsToColors();
    init_Constants3();
    init_Constants2();
    vtkErrorMacro21 = macro.vtkErrorMacro;
    BELOW_RANGE_COLOR_INDEX = 0;
    ABOVE_RANGE_COLOR_INDEX = 1;
    NAN_COLOR_INDEX = 2;
    DEFAULT_VALUES71 = {
      numberOfColors: 256,
      hueRange: [0, 0.66667],
      saturationRange: [1, 1],
      valueRange: [1, 1],
      alphaRange: [1, 1],
      nanColor: [0.5, 0, 0, 1],
      belowRangeColor: [0, 0, 0, 1],
      aboveRangeColor: [1, 1, 1, 1],
      useAboveRangeColor: false,
      useBelowRangeColor: false,
      alpha: 1
    };
    newInstance72 = macro.newInstance(extend72, "vtkLookupTable");
    vtkLookupTable$1 = {
      newInstance: newInstance72,
      extend: extend72
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  resolveCoincidentTopologyPolygonOffsetFaces = value;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  var mode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  resolveCoincidentTopology = mode;
}
function setResolveCoincidentTopologyToDefault() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToOff() {
  setResolveCoincidentTopology(0);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  setResolveCoincidentTopology(1);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var resolveCoincidentTopologyPolygonOffsetFaces, resolveCoincidentTopology, RESOLVE_COINCIDENT_TOPOLOGY_MODE, otherStaticMethods;
var init_Static = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js"() {
    resolveCoincidentTopologyPolygonOffsetFaces = 1;
    resolveCoincidentTopology = 0;
    RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
    otherStaticMethods = {
      getResolveCoincidentTopologyAsString,
      getResolveCoincidentTopologyPolygonOffsetFaces,
      getResolveCoincidentTopology,
      setResolveCoincidentTopology,
      setResolveCoincidentTopologyPolygonOffsetFaces,
      setResolveCoincidentTopologyToDefault,
      setResolveCoincidentTopologyToOff,
      setResolveCoincidentTopologyToPolygonOffset
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach(function(item) {
    publicAPI["get".concat(item.method)] = function() {
      return model[item.key];
    };
    publicAPI["set".concat(item.method)] = function(factor, offset) {
      model[item.key] = {
        factor,
        offset
      };
    };
  });
}
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach(function(methodName) {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).forEach(function(methodName) {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map(function(key) {
    return {
      key,
      method: "RelativeCoincidentTopology".concat(key, "OffsetParameters")
    };
  }));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = function() {
    var globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    var localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CATEGORIES, staticOffsetModel, staticOffsetAPI, CoincidentTopologyHelper;
var init_CoincidentTopologyHelper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js"() {
    init_Static();
    init_macros();
    CATEGORIES = ["Polygon", "Line", "Point"];
    staticOffsetModel = {
      Polygon: {
        factor: 2,
        offset: 0
      },
      Line: {
        factor: 1,
        offset: -1
      },
      Point: {
        factor: 0,
        offset: -2
      }
    };
    staticOffsetAPI = {};
    addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map(function(key) {
      return {
        key,
        method: "ResolveCoincidentTopology".concat(key, "OffsetParameters")
      };
    }));
    CoincidentTopologyHelper = {
      implementCoincidentTopologyMethods,
      staticOffsetAPI,
      otherStaticMethods,
      CATEGORIES
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var Mapper_exports = {};
__export(Mapper_exports, {
  default: () => vtkMapper$1,
  extend: () => extend73,
  newInstance: () => newInstance73
});
function ownKeys24(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread24(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys24(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys24(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function notImplemented6(method) {
  return function() {
    return macro.vtkErrorMacro("vtkMapper::".concat(method, " - NOT IMPLEMENTED"));
  };
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = function() {
    var input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = function(v) {
    model.forceCompileOnly = v;
  };
  publicAPI.createDefaultLookupTable = function() {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = function() {
    return macro.enumToString(ColorMode3, model.colorMode);
  };
  publicAPI.setColorModeToDefault = function() {
    return publicAPI.setColorMode(0);
  };
  publicAPI.setColorModeToMapScalars = function() {
    return publicAPI.setColorMode(1);
  };
  publicAPI.setColorModeToDirectScalars = function() {
    return publicAPI.setColorMode(2);
  };
  publicAPI.getScalarModeAsString = function() {
    return macro.enumToString(ScalarMode2, model.scalarMode);
  };
  publicAPI.setScalarModeToDefault = function() {
    return publicAPI.setScalarMode(0);
  };
  publicAPI.setScalarModeToUsePointData = function() {
    return publicAPI.setScalarMode(1);
  };
  publicAPI.setScalarModeToUseCellData = function() {
    return publicAPI.setScalarMode(2);
  };
  publicAPI.setScalarModeToUsePointFieldData = function() {
    return publicAPI.setScalarMode(3);
  };
  publicAPI.setScalarModeToUseCellFieldData = function() {
    return publicAPI.setScalarMode(4);
  };
  publicAPI.setScalarModeToUseFieldData = function() {
    return publicAPI.setScalarMode(5);
  };
  publicAPI.getAbstractScalars = function(input, scalarMode, arrayAccessMode, arrayId, arrayName) {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFLag: false
      };
    }
    var scalars = null;
    var cellFlag = false;
    if (scalarMode === ScalarMode2.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
      var pd = input.getPointData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
      var cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
      var fd = input.getFieldData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = function(input, alpha) {
    var scalars = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName).scalars;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    var toString = "".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);
    if (model.colorBuildString === toString)
      return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(input)) {
      publicAPI.mapScalarsToTexture(scalars, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      var lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = "".concat(publicAPI.getMTime()).concat(scalars.getMTime()).concat(alpha);
  };
  publicAPI.scalarToTextureCoordinate = function(scalarValue, rangeMin, invRangeWidth) {
    var texCoordS = 0.5;
    var texCoordT = 1;
    if (!isNan(scalarValue)) {
      texCoordT = 0.49;
      texCoordS = (scalarValue - rangeMin) * invRangeWidth;
      if (texCoordS > 1e3) {
        texCoordS = 1e3;
      } else if (texCoordS < -1e3) {
        texCoordS = -1e3;
      }
    }
    return {
      texCoordS,
      texCoordT
    };
  };
  publicAPI.createColorTextureCoordinates = function(input, output, numScalars, numComps, component, range, tableRange, tableNumberOfColors, useLogScale) {
    var scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;
    var paddedRange = [];
    paddedRange[0] = range[0] - scalarTexelWidth;
    paddedRange[1] = range[1] + scalarTexelWidth;
    var invRangeWidth = 1 / (paddedRange[1] - paddedRange[0]);
    var outputV = output.getData();
    var inputV = input.getData();
    var count = 0;
    var outputCount = 0;
    if (component < 0 || component >= numComps) {
      for (var scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        var sum = 0;
        for (var compIdx = 0; compIdx < numComps; ++compIdx) {
          sum += inputV[count] * inputV[count];
          count++;
        }
        var magnitude = Math.sqrt(sum);
        if (useLogScale) {
          magnitude = vtkLookupTable$1.applyLogScale(magnitude, tableRange, range);
        }
        var outputs = publicAPI.scalarToTextureCoordinate(magnitude, paddedRange[0], invRangeWidth);
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
      }
    } else {
      count += component;
      for (var _scalarIdx = 0; _scalarIdx < numScalars; ++_scalarIdx) {
        var inputValue = inputV[count];
        if (useLogScale) {
          inputValue = vtkLookupTable$1.applyLogScale(inputValue, tableRange, range);
        }
        var _outputs = publicAPI.scalarToTextureCoordinate(inputValue, paddedRange[0], invRangeWidth);
        outputV[outputCount] = _outputs.texCoordS;
        outputV[outputCount + 1] = _outputs.texCoordT;
        outputCount += 2;
        count += numComps;
      }
    }
  };
  publicAPI.mapScalarsToTexture = function(scalars, alpha) {
    var range = model.lookupTable.getRange();
    var useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      vtkLookupTable$1.getLogRange(range, range);
    }
    var origAlpha = model.lookupTable.getAlpha();
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      var numberOfColors = model.lookupTable.getNumberOfAvailableColors();
      if (numberOfColors > 4094) {
        numberOfColors = 4094;
      }
      numberOfColors += 2;
      var k = (range[1] - range[0]) / (numberOfColors - 1 - 2);
      var newArray = new Float64Array(numberOfColors * 2);
      for (var i = 0; i < numberOfColors; ++i) {
        newArray[i] = range[0] + i * k - k;
        if (useLogScale) {
          newArray[i] = Math.pow(10, newArray[i]);
        }
      }
      for (var _i = 0; _i < numberOfColors; ++_i) {
        newArray[_i + numberOfColors] = NaN;
      }
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);
      var tmp = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: newArray
      });
      model.colorTextureMap.getPointData().setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));
      model.lookupTable.setAlpha(origAlpha);
    }
    if (!model.colorCoordinates || publicAPI.getMTime() > model.colorCoordinates.getMTime() || publicAPI.getInputData(0).getMTime() > model.colorCoordinates.getMTime() || model.lookupTable.getMTime() > model.colorCoordinates.getMTime()) {
      model.colorCoordinates = null;
      var numComps = scalars.getNumberOfComponents();
      var num = scalars.getNumberOfTuples();
      model.colorCoordinates = vtkDataArray$1.newInstance({
        numberOfComponents: 2,
        values: new Float32Array(num * 2)
      });
      var scalarComponent = model.lookupTable.getVectorComponent();
      if (model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1) {
        scalarComponent = -1;
      }
      publicAPI.createColorTextureCoordinates(scalars, model.colorCoordinates, num, numComps, scalarComponent, range, model.lookupTable.getRange(), model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() / 2 - 2, useLogScale);
    }
  };
  publicAPI.getIsOpaque = function() {
    var lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.isOpaque();
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = function(input) {
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    var gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    var scalars = gasResult.scalars;
    if (!scalars) {
      return false;
    }
    if (gasResult.cellFlag) {
      return false;
    }
    if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = function() {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = function() {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = function() {
    var mt = model.mtime;
    if (model.lookupTable !== null) {
      var time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = function() {
    var input = publicAPI.getInputData();
    var pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getLines().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented6("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented6("ValueToColor");
  publicAPI.colorToValue = notImplemented6("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented6("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented6("ClearInvertibleColor");
}
function extend73(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES72, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["colorCoordinates", "colorMapColors", "colorTextureMap"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "useLookupTableScalarRange",
    "viewSpecificProperties",
    "customShaderAttributes"
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var staticOffsetAPI2, otherStaticMethods2, ColorMode3, ScalarMode2, GetArray2, VectorMode3, VtkDataTypes4, DEFAULT_VALUES72, newInstance73, vtkMapper$1;
var init_Mapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js"() {
    init_defineProperty();
    init_macros();
    init_AbstractMapper3D();
    init_DataArray();
    init_ImageData();
    init_LookupTable();
    init_Math();
    init_Constants3();
    init_CoincidentTopologyHelper();
    init_Constants4();
    staticOffsetAPI2 = CoincidentTopologyHelper.staticOffsetAPI;
    otherStaticMethods2 = CoincidentTopologyHelper.otherStaticMethods;
    ColorMode3 = Constants3.ColorMode;
    ScalarMode2 = Constants3.ScalarMode;
    GetArray2 = Constants3.GetArray;
    VectorMode3 = vtkScalarsToColors.VectorMode;
    VtkDataTypes4 = vtkDataArray$1.VtkDataTypes;
    DEFAULT_VALUES72 = {
      colorMapColors: null,
      static: false,
      lookupTable: null,
      scalarVisibility: true,
      scalarRange: [0, 1],
      useLookupTableScalarRange: false,
      colorMode: 0,
      scalarMode: 0,
      arrayAccessMode: 1,
      renderTime: 0,
      colorByArrayName: null,
      fieldDataTupleId: -1,
      interpolateScalarsBeforeMapping: false,
      colorCoordinates: null,
      colorTextureMap: null,
      forceCompileOnly: 0,
      useInvertibleColors: false,
      invertibleScalars: null,
      viewSpecificProperties: null,
      customShaderAttributes: []
    };
    newInstance73 = macro.newInstance(extend73, "vtkMapper");
    vtkMapper$1 = _objectSpread24(_objectSpread24(_objectSpread24({
      newInstance: newInstance73,
      extend: extend73
    }, staticOffsetAPI2), otherStaticMethods2), Constants3);
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
var init_asyncToGenerator = __esm({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js"() {
  }
});

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj2, key, value) {
        Object.defineProperty(obj2, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj2[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj2, key, value) {
          return obj2[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj2, arg) {
        try {
          return { type: "normal", arg: fn.call(obj2, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define2(Gp, "constructor", GeneratorFunctionPrototype);
      define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(typeof module === "object" ? module.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/@kitware/vtk.js/node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "node_modules/@kitware/vtk.js/node_modules/@babel/runtime/regenerator/index.js"(exports, module) {
    module.exports = require_runtime();
  }
});

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js
function vtkRenderPass(publicAPI, model) {
  model.classHierarchy.push("vtkRenderPass");
  publicAPI.getOperation = function() {
    return model.currentOperation;
  };
  publicAPI.setCurrentOperation = function(val) {
    model.currentOperation = val;
    model.currentTraverseOperation = "traverse".concat(macro.capitalize(model.currentOperation));
  };
  publicAPI.getTraverseOperation = function() {
    return model.currentTraverseOperation;
  };
  publicAPI.traverse = function(viewNode) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model.currentParent = parent;
    model.preDelegateOperations.forEach(function(val) {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach(function(val) {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach(function(val) {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}
function extend74(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES73, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["currentOperation"]);
  macro.setGet(publicAPI, model, ["delegates", "currentParent", "preDelegateOperations", "postDelegateOperations"]);
  vtkRenderPass(publicAPI, model);
}
var DEFAULT_VALUES73, newInstance74, vtkRenderPass$1;
var init_RenderPass = __esm({
  "node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderPass.js"() {
    init_macros();
    DEFAULT_VALUES73 = {
      delegates: [],
      currentOperation: null,
      preDelegateOperations: [],
      postDelegateOperations: [],
      currentParent: null
    };
    newInstance74 = macro.newInstance(extend74, "vtkRenderPass");
    vtkRenderPass$1 = {
      newInstance: newInstance74,
      extend: extend74
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js
function translucentShaderReplacement(shaders) {
  var substituteRes = vtkShaderProgram$1.substitute(shaders.Fragment, "//VTK::RenderPassFragmentShader::Impl", "\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ", false);
  shaders.Fragment = substituteRes.result;
}
function vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass");
  publicAPI.createVertexBuffer = function() {
    var ptsArray = new Float32Array([-1, -1, -1, 1, -1, -1, -1, 1, -1, 1, 1, -1]);
    var tcoordArray = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
    var cellArray = new Uint16Array([4, 0, 1, 3, 2]);
    var points = vtkDataArray$1.newInstance({
      numberOfComponents: 3,
      values: ptsArray
    });
    points.setName("points");
    var tcoords = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoordArray
    });
    tcoords.setName("tcoords");
    var cells = vtkDataArray$1.newInstance({
      numberOfComponents: 1,
      values: cellArray
    });
    model.tris.getCABO().createVBO(cells, "polys", Representation4.SURFACE, {
      points,
      tcoords,
      cellOffset: 0
    });
    model.VBOBuildTime.modified();
  };
  publicAPI.createFramebuffer = function(viewNode) {
    var _model$framebuffer;
    var size = viewNode.getSize();
    var gl = viewNode.getContext();
    model.framebuffer = vtkOpenGLFramebuffer.newInstance();
    model.framebuffer.setOpenGLRenderWindow(viewNode);
    (_model$framebuffer = model.framebuffer).create.apply(_model$framebuffer, _toConsumableArray(size));
    model.framebuffer.saveCurrentBindingsAndBuffers();
    model.framebuffer.bind();
    model.translucentRGBATexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRGBATexture.setInternalFormat(gl.RGBA16F);
    model.translucentRGBATexture.setFormat(gl.RGBA);
    model.translucentRGBATexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRGBATexture.setOpenGLRenderWindow(viewNode);
    model.translucentRGBATexture.create2DFromRaw(size[0], size[1], 4, "Float32Array", null);
    model.translucentRTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentRTexture.setInternalFormat(gl.R16F);
    model.translucentRTexture.setFormat(gl.RED);
    model.translucentRTexture.setOpenGLDataType(gl.HALF_FLOAT);
    model.translucentRTexture.setOpenGLRenderWindow(viewNode);
    model.translucentRTexture.create2DFromRaw(size[0], size[1], 1, "Float32Array", null);
    model.translucentZTexture = vtkOpenGLTexture$1.newInstance();
    model.translucentZTexture.setOpenGLRenderWindow(viewNode);
    model.translucentZTexture.createDepthFromRaw(size[0], size[1], "Float32Array", null);
    model.framebuffer.setColorBuffer(model.translucentRGBATexture, 0);
    model.framebuffer.setColorBuffer(model.translucentRTexture, 1);
    model.framebuffer.setDepthBuffer(model.translucentZTexture);
  };
  publicAPI.createCopyShader = function(viewNode) {
    model.copyShader = viewNode.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec", "attribute vec4 vertexDC;", "attribute vec2 tcoordTC;", "varying vec2 tcoord;", "void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"), oitpFragTemplate, "");
  };
  publicAPI.createVBO = function(viewNode) {
    var gl = viewNode.getContext();
    model.tris.setOpenGLRenderWindow(viewNode);
    publicAPI.createVertexBuffer();
    var program = model.copyShader;
    model.tris.getCABO().bind();
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "vertexDC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 3, gl.FALSE)) {
      vtkErrorMacro22("Error setting vertexDC in copy shader VAO.");
    }
    if (!model.copyVAO.addAttributeArray(program, model.tris.getCABO(), "tcoordTC", model.tris.getCABO().getTCoordOffset(), model.tris.getCABO().getStride(), gl.FLOAT, 2, gl.FALSE)) {
      vtkErrorMacro22("Error setting vertexDC in copy shader VAO.");
    }
  };
  publicAPI.traverse = function(viewNode, renNode, forwardPass) {
    if (model.deleted) {
      return;
    }
    var size = viewNode.getSize();
    var gl = viewNode.getContext();
    if (gl === null) {
      model.delegates.forEach(function(val) {
        val.traverse(viewNode, publicAPI);
      });
      return;
    }
    if (!viewNode.getWebgl2() || !gl.getExtension("EXT_color_buffer_half_float") && !gl.getExtension("EXT_color_buffer_float")) {
      console.log("fallback");
      publicAPI.setCurrentOperation("translucentPass");
      renNode.traverse(publicAPI);
      return;
    }
    if (model.framebuffer === null) {
      publicAPI.createFramebuffer(viewNode);
    } else {
      var fbSize = model.framebuffer.getSize();
      if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.releaseGraphicsResources();
        model.translucentRGBATexture.releaseGraphicsResources(viewNode);
        model.translucentRTexture.releaseGraphicsResources(viewNode);
        model.translucentZTexture.releaseGraphicsResources(viewNode);
        publicAPI.createFramebuffer(viewNode);
      } else {
        model.framebuffer.saveCurrentBindingsAndBuffers();
        model.framebuffer.bind();
      }
    }
    gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 0]);
    gl.clearBufferfv(gl.DEPTH, 0, [1]);
    gl.colorMask(false, false, false, false);
    if (forwardPass.getOpaqueActorCount() > 0) {
      forwardPass.setCurrentOperation("opaquePass");
      renNode.traverse(forwardPass);
    }
    gl.colorMask(true, true, true, true);
    gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);
    gl.clearBufferfv(gl.COLOR, 0, [0, 0, 0, 1]);
    gl.clearBufferfv(gl.COLOR, 1, [0, 0, 0, 0]);
    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.BLEND);
    gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
    publicAPI.setCurrentOperation("translucentPass");
    renNode.traverse(publicAPI);
    gl.drawBuffers([gl.NONE]);
    model.framebuffer.restorePreviousBindingsAndBuffers();
    if (model.copyShader === null) {
      publicAPI.createCopyShader(viewNode);
    } else {
      viewNode.getShaderCache().readyShaderProgram(model.copyShader);
    }
    if (!model.copyVAO) {
      model.copyVAO = vtkVertexArrayObject.newInstance();
      model.copyVAO.setOpenGLRenderWindow(viewNode);
    }
    model.copyVAO.bind();
    if (model.VBOBuildTime.getMTime() < publicAPI.getMTime()) {
      publicAPI.createVBO(viewNode);
    }
    gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    gl.depthMask(false);
    gl.depthFunc(gl.ALWAYS);
    gl.viewport(0, 0, size[0], size[1]);
    gl.scissor(0, 0, size[0], size[1]);
    model.translucentRGBATexture.activate();
    model.copyShader.setUniformi("translucentRGBATexture", model.translucentRGBATexture.getTextureUnit());
    model.translucentRTexture.activate();
    model.copyShader.setUniformi("translucentRTexture", model.translucentRTexture.getTextureUnit());
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    gl.depthMask(true);
    gl.depthFunc(gl.LEQUAL);
    model.translucentRGBATexture.deactivate();
    model.translucentRTexture.deactivate();
  };
  publicAPI.getShaderReplacement = function() {
    return translucentShaderReplacement;
  };
  publicAPI.releaseGraphicsResources = function(viewNode) {
    if (model.framebuffer) {
      model.framebuffer.releaseGraphicsResources(viewNode);
      model.framebuffer = null;
    }
    if (model.translucentRGBATexture) {
      model.translucentRGBATexture.releaseGraphicsResources(viewNode);
      model.translucentRGBATexture = null;
    }
    if (model.translucentRTexture) {
      model.translucentRTexture.releaseGraphicsResources(viewNode);
      model.translucentRTexture = null;
    }
    if (model.translucentZTexture) {
      model.translucentZTexture.releaseGraphicsResources(viewNode);
      model.translucentZTexture = null;
    }
    if (model.copyVAO) {
      model.copyVAO.releaseGraphicsResources(viewNode);
      model.copyVAO = null;
    }
    if (model.copyShader) {
      model.copyShader.releaseGraphicsResources(viewNode);
      model.copyShader = null;
    }
    if (model.tris) {
      model.tris.releaseGraphicsResources(viewNode);
      model.tris = null;
    }
    publicAPI.modified();
  };
}
function extend75(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES74, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  model.VBOBuildTime = {};
  macro.obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.tris = vtkHelper.newInstance();
  macro.get(publicAPI, model, ["framebuffer"]);
  vtkOpenGLOrderIndependentTranslucentPass(publicAPI, model);
}
var Representation4, vtkErrorMacro22, oitpFragTemplate, DEFAULT_VALUES74, newInstance75, vtkOpenGLOrderIndependentTranslucentPass$1;
var init_OrderIndependentTranslucentPass = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/OrderIndependentTranslucentPass.js"() {
    init_toConsumableArray();
    init_macros();
    init_Texture();
    init_Framebuffer();
    init_RenderPass();
    init_DataArray();
    init_Helper();
    init_Property();
    init_ShaderProgram();
    init_VertexArrayObject();
    Representation4 = vtkProperty$1.Representation;
    vtkErrorMacro22 = macro.vtkErrorMacro;
    oitpFragTemplate = "//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n";
    DEFAULT_VALUES74 = {
      framebuffer: null,
      copyShader: null,
      tris: null
    };
    newInstance75 = macro.newInstance(extend75, "vtkOpenGLOrderIndependentTranslucentPass");
    vtkOpenGLOrderIndependentTranslucentPass$1 = {
      newInstance: newInstance75,
      extend: extend75
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js
function vtkForwardPass(publicAPI, model) {
  model.classHierarchy.push("vtkForwardPass");
  publicAPI.traverse = function(viewNode) {
    var parent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (model.deleted) {
      return;
    }
    model.currentParent = parent;
    publicAPI.setCurrentOperation("buildPass");
    viewNode.traverse(publicAPI);
    var numlayers = viewNode.getRenderable().getNumberOfLayers();
    var renderers = viewNode.getChildren();
    for (var i = 0; i < numlayers; i++) {
      for (var index = 0; index < renderers.length; index++) {
        var renNode = renderers[index];
        var ren = viewNode.getRenderable().getRenderers()[index];
        if (ren.getDraw() && ren.getLayer() === i) {
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          model.overlayActorCount = 0;
          publicAPI.setCurrentOperation("queryPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0 && model.volumeCount > 0 || model.depthRequested) {
            var size = viewNode.getFramebufferSize();
            if (model.framebuffer === null) {
              model.framebuffer = vtkOpenGLFramebuffer.newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            var fbSize = model.framebuffer.getSize();
            if (fbSize === null || fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation("opaqueZBufferPass");
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
            model.depthRequested = false;
          }
          publicAPI.setCurrentOperation("cameraPass");
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation("opaquePass");
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            if (!model.translucentPass) {
              model.translucentPass = vtkOpenGLOrderIndependentTranslucentPass$1.newInstance();
            }
            model.translucentPass.traverse(viewNode, renNode, publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation("volumePass");
            renNode.traverse(publicAPI);
          }
          if (model.overlayActorCount > 0) {
            publicAPI.setCurrentOperation("overlayPass");
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };
  publicAPI.getZBufferTexture = function() {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };
  publicAPI.requestDepth = function() {
    model.depthRequested = true;
  };
  publicAPI.incrementOpaqueActorCount = function() {
    return model.opaqueActorCount++;
  };
  publicAPI.incrementTranslucentActorCount = function() {
    return model.translucentActorCount++;
  };
  publicAPI.incrementVolumeCount = function() {
    return model.volumeCount++;
  };
  publicAPI.incrementOverlayActorCount = function() {
    return model.overlayActorCount++;
  };
}
function extend76(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES75, initialValues);
  vtkRenderPass$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["framebuffer", "opaqueActorCount", "translucentActorCount", "volumeCount"]);
  vtkForwardPass(publicAPI, model);
}
var DEFAULT_VALUES75, newInstance76, vtkForwardPass$1;
var init_ForwardPass = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ForwardPass.js"() {
    init_macros();
    init_Framebuffer();
    init_RenderPass();
    init_OrderIndependentTranslucentPass();
    DEFAULT_VALUES75 = {
      opaqueActorCount: 0,
      translucentActorCount: 0,
      volumeCount: 0,
      overlayActorCount: 0,
      framebuffer: null,
      depthRequested: false
    };
    newInstance76 = macro.newInstance(extend76, "vtkForwardPass");
    vtkForwardPass$1 = {
      newInstance: newInstance76,
      extend: extend76
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var PassTypes, Constants15;
var init_Constants20 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js"() {
    PassTypes = {
      MIN_KNOWN_PASS: 0,
      ACTOR_PASS: 0,
      COMPOSITE_INDEX_PASS: 1,
      ID_LOW24: 2,
      MAX_KNOWN_PASS: 2
    };
    Constants15 = {
      PassTypes
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js
function vtkHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkHardwareSelector");
  publicAPI.getSourceDataAsync = function() {
    var _ref = _asyncToGenerator(import_regenerator.default.mark(function _callee(renderer, fx1, fy1, fx2, fy2) {
      return import_regenerator.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.selectAsync = function() {
    var _ref2 = _asyncToGenerator(import_regenerator.default.mark(function _callee2(renderer, fx1, fy1, fx2, fy2) {
      var srcData;
      return import_regenerator.default.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return publicAPI.getSourceDataAsync(renderer, fx1, fy1, fx2, fy2);
            case 2:
              srcData = _context2.sent;
              if (!srcData) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return", srcData.generateSelection(fx1, fy1, fx2, fy2));
            case 5:
              return _context2.abrupt("return", []);
            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return function(_x6, _x7, _x8, _x9, _x10) {
      return _ref2.apply(this, arguments);
    };
  }();
}
function extend77(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES76, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["fieldAssociation", "captureZValues"]);
  vtkHardwareSelector(publicAPI, model);
}
var import_regenerator, FieldAssociations2, DEFAULT_VALUES76, newInstance77, vtkHardwareSelector$1;
var init_HardwareSelector = __esm({
  "node_modules/@kitware/vtk.js/Rendering/Core/HardwareSelector.js"() {
    init_asyncToGenerator();
    import_regenerator = __toESM(require_regenerator());
    init_macros();
    init_DataSet();
    FieldAssociations2 = vtkDataSet$1.FieldAssociations;
    DEFAULT_VALUES76 = {
      fieldAssociation: FieldAssociations2.FIELD_ASSOCIATION_CELLS,
      captureZValues: false
    };
    newInstance77 = macro.newInstance(extend77, "vtkHardwareSelector");
    vtkHardwareSelector$1 = {
      newInstance: newInstance77,
      extend: extend77
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js
var SelectionContent, SelectionField, Constants16;
var init_Constants21 = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode/Constants.js"() {
    SelectionContent = {
      GLOBALIDS: 0,
      PEDIGREEIDS: 1,
      VALUES: 2,
      INDICES: 3,
      FRUSTUM: 4,
      LOCATIONS: 5,
      THRESHOLDS: 6,
      BLOCKS: 7,
      QUERY: 8
    };
    SelectionField = {
      CELL: 0,
      POINT: 1,
      FIELD: 2,
      VERTEX: 3,
      EDGE: 4,
      ROW: 5
    };
    Constants16 = {
      SelectionContent,
      SelectionField
    };
  }
});

// node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js
function ownKeys25(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread25(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys25(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys25(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkSelectionNode(publicAPI, model) {
  model.classHierarchy.push("vtkSelectionNode");
  publicAPI.getBounds = function() {
    return model.points.getBounds();
  };
}
function extend78(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES77, initialValues);
  macro.obj(publicAPI, model);
  model.properties = {};
  macro.setGet(publicAPI, model, ["contentType", "fieldType", "properties", "selectionList"]);
  vtkSelectionNode(publicAPI, model);
}
var DEFAULT_VALUES77, newInstance78, vtkSelectionNode$1;
var init_SelectionNode = __esm({
  "node_modules/@kitware/vtk.js/Common/DataModel/SelectionNode.js"() {
    init_defineProperty();
    init_macros();
    init_Constants21();
    DEFAULT_VALUES77 = {
      contentType: -1,
      fieldType: -1,
      properties: null,
      selectionList: []
    };
    newInstance78 = macro.newInstance(extend78, "vtkSelectionNode");
    vtkSelectionNode$1 = _objectSpread25({
      newInstance: newInstance78,
      extend: extend78
    }, Constants16);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js
function ownKeys26(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread26(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys26(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys26(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function getInfoHash(info) {
  return "".concat(info.propID, " ").concat(info.compositeID);
}
function convert(xx, yy, pb, area) {
  if (!pb) {
    return 0;
  }
  var offset = (yy * (area[2] - area[0] + 1) + xx) * 4;
  var rgb = [];
  rgb[0] = pb[offset];
  rgb[1] = pb[offset + 1];
  rgb[2] = pb[offset + 2];
  var val = rgb[2];
  val *= 256;
  val += rgb[1];
  val *= 256;
  val += rgb[0];
  return val;
}
function getPixelInformationWithData(buffdata, inDisplayPosition, maxDistance, outSelectedPosition) {
  var maxDist = maxDistance < 0 ? 0 : maxDistance;
  if (maxDist === 0) {
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    if (inDisplayPosition[0] < buffdata.area[0] || inDisplayPosition[0] > buffdata.area[2] || inDisplayPosition[1] < buffdata.area[1] || inDisplayPosition[1] > buffdata.area[3]) {
      return null;
    }
    var displayPosition = [inDisplayPosition[0] - buffdata.area[0], inDisplayPosition[1] - buffdata.area[1]];
    var actorid = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.ACTOR_PASS], buffdata.area);
    if (actorid <= 0 || actorid - idOffset >= buffdata.props.length) {
      return null;
    }
    var _info = {};
    _info.valid = true;
    _info.propID = actorid - idOffset;
    _info.prop = buffdata.props[_info.propID];
    var compositeID = convert(displayPosition[0], displayPosition[1], buffdata.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], buffdata.area);
    if (compositeID < 0 || compositeID > 16777215) {
      compositeID = 0;
    }
    _info.compositeID = compositeID - idOffset;
    if (buffdata.captureZValues) {
      var offset = (displayPosition[1] * (buffdata.area[2] - buffdata.area[0] + 1) + displayPosition[0]) * 4;
      _info.zValue = (256 * buffdata.zBuffer[offset] + buffdata.zBuffer[offset + 1]) / 65535;
      _info.displayPosition = inDisplayPosition;
    }
    return _info;
  }
  var dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
  var curPos = [0, 0];
  var info = getPixelInformationWithData(buffdata, inDisplayPosition, 0, outSelectedPosition);
  if (info && info.valid) {
    return info;
  }
  for (var dist = 1; dist < maxDist; ++dist) {
    for (var y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
      curPos[1] = y;
      if (dispPos[0] >= dist) {
        curPos[0] = dispPos[0] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[0] = dispPos[0] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
    for (var x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
      curPos[0] = x;
      if (dispPos[1] >= dist) {
        curPos[1] = dispPos[1] - dist;
        info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      curPos[1] = dispPos[1] + dist;
      info = getPixelInformationWithData(buffdata, curPos, 0, outSelectedPosition);
      if (info && info.valid) {
        return info;
      }
    }
  }
  outSelectedPosition[0] = inDisplayPosition[0];
  outSelectedPosition[1] = inDisplayPosition[1];
  return null;
}
function convertSelection(fieldassociation, dataMap, captureZValues, renderer, openGLRenderWindow) {
  var sel = [];
  var count = 0;
  dataMap.forEach(function(value, key) {
    var child = vtkSelectionNode$1.newInstance();
    child.setContentType(SelectionContent2.INDICES);
    switch (fieldassociation) {
      case FieldAssociations3.FIELD_ASSOCIATION_CELLS:
        child.setFieldType(SelectionField2.CELL);
        break;
      case FieldAssociations3.FIELD_ASSOCIATION_POINTS:
        child.setFieldType(SelectionField2.POINT);
        break;
      default:
        vtkErrorMacro23("Unknown field association");
    }
    child.getProperties().propID = value.info.propID;
    child.getProperties().prop = value.info.prop;
    child.getProperties().compositeID = value.info.compositeID;
    child.getProperties().pixelCount = value.pixelCount;
    if (captureZValues) {
      child.getProperties().displayPosition = [value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue];
      child.getProperties().worldPosition = openGLRenderWindow.displayToWorld(value.info.displayPosition[0], value.info.displayPosition[1], value.info.zValue, renderer);
    }
    child.setSelectionList(value.attributeIDs);
    sel[count] = child;
    count++;
  });
  return sel;
}
function generateSelectionWithData(buffdata, fx1, fy1, fx2, fy2) {
  var x1 = Math.floor(fx1);
  var y1 = Math.floor(fy1);
  var x2 = Math.floor(fx2);
  var y2 = Math.floor(fy2);
  var dataMap = /* @__PURE__ */ new Map();
  var outSelectedPosition = [0, 0];
  for (var yy = y1; yy <= y2; yy++) {
    for (var xx = x1; xx <= x2; xx++) {
      var pos = [xx, yy];
      var info = getPixelInformationWithData(buffdata, pos, 0, outSelectedPosition);
      if (info && info.valid) {
        var hash = getInfoHash(info);
        if (!dataMap.has(hash)) {
          dataMap.set(hash, {
            info,
            pixelCount: 1,
            attributeIDs: [info.attributeID]
          });
        } else {
          var dmv = dataMap.get(hash);
          dmv.pixelCount++;
          if (buffdata.captureZValues) {
            if (info.zValue < dmv.info.zValue) {
              dmv.info = info;
            }
          }
          if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
            dmv.attributeIDs.push(info.attributeID);
          }
        }
      }
    }
  }
  return convertSelection(buffdata.fieldAssociation, dataMap, buffdata.captureZValues, buffdata.renderer, buffdata.openGLRenderWindow);
}
function vtkOpenGLHardwareSelector(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHardwareSelector");
  publicAPI.releasePixBuffers = function() {
    model.pixBuffer = [];
    model.zBuffer = null;
  };
  publicAPI.beginSelection = function() {
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model.renderer);
    model.maxAttributeId = 0;
    var size = model._openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtkOpenGLFramebuffer.newInstance();
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      var fbSize = model.framebuffer.getSize();
      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }
    model._openGLRenderer.clear();
    model._openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.props = [];
    publicAPI.releasePixBuffers();
  };
  publicAPI.endSelection = function() {
    model.hitProps = {};
    model._openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };
  publicAPI.preCapturePass = function() {
  };
  publicAPI.postCapturePass = function() {
  };
  publicAPI.select = function() {
    var sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(model.area[0], model.area[1], model.area[2], model.area[3]);
      publicAPI.releasePixBuffers();
    }
    return sel;
  };
  publicAPI.getSourceDataAsync = function() {
    var _ref = _asyncToGenerator(import_regenerator2.default.mark(function _callee(renderer, fx1, fy1, fx2, fy2) {
      var size, result;
      return import_regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              model.renderer = renderer;
              if (fx1 === void 0) {
                size = model._openGLRenderWindow.getSize();
                publicAPI.setArea(0, 0, size[0] - 1, size[1] - 1);
              } else {
                publicAPI.setArea(fx1, fy1, fx2, fy2);
              }
              if (publicAPI.captureBuffers()) {
                _context.next = 4;
                break;
              }
              return _context.abrupt("return", false);
            case 4:
              result = {
                area: _toConsumableArray(model.area),
                pixBuffer: _toConsumableArray(model.pixBuffer),
                captureZValues: model.captureZValues,
                zBuffer: model.zBuffer,
                props: _toConsumableArray(model.props),
                fieldAssociation: model.fieldAssociation,
                renderer,
                openGLRenderWindow: model._openGLRenderWindow
              };
              result.generateSelection = function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }
                return generateSelectionWithData.apply(void 0, [result].concat(args));
              };
              return _context.abrupt("return", result);
            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x, _x2, _x3, _x4, _x5) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.captureBuffers = function() {
    if (!model.renderer || !model._openGLRenderWindow) {
      vtkErrorMacro23("Renderer and view must be set before calling Select.");
      return false;
    }
    model._openGLRenderer = model._openGLRenderWindow.getViewNodeFor(model.renderer);
    model._openGLRenderWindow.getRenderable().preRender();
    publicAPI.invokeEvent({
      type: "StartEvent"
    });
    model.originalBackground = model.renderer.getBackgroundByReference();
    model.renderer.setBackground(0, 0, 0);
    var rpasses = model._openGLRenderWindow.getRenderPasses();
    publicAPI.beginSelection();
    for (model.currentPass = PassTypes2.MIN_KNOWN_PASS; model.currentPass <= PassTypes2.COMPOSITE_INDEX_PASS; model.currentPass++) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (model.captureZValues && model.currentPass === PassTypes2.ACTOR_PASS && typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          rpasses[0].requestDepth();
          model._openGLRenderWindow.traverseAllPasses();
        } else {
          model._openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);
        publicAPI.savePixelBuffer(model.currentPass);
      }
    }
    publicAPI.endSelection();
    model.renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({
      type: "EndEvent"
    });
    return true;
  };
  publicAPI.passRequired = function(pass) {
    return true;
  };
  publicAPI.savePixelBuffer = function(passNo) {
    model.pixBuffer[passNo] = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
    if (passNo === PassTypes2.ACTOR_PASS) {
      if (model.captureZValues) {
        var rpasses = model._openGLRenderWindow.getRenderPasses();
        if (typeof rpasses[0].requestDepth === "function" && typeof rpasses[0].getFramebuffer === "function") {
          var fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model._openGLRenderWindow.getPixelData(model.area[0], model.area[1], model.area[2], model.area[3]);
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.pixBuffer[passNo]);
    }
  };
  publicAPI.buildPropHitList = function(pixelbuffer) {
    for (var yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (var xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        var val = convert(xx, yy, pixelbuffer, model.area);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
          }
        }
      }
    }
  };
  publicAPI.renderProp = function(prop) {
    if (model.currentPass === PassTypes2.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + idOffset);
      model.props.push(prop);
    }
  };
  publicAPI.renderCompositeIndex = function(index) {
    if (model.currentPass === PassTypes2.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + idOffset);
    }
  };
  publicAPI.renderAttributeId = function(attribid) {
    if (attribid < 0) {
      return;
    }
    model.maxAttributeId = attribid > model.maxAttributeId ? attribid : model.maxAttributeId;
  };
  publicAPI.passTypeToString = function(type) {
    return macro.enumToString(PassTypes2, type);
  };
  publicAPI.isPropHit = function(id) {
    return Boolean(model.hitProps[id]);
  };
  publicAPI.setPropColorValueFromInt = function(val) {
    model.propColorValue[0] = val % 256 / 255;
    model.propColorValue[1] = Math.floor(val / 256) % 256 / 255;
    model.propColorValue[2] = Math.floor(val / 65536) % 256 / 255;
  };
  publicAPI.getPixelInformation = function(inDisplayPosition, maxDistance, outSelectedPosition) {
    var maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (inDisplayPosition[0] < model.area[0] || inDisplayPosition[0] > model.area[2] || inDisplayPosition[1] < model.area[1] || inDisplayPosition[1] > model.area[3]) {
        return null;
      }
      var displayPosition = [inDisplayPosition[0] - model.area[0], inDisplayPosition[1] - model.area[1]];
      var actorid = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.ACTOR_PASS], model.area);
      if (actorid <= 0 || actorid - idOffset >= model.props.length) {
        return null;
      }
      var _info2 = {};
      _info2.valid = true;
      _info2.propID = actorid - idOffset;
      _info2.prop = model.props[_info2.propID];
      var compositeID = convert(displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes2.COMPOSITE_INDEX_PASS], model.area);
      if (compositeID < 0 || compositeID > 16777215) {
        compositeID = 0;
      }
      _info2.compositeID = compositeID - idOffset;
      if (model.captureZValues) {
        var offset = (displayPosition[1] * (model.area[2] - model.area[0] + 1) + displayPosition[0]) * 4;
        _info2.zValue = (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535;
        _info2.displayPosition = inDisplayPosition;
      }
      return _info2;
    }
    var dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    var curPos = [0, 0];
    var info = publicAPI.getPixelInformation(inDisplayPosition, 0, outSelectedPosition);
    if (info && info.valid) {
      return info;
    }
    for (var dist = 1; dist < maxDist; ++dist) {
      for (var y = dispPos[1] > dist ? dispPos[1] - dist : 0; y <= dispPos[1] + dist; ++y) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      for (var x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0; x <= dispPos[0] + (dist - 1); ++x) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };
  publicAPI.generateSelection = function(fx1, fy1, fx2, fy2) {
    var x1 = Math.floor(fx1);
    var y1 = Math.floor(fy1);
    var x2 = Math.floor(fx2);
    var y2 = Math.floor(fy2);
    var dataMap = /* @__PURE__ */ new Map();
    var outSelectedPosition = [0, 0];
    for (var yy = y1; yy <= y2; yy++) {
      for (var xx = x1; xx <= x2; xx++) {
        var pos = [xx, yy];
        var info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          var hash = getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID]
            });
          } else {
            var dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return convertSelection(model.fieldAssociation, dataMap, model.captureZValues, model.renderer, model._openGLRenderWindow);
  };
  publicAPI.attach = function(w, r) {
    model._openGLRenderWindow = w;
    model.renderer = r;
  };
  var superSetArea = publicAPI.setArea;
  publicAPI.setArea = function() {
    if (superSetArea.apply(void 0, arguments)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}
function extend79(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES78, initialValues);
  vtkHardwareSelector$1.extend(publicAPI, model, initialValues);
  model.propColorValue = [0, 0, 0];
  model.props = [];
  if (!model.area) {
    model.area = [0, 0, 0, 0];
  }
  macro.setGetArray(publicAPI, model, ["area"], 4);
  macro.setGet(publicAPI, model, ["_renderer", "currentPass", "_openGLRenderWindow"]);
  macro.setGetArray(publicAPI, model, ["propColorValue"], 3);
  macro.moveToProtected(publicAPI, model, ["renderer", "openGLRenderWindow"]);
  macro.event(publicAPI, model, "event");
  vtkOpenGLHardwareSelector(publicAPI, model);
}
var import_regenerator2, PassTypes2, SelectionContent2, SelectionField2, FieldAssociations3, vtkErrorMacro23, idOffset, DEFAULT_VALUES78, newInstance79, vtkHardwareSelector2;
var init_HardwareSelector2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector.js"() {
    init_defineProperty();
    init_toConsumableArray();
    init_asyncToGenerator();
    import_regenerator2 = __toESM(require_regenerator());
    init_macros();
    init_Constants20();
    init_HardwareSelector();
    init_Framebuffer();
    init_SelectionNode();
    init_DataSet();
    PassTypes2 = Constants15.PassTypes;
    SelectionContent2 = vtkSelectionNode$1.SelectionContent;
    SelectionField2 = vtkSelectionNode$1.SelectionField;
    FieldAssociations3 = vtkDataSet$1.FieldAssociations;
    vtkErrorMacro23 = macro.vtkErrorMacro;
    idOffset = 1;
    DEFAULT_VALUES78 = {
      area: void 0,
      currentPass: -1,
      propColorValue: null,
      props: null,
      idOffset: 1
    };
    newInstance79 = macro.newInstance(extend79, "vtkOpenGLHardwareSelector");
    vtkHardwareSelector2 = _objectSpread26({
      newInstance: newInstance79,
      extend: extend79
    }, Constants15);
  }
});

// node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "node_modules/spark-md5/spark-md5.js"(exports, module) {
    (function(factory) {
      if (typeof exports === "object") {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a, b) {
        return a + b & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b);
      }
      function md5cycle(x, k) {
        var a = x[0], b = x[1], c = x[2], d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      function md5blk(s) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
      }
      function md51(s) {
        var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a) {
        var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= a[i] << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n) {
        var s = "", j;
        for (j = 0; j < 4; j += 1) {
          s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        }
        return s;
      }
      function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
          x[i] = rhex(x[i]);
        }
        return x.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x, y) {
          var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
        for (i = 0; i < length; i += 1) {
          arr[i] = str.charCodeAt(i);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length = hex2.length, x;
        for (x = 0; x < length - 1; x += 2) {
          bytes.push(parseInt(hex2.substr(x, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }
        this._buff = this._buff.substring(i - 64);
        return this;
      };
      SparkMD5.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(tail, length) {
        var i = length, tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(this._hash, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD5.hash = function(str, raw) {
        return SparkMD5.hashBinary(toUtf8(str), raw);
      };
      SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff[i] << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD5.prototype.setState.call(this, state);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD5;
    });
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js
function vtkShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkShaderCache");
  publicAPI.replaceShaderValues = function(VSSource, FSSource, GSSource) {
    var nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "VSOut", "GSOut").result;
    }
    var gl2 = model._openGLRenderWindow.getWebgl2();
    var fragDepthString = "\n";
    var version = "#version 100\n";
    if (gl2) {
      version = "#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n";
    } else {
      model.context.getExtension("OES_standard_derivatives");
      if (model.context.getExtension("EXT_frag_depth")) {
        fragDepthString = "#extension GL_EXT_frag_depth : enable\n";
      }
      if (model.context.getExtension("EXT_shader_texture_lod")) {
        fragDepthString += "#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT";
      }
    }
    nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::System::Dec", ["".concat(version, "\n"), gl2 ? "" : "#extension GL_OES_standard_derivatives : enable\n", fragDepthString, "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    var nVSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::System::Dec", ["".concat(version, "\n"), "#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "precision highp int;", "#else", "precision mediump float;", "precision mediump int;", "#endif"]).result;
    if (gl2) {
      nVSSource = vtkShaderProgram$1.substitute(nVSSource, "varying", "out").result;
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "varying", "in").result;
      var shaderOutputs = "";
      var outputCount = 0;
      while (nFSSource.includes("gl_FragData[".concat(outputCount, "]"))) {
        nFSSource = vtkShaderProgram$1.substitute(nFSSource, "gl_FragData\\[".concat(outputCount, "\\]"), "fragOutput".concat(outputCount)).result;
        shaderOutputs += "layout(location = ".concat(outputCount, ") out vec4 fragOutput").concat(outputCount, ";\n");
        outputCount++;
      }
      nFSSource = vtkShaderProgram$1.substitute(nFSSource, "//VTK::Output::Dec", shaderOutputs).result;
    }
    var nGSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::System::Dec", version).result;
    return {
      VSSource: nVSSource,
      FSSource: nFSSource,
      GSSource: nGSSource
    };
  };
  publicAPI.readyShaderProgramArray = function(vertexCode, fragmentCode, geometryCode) {
    var data = publicAPI.replaceShaderValues(vertexCode, fragmentCode, geometryCode);
    var shader = publicAPI.getShaderProgram(data.VSSource, data.FSSource, data.GSSource);
    return publicAPI.readyShaderProgram(shader);
  };
  publicAPI.readyShaderProgram = function(shader) {
    if (!shader) {
      return null;
    }
    if (!shader.getCompiled() && !shader.compileShader()) {
      return null;
    }
    if (!publicAPI.bindShader(shader)) {
      return null;
    }
    return shader;
  };
  publicAPI.getShaderProgram = function(vertexCode, fragmentCode, geometryCode) {
    var hashInput = "".concat(vertexCode).concat(fragmentCode).concat(geometryCode);
    var result = import_spark_md5.default.hash(hashInput);
    var loc = Object.keys(model.shaderPrograms).indexOf(result);
    if (loc === -1) {
      var sps = vtkShaderProgram$1.newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }
    return model.shaderPrograms[result];
  };
  publicAPI.releaseGraphicsResources = function(win) {
    publicAPI.releaseCurrentShader();
    Object.keys(model.shaderPrograms).map(function(key) {
      return model.shaderPrograms[key];
    }).forEach(function(sp) {
      return sp.releaseGraphicsResources(win);
    });
  };
  publicAPI.releaseGraphicsResources = function() {
    if (model.astShaderBound) {
      model.lastShaderBound.release();
      model.lastShaderBound = null;
    }
  };
  publicAPI.bindShader = function(shader) {
    if (model.lastShaderBound === shader) {
      return 1;
    }
    if (model.lastShaderBound) {
      model.lastShaderBound.release();
    }
    shader.bind();
    model.lastShaderBound = shader;
    return 1;
  };
}
function extend80(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES79, initialValues);
  model.shaderPrograms = {};
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, SET_GET_FIELDS);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkShaderCache(publicAPI, model);
}
var import_spark_md5, SET_GET_FIELDS, DEFAULT_VALUES79, newInstance80, vtkShaderCache$1;
var init_ShaderCache2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderCache.js"() {
    import_spark_md5 = __toESM(require_spark_md5());
    init_macros();
    init_ShaderProgram();
    SET_GET_FIELDS = ["lastShaderBound", "context", "_openGLRenderWindow"];
    DEFAULT_VALUES79 = {
      lastShaderBound: null,
      shaderPrograms: null,
      context: null
    };
    newInstance80 = macro.newInstance(extend80, "vtkShaderCache");
    vtkShaderCache$1 = {
      newInstance: newInstance80,
      extend: extend80
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js
function vtkOpenGLTextureUnitManager(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTextureUnitManager");
  publicAPI.deleteTable = function() {
    for (var i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        vtkErrorMacro24("some texture units  were not properly released");
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };
  publicAPI.setContext = function(ctx) {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
        for (var i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.allocate = function() {
    for (var i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };
  publicAPI.allocateUnit = function(unit) {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }
    model.textureUnits[unit] = true;
    return unit;
  };
  publicAPI.isAllocated = function(textureUnitId) {
    return model.textureUnits[textureUnitId];
  };
  publicAPI.free = function(val) {
    model.textureUnits[val] = false;
  };
}
function extend81(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES80, initialValues);
  macro.obj(publicAPI, model);
  model.textureUnits = [];
  macro.get(publicAPI, model, ["numberOfTextureUnits"]);
  macro.setGet(publicAPI, model, ["context"]);
  vtkOpenGLTextureUnitManager(publicAPI, model);
}
var vtkErrorMacro24, DEFAULT_VALUES80, newInstance81, vtkTextureUnitManager;
var init_TextureUnitManager = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/TextureUnitManager.js"() {
    init_macros();
    vtkErrorMacro24 = macro.vtkErrorMacro;
    DEFAULT_VALUES80 = {
      context: null,
      numberOfTextureUnits: 0,
      textureUnits: 0
    };
    newInstance81 = macro.newInstance(extend81, "vtkOpenGLTextureUnitManager");
    vtkTextureUnitManager = {
      newInstance: newInstance81,
      extend: extend81
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js
function vtkRenderWindowViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkRenderWindowViewNode");
  publicAPI.getViewNodeFactory = function() {
    return null;
  };
  publicAPI.getAspectRatio = function() {
    return model.size[0] / model.size[1];
  };
  publicAPI.getAspectRatioForRenderer = function(renderer) {
    var viewport = renderer.getViewportByReference();
    return model.size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * model.size[1]);
  };
  publicAPI.isInViewport = function(x, y, viewport) {
    var vCoords = viewport.getViewportByReference();
    var size = publicAPI.getFramebufferSize();
    if (vCoords[0] * size[0] <= x && vCoords[2] * size[0] >= x && vCoords[1] * size[1] <= y && vCoords[3] * size[1] >= y) {
      return true;
    }
    return false;
  };
  publicAPI.getViewportSize = function(viewport) {
    var vCoords = viewport.getViewportByReference();
    var size = publicAPI.getFramebufferSize();
    return [(vCoords[2] - vCoords[0]) * size[0], (vCoords[3] - vCoords[1]) * size[1]];
  };
  publicAPI.getViewportCenter = function(viewport) {
    var size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };
  publicAPI.displayToNormalizedDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };
  publicAPI.normalizedDisplayToDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };
  publicAPI.worldToView = function(x, y, z, renderer) {
    return renderer.worldToView(x, y, z);
  };
  publicAPI.viewToWorld = function(x, y, z, renderer) {
    return renderer.viewToWorld(x, y, z);
  };
  publicAPI.worldToDisplay = function(x, y, z, renderer) {
    var val = renderer.worldToView(x, y, z);
    var dims = publicAPI.getViewportSize(renderer);
    var val2 = renderer.viewToProjection(val[0], val[1], val[2], dims[0] / dims[1]);
    var val3 = renderer.projectionToNormalizedDisplay(val2[0], val2[1], val2[2]);
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };
  publicAPI.displayToWorld = function(x, y, z, renderer) {
    var val = publicAPI.displayToNormalizedDisplay(x, y, z);
    var val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    var dims = publicAPI.getViewportSize(renderer);
    var val3 = renderer.projectionToView(val2[0], val2[1], val2[2], dims[0] / dims[1]);
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };
  publicAPI.normalizedDisplayToViewport = function(x, y, z, renderer) {
    var vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    var coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };
  publicAPI.viewportToNormalizedViewport = function(x, y, z, renderer) {
    var size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1), y / (size[1] - 1), z];
    }
    return [x, y, z];
  };
  publicAPI.normalizedViewportToViewport = function(x, y, z, renderer) {
    var size = publicAPI.getViewportSize(renderer);
    return [x * (size[0] - 1), y * (size[1] - 1), z];
  };
  publicAPI.displayToLocalDisplay = function(x, y, z) {
    var size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };
  publicAPI.viewportToNormalizedDisplay = function(x, y, z, renderer) {
    var vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0);
    var x2 = x + vCoords[0] + 0.5;
    var y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };
  publicAPI.getPixelData = function(x1, y1, x2, y2) {
    macro.vtkErrorMacro("not implemented");
    return void 0;
  };
  publicAPI.createSelector = function() {
    macro.vtkErrorMacro("not implemented");
    return void 0;
  };
}
function extend82(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES81, initialValues);
  if (!model.size) {
    model.size = [300, 300];
  }
  macro.getArray(publicAPI, model, ["size"], 2);
  macro.get(publicAPI, model, ["selector"]);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkRenderWindowViewNode(publicAPI, model);
}
var DEFAULT_VALUES81, newInstance82, vtkRenderWindowViewNode$1;
var init_RenderWindowViewNode = __esm({
  "node_modules/@kitware/vtk.js/Rendering/SceneGraph/RenderWindowViewNode.js"() {
    init_macros();
    init_ViewNode();
    DEFAULT_VALUES81 = {
      size: void 0,
      selector: void 0
    };
    newInstance82 = macro.newInstance(extend82, "vtkRenderWindowViewNode");
    vtkRenderWindowViewNode$1 = {
      newInstance: newInstance82,
      extend: extend82
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js
var RenderWindow_exports2 = {};
__export(RenderWindow_exports2, {
  default: () => vtkRenderWindow2,
  extend: () => extend83,
  newInstance: () => newInstance83,
  popMonitorGLContextCount: () => popMonitorGLContextCount,
  pushMonitorGLContextCount: () => pushMonitorGLContextCount
});
function checkRenderTargetSupport(gl, format, type) {
  var framebuffer = gl.createFramebuffer();
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);
  return status === gl.FRAMEBUFFER_COMPLETE;
}
function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach(function(cb) {
    return cb(GL_CONTEXT_COUNT);
  });
}
function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach(function(cb) {
    return cb(GL_CONTEXT_COUNT);
  });
}
function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}
function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}
function vtkOpenGLRenderWindow(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderWindow");
  publicAPI.getViewNodeFactory = function() {
    return model.myFactory;
  };
  var previousSize = [0, 0];
  function updateWindow() {
    if (model.renderable) {
      if (model.size[0] !== previousSize[0] || model.size[1] !== previousSize[1]) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute("width", model.size[0]);
        model.canvas.setAttribute("height", model.size[1]);
      }
    }
    if (model.viewStream) {
      model.viewStream.setSize(model.size[0], model.size[1]);
    }
    model.canvas.style.display = model.useOffScreen ? "none" : "block";
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : "none";
    }
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();
      publicAPI.initialize();
      model.children.forEach(function(child) {
        child.setOpenGLRenderWindow(publicAPI);
      });
    }
  };
  publicAPI.initialize = function() {
    if (!model.initialized) {
      model.context = publicAPI.get3DContext();
      model.textureUnitManager = vtkTextureUnitManager.newInstance();
      model.textureUnitManager.setContext(model.context);
      model.shaderCache.setContext(model.context);
      var gl = model.context;
      gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      model.initialized = true;
    }
  };
  publicAPI.makeCurrent = function() {
    model.context.makeCurrent();
  };
  publicAPI.setContainer = function(el) {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro25("Error: canvas parent node does not match container");
      }
      model.el.removeChild(model.canvas);
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }
    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }
      publicAPI.modified();
    }
  };
  publicAPI.getContainer = function() {
    return model.el;
  };
  publicAPI.getContainerSize = function() {
    if (!model.containerSize && model.el) {
      var _model$el$getBounding = model.el.getBoundingClientRect(), width = _model$el$getBounding.width, height = _model$el$getBounding.height;
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };
  publicAPI.getFramebufferSize = function() {
    if (model.activeFramebuffer) {
      return model.activeFramebuffer.getSize();
    }
    return model.size;
  };
  publicAPI.getPixelData = function(x1, y1, x2, y2) {
    var pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(x1, y1, x2 - x1 + 1, y2 - y1 + 1, model.context.RGBA, model.context.UNSIGNED_BYTE, pixels);
    return pixels;
  };
  publicAPI.get3DContext = function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      preserveDrawingBuffer: false,
      depth: true,
      alpha: true,
      powerPreference: "high-performance"
    };
    var result = null;
    if (navigator.xr !== void 0 && navigator.xr.isSessionSupported("immersive-vr")) {
      publicAPI.invokeHaveVRDisplay();
    }
    var webgl2Supported = typeof WebGL2RenderingContext !== "undefined";
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext("webgl2", options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro12("using webgl2");
      }
    }
    if (!result) {
      vtkDebugMacro12("using webgl1");
      result = model.canvas.getContext("webgl", options) || model.canvas.getContext("experimental-webgl", options);
    }
    model.canvas.addEventListener("webglcontextlost", function(event2) {
      event2.preventDefault();
    }, false);
    model.canvas.addEventListener("webglcontextrestored", publicAPI.restoreContext, false);
    return result;
  };
  publicAPI.startXR = function(isAR) {
    if (navigator.xr === void 0) {
      throw new Error("WebXR is not available");
    }
    model.xrSessionIsAR = isAR;
    var sessionType = isAR ? "immersive-ar" : "immersive-vr";
    if (!navigator.xr.isSessionSupported(sessionType)) {
      if (isAR) {
        throw new Error("Device does not support AR session");
      } else {
        throw new Error("VR display is not available");
      }
    }
    if (model.xrSession === null) {
      navigator.xr.requestSession(sessionType).then(publicAPI.enterXR, function() {
        throw new Error("Failed to create XR session!");
      });
    } else {
      throw new Error("XR Session already exists!");
    }
  };
  publicAPI.enterXR = function() {
    var _ref = _asyncToGenerator(import_regenerator3.default.mark(function _callee(xrSession) {
      var gl, glLayer;
      return import_regenerator3.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              model.xrSession = xrSession;
              model.oldCanvasSize = model.size.slice();
              if (!(model.xrSession !== null)) {
                _context.next = 15;
                break;
              }
              gl = publicAPI.get3DContext();
              _context.next = 6;
              return gl.makeXRCompatible();
            case 6:
              glLayer = new global.XRWebGLLayer(model.xrSession, gl);
              publicAPI.setSize(glLayer.framebufferWidth, glLayer.framebufferHeight);
              model.xrSession.updateRenderState({
                baseLayer: glLayer
              });
              model.xrSession.requestReferenceSpace("local").then(function(refSpace) {
                model.xrReferenceSpace = refSpace;
              });
              publicAPI.resetXRScene();
              model.renderable.getInteractor().switchToXRAnimation();
              model.xrSceneFrame = model.xrSession.requestAnimationFrame(publicAPI.xrRender);
              _context.next = 16;
              break;
            case 15:
              throw new Error("Failed to enter VR with a null xrSession.");
            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }();
  publicAPI.resetXRScene = function() {
    var inputRescaleFactor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_RESET_FACTORS.vr.rescaleFactor;
    var inputTranslateZ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_RESET_FACTORS.vr.translateZ;
    var rescaleFactor = inputRescaleFactor;
    var translateZ = inputTranslateZ;
    if (model.xrSessionIsAR && rescaleFactor === DEFAULT_RESET_FACTORS.vr.rescaleFactor) {
      rescaleFactor = DEFAULT_RESET_FACTORS.ar.rescaleFactor;
    }
    if (model.xrSessionIsAR && translateZ === DEFAULT_RESET_FACTORS.vr.translateZ) {
      translateZ = DEFAULT_RESET_FACTORS.ar.translateZ;
    }
    var ren = model.renderable.getRenderers()[0];
    ren.resetCamera();
    var camera = ren.getActiveCamera();
    var physicalScale = camera.getPhysicalScale();
    var physicalTranslation = camera.getPhysicalTranslation();
    physicalScale /= rescaleFactor;
    translateZ *= physicalScale;
    physicalTranslation[2] += translateZ;
    camera.setPhysicalScale(physicalScale);
    camera.setPhysicalTranslation(physicalTranslation);
  };
  publicAPI.stopXR = _asyncToGenerator(import_regenerator3.default.mark(function _callee2() {
    var gl, ren;
    return import_regenerator3.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!(navigator.xr === void 0)) {
              _context2.next = 2;
              break;
            }
            return _context2.abrupt("return");
          case 2:
            if (!(model.xrSession !== null)) {
              _context2.next = 10;
              break;
            }
            model.xrSession.cancelAnimationFrame(model.xrSceneFrame);
            model.renderable.getInteractor().returnFromXRAnimation();
            gl = publicAPI.get3DContext();
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            _context2.next = 9;
            return model.xrSession.end().catch(function(error) {
              if (!(error instanceof DOMException)) {
                throw error;
              }
            });
          case 9:
            model.xrSession = null;
          case 10:
            if (model.oldCanvasSize !== void 0) {
              publicAPI.setSize.apply(publicAPI, _toConsumableArray(model.oldCanvasSize));
            }
            ren = model.renderable.getRenderers()[0];
            ren.getActiveCamera().setProjectionMatrix(null);
            ren.resetCamera();
            ren.setViewport(0, 0, 1, 1);
            publicAPI.traverseAllPasses();
          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  publicAPI.xrRender = function() {
    var _ref3 = _asyncToGenerator(import_regenerator3.default.mark(function _callee3(t, frame) {
      var xrSession, xrPose, gl, glLayer, ren;
      return import_regenerator3.default.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              xrSession = frame.session;
              model.renderable.getInteractor().updateXRGamepads(xrSession, frame, model.xrReferenceSpace);
              model.xrSceneFrame = model.xrSession.requestAnimationFrame(publicAPI.xrRender);
              xrPose = frame.getViewerPose(model.xrReferenceSpace);
              if (xrPose) {
                gl = publicAPI.get3DContext();
                if (model.xrSessionIsAR && model.oldCanvasSize !== void 0) {
                  gl.canvas.width = model.oldCanvasSize[0];
                  gl.canvas.height = model.oldCanvasSize[1];
                }
                glLayer = xrSession.renderState.baseLayer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.clear(gl.DEPTH_BUFFER_BIT);
                ren = model.renderable.getRenderers()[0];
                xrPose.views.forEach(function(view) {
                  var viewport = glLayer.getViewport(view);
                  gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                  if (!model.xrSessionIsAR) {
                    if (view.eye === "left") {
                      ren.setViewport(0, 0, 0.5, 1);
                    } else if (view.eye === "right") {
                      ren.setViewport(0.5, 0, 1, 1);
                    } else {
                      return;
                    }
                  }
                  ren.getActiveCamera().computeViewParametersFromPhysicalMatrix(view.transform.inverse.matrix);
                  ren.getActiveCamera().setProjectionMatrix(view.projectionMatrix);
                  publicAPI.traverseAllPasses();
                });
              }
            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return function(_x2, _x3) {
      return _ref3.apply(this, arguments);
    };
  }();
  publicAPI.restoreContext = function() {
    var rp = vtkRenderPass$1.newInstance();
    rp.setCurrentOperation("Release");
    rp.traverse(publicAPI, null);
  };
  publicAPI.activateTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }
    var activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro25("Hardware does not support the number of textures defined.");
      return;
    }
    model._textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };
  publicAPI.deactivateTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      publicAPI.getTextureUnitManager().free(result);
      delete model._textureResourceIds.delete(texture);
    }
  };
  publicAPI.getTextureUnitForTexture = function(texture) {
    var result = model._textureResourceIds.get(texture);
    if (result !== void 0) {
      return result;
    }
    return -1;
  };
  publicAPI.getDefaultTextureInternalFormat = function(vtktype, numComps, useFloat) {
    if (model.webgl2) {
      switch (vtktype) {
        case VtkDataTypes.UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        case VtkDataTypes.FLOAT:
        default:
          switch (numComps) {
            case 1:
              return model.context.R16F;
            case 2:
              return model.context.RG16F;
            case 3:
              return model.context.RGB16F;
            case 4:
            default:
              return model.context.RGBA16F;
          }
      }
    }
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };
  publicAPI.setBackgroundImage = function(img) {
    model.bgImage.src = img.src;
  };
  publicAPI.setUseBackgroundImage = function(value) {
    model.useBackgroundImage = value;
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };
  function getCanvasDataURL() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : model.imageFormat;
    var temporaryCanvas = document.createElement("canvas");
    var temporaryContext = temporaryCanvas.getContext("2d");
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);
    var mainBoundingClientRect = model.canvas.getBoundingClientRect();
    var renderWindow = model.renderable;
    var renderers = renderWindow.getRenderers();
    renderers.forEach(function(renderer) {
      var viewProps = renderer.getViewProps();
      viewProps.forEach(function(viewProp) {
        if (viewProp.getContainer) {
          var container = viewProp.getContainer();
          var canvasList = container.getElementsByTagName("canvas");
          for (var i = 0; i < canvasList.length; i++) {
            var currentCanvas = canvasList[i];
            var boundingClientRect = currentCanvas.getBoundingClientRect();
            var newXPosition = boundingClientRect.x - mainBoundingClientRect.x;
            var newYPosition = boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(currentCanvas, newXPosition, newYPosition);
          }
        }
      });
    });
    var screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }
  publicAPI.captureNextImage = function() {
    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "image/png";
    var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref4$resetCamera = _ref4.resetCamera, resetCamera = _ref4$resetCamera === void 0 ? false : _ref4$resetCamera, _ref4$size = _ref4.size, size = _ref4$size === void 0 ? null : _ref4$size, _ref4$scale = _ref4.scale, scale = _ref4$scale === void 0 ? 1 : _ref4$scale;
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    var previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;
    model._screenshot = {
      size: !!size || scale !== 1 ? size || model.size.map(function(val) {
        return val * scale;
      }) : null
    };
    return new Promise(function(resolve, reject) {
      var subscription = publicAPI.onImageReady(function(imageURL) {
        if (model._screenshot.size === null) {
          model.notifyStartCaptureImage = previous;
          subscription.unsubscribe();
          if (model._screenshot.placeHolder) {
            model.size = model._screenshot.originalSize;
            publicAPI.modified();
            if (model._screenshot.cameras) {
              model._screenshot.cameras.forEach(function(_ref5) {
                var restoreParamsFn = _ref5.restoreParamsFn, arg = _ref5.arg;
                return restoreParamsFn(arg);
              });
            }
            publicAPI.traverseAllPasses();
            model.el.removeChild(model._screenshot.placeHolder);
            model._screenshot.placeHolder.remove();
            model._screenshot = null;
          }
          resolve(imageURL);
        } else {
          var tmpImg = document.createElement("img");
          tmpImg.style = SCREENSHOT_PLACEHOLDER;
          tmpImg.src = imageURL;
          model._screenshot.placeHolder = model.el.appendChild(tmpImg);
          model.canvas.style.display = "none";
          model._screenshot.originalSize = model.size;
          model.size = model._screenshot.size;
          model._screenshot.size = null;
          publicAPI.modified();
          if (resetCamera) {
            var isUserResetCamera = resetCamera !== true;
            model._screenshot.cameras = model.renderable.getRenderers().map(function(renderer) {
              var camera = renderer.getActiveCamera();
              var params = camera.get("focalPoint", "position", "parallelScale");
              return {
                resetCameraArgs: isUserResetCamera ? {
                  renderer
                } : void 0,
                resetCameraFn: isUserResetCamera ? resetCamera : renderer.resetCamera,
                restoreParamsFn: camera.set,
                arg: JSON.parse(JSON.stringify(params))
              };
            });
            model._screenshot.cameras.forEach(function(_ref6) {
              var resetCameraFn = _ref6.resetCameraFn, resetCameraArgs = _ref6.resetCameraArgs;
              return resetCameraFn(resetCameraArgs);
            });
          }
          publicAPI.traverseAllPasses();
        }
      });
    });
  };
  publicAPI.getGLInformations = function() {
    var gl = publicAPI.get3DContext();
    var glTextureFloat = gl.getExtension("OES_texture_float");
    var glTextureHalfFloat = gl.getExtension("OES_texture_half_float");
    var glDebugRendererInfo = gl.getExtension("WEBGL_debug_renderer_info");
    var glDrawBuffers = gl.getExtension("WEBGL_draw_buffers");
    var glAnisotropic = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
    var params = [["Max Vertex Attributes", "MAX_VERTEX_ATTRIBS", gl.getParameter(gl.MAX_VERTEX_ATTRIBS)], ["Max Varying Vectors", "MAX_VARYING_VECTORS", gl.getParameter(gl.MAX_VARYING_VECTORS)], ["Max Vertex Uniform Vectors", "MAX_VERTEX_UNIFORM_VECTORS", gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS)], ["Max Fragment Uniform Vectors", "MAX_FRAGMENT_UNIFORM_VECTORS", gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS)], ["Max Fragment Texture Image Units", "MAX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)], ["Max Vertex Texture Image Units", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS)], ["Max Combined Texture Image Units", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS)], ["Max 2D Texture Size", "MAX_TEXTURE_SIZE", gl.getParameter(gl.MAX_TEXTURE_SIZE)], ["Max Cube Texture Size", "MAX_CUBE_MAP_TEXTURE_SIZE", gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)], ["Max Texture Anisotropy", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", glAnisotropic && gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)], ["Point Size Range", "ALIASED_POINT_SIZE_RANGE", gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(" - ")], ["Line Width Range", "ALIASED_LINE_WIDTH_RANGE", gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(" - ")], ["Max Viewport Dimensions", "MAX_VIEWPORT_DIMS", gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(" - ")], ["Max Renderbuffer Size", "MAX_RENDERBUFFER_SIZE", gl.getParameter(gl.MAX_RENDERBUFFER_SIZE)], ["Framebuffer Red Bits", "RED_BITS", gl.getParameter(gl.RED_BITS)], ["Framebuffer Green Bits", "GREEN_BITS", gl.getParameter(gl.GREEN_BITS)], ["Framebuffer Blue Bits", "BLUE_BITS", gl.getParameter(gl.BLUE_BITS)], ["Framebuffer Alpha Bits", "ALPHA_BITS", gl.getParameter(gl.ALPHA_BITS)], ["Framebuffer Depth Bits", "DEPTH_BITS", gl.getParameter(gl.DEPTH_BITS)], ["Framebuffer Stencil Bits", "STENCIL_BITS", gl.getParameter(gl.STENCIL_BITS)], ["Framebuffer Subpixel Bits", "SUBPIXEL_BITS", gl.getParameter(gl.SUBPIXEL_BITS)], ["MSAA Samples", "SAMPLES", gl.getParameter(gl.SAMPLES)], ["MSAA Sample Buffers", "SAMPLE_BUFFERS", gl.getParameter(gl.SAMPLE_BUFFERS)], ["Supported Formats for UByte Render Targets     ", "UNSIGNED_BYTE RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Half Float Render Targets", "HALF FLOAT RENDER TARGET FORMATS", [glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGBA, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGBA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.RGB, glTextureHalfFloat.HALF_FLOAT_OES) ? "RGB" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "ALPHA" : "", glTextureHalfFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, glTextureHalfFloat.HALF_FLOAT_OES) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Supported Formats for Full Float Render Targets", "FLOAT RENDER TARGET FORMATS", [glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT) ? "RGBA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT) ? "RGB" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT) ? "LUMINANCE" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT) ? "ALPHA" : "", glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT) ? "LUMINANCE_ALPHA" : ""].join(" ")], ["Max Multiple Render Targets Buffers", "MAX_DRAW_BUFFERS_WEBGL", glDrawBuffers ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL) : 0], ["High Float Precision in Vertex Shader", "HIGH_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Vertex Shader", "MEDIUM_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Vertex Shader", "LOW_FLOAT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Float Precision in Fragment Shader", "HIGH_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).rangeMax, "</sup>)"].join("")], ["Medium Float Precision in Fragment Shader", "MEDIUM_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).rangeMax, "</sup>)"].join("")], ["Low Float Precision in Fragment Shader", "LOW_FLOAT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Vertex Shader", "HIGH_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Vertex Shader", "MEDIUM_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Vertex Shader", "LOW_INT VERTEX_SHADER", [gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["High Int Precision in Fragment Shader", "HIGH_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax, "</sup>)"].join("")], ["Medium Int Precision in Fragment Shader", "MEDIUM_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT).rangeMax, "</sup>)"].join("")], ["Low Int Precision in Fragment Shader", "LOW_INT FRAGMENT_SHADER", [gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision, " (-2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin, "</sup> - 2<sup>", gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax, "</sup>)"].join("")], ["Supported Extensions", "EXTENSIONS", gl.getSupportedExtensions().join("<br/>					    ")], ["WebGL Renderer", "RENDERER", gl.getParameter(gl.RENDERER)], ["WebGL Vendor", "VENDOR", gl.getParameter(gl.VENDOR)], ["WebGL Version", "VERSION", gl.getParameter(gl.VERSION)], ["Shading Language Version", "SHADING_LANGUAGE_VERSION", gl.getParameter(gl.SHADING_LANGUAGE_VERSION)], ["Unmasked Renderer", "UNMASKED_RENDERER", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL)], ["Unmasked Vendor", "UNMASKED_VENDOR", glDebugRendererInfo && gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL)], ["WebGL Version", "WEBGL_VERSION", model.webgl2 ? 2 : 1]];
    var result = {};
    while (params.length) {
      var _params$pop = params.pop(), _params$pop2 = _slicedToArray(_params$pop, 3), label = _params$pop2[0], key = _params$pop2[1], value = _params$pop2[2];
      if (key) {
        result[key] = {
          label,
          value
        };
      }
    }
    return result;
  };
  publicAPI.traverseAllPasses = function() {
    if (model.renderPasses) {
      for (var index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
  };
  publicAPI.disableCullFace = function() {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };
  publicAPI.enableCullFace = function() {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };
  publicAPI.setViewStream = function(stream) {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      var mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;
      publicAPI.setUseBackgroundImage(true);
      model.subscription = model.viewStream.onImageReady(function(e) {
        return publicAPI.setBackgroundImage(e.image);
      });
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();
      publicAPI.modified();
    }
    return true;
  };
  publicAPI.createSelector = function() {
    var ret = vtkHardwareSelector2.newInstance();
    ret.setOpenGLRenderWindow(publicAPI);
    return ret;
  };
  publicAPI.delete = macro.chain(publicAPI.delete, publicAPI.setViewStream, deleteGLContext);
}
function extend83(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES82, initialValues);
  vtkRenderWindowViewNode$1.extend(publicAPI, model, initialValues);
  model.canvas = document.createElement("canvas");
  model.canvas.style.width = "100%";
  createGLContext();
  if (!model.selector) {
    model.selector = vtkHardwareSelector2.newInstance();
    model.selector.setOpenGLRenderWindow(publicAPI);
  }
  model.bgImage = new Image();
  model.bgImage.style.position = "absolute";
  model.bgImage.style.left = "0";
  model.bgImage.style.top = "0";
  model.bgImage.style.width = "100%";
  model.bgImage.style.height = "100%";
  model.bgImage.style.zIndex = "-1";
  model._textureResourceIds = /* @__PURE__ */ new Map();
  model.myFactory = vtkViewNodeFactory2.newInstance();
  model.myFactory.registerOverride("vtkRenderWindow", newInstance83);
  model.shaderCache = vtkShaderCache$1.newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);
  model.renderPasses[0] = vtkForwardPass$1.newInstance();
  macro.event(publicAPI, model, "imageReady");
  macro.event(publicAPI, model, "haveVRDisplay");
  macro.get(publicAPI, model, ["shaderCache", "textureUnitManager", "webgl2", "vrDisplay", "useBackgroundImage", "xrSupported"]);
  macro.setGet(publicAPI, model, [
    "initialized",
    "context",
    "canvas",
    "renderPasses",
    "notifyStartCaptureImage",
    "defaultToWebgl2",
    "cursor",
    "useOffScreen",
    "activeFramebuffer"
  ]);
  macro.setGetArray(publicAPI, model, ["size"], 2);
  vtkOpenGLRenderWindow(publicAPI, model);
}
var import_regenerator3, vtkDebugMacro12, vtkErrorMacro25, SCREENSHOT_PLACEHOLDER, DEFAULT_RESET_FACTORS, GL_CONTEXT_COUNT, GL_CONTEXT_LISTENERS, DEFAULT_VALUES82, newInstance83, vtkRenderWindow2;
var init_RenderWindow2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/RenderWindow.js"() {
    init_slicedToArray();
    init_toConsumableArray();
    init_asyncToGenerator();
    import_regenerator3 = __toESM(require_regenerator());
    init_Constants2();
    init_macros();
    init_RenderWindow();
    init_ForwardPass();
    init_HardwareSelector2();
    init_ShaderCache2();
    init_TextureUnitManager();
    init_ViewNodeFactory2();
    init_RenderPass();
    init_RenderWindowViewNode();
    vtkDebugMacro12 = macro.vtkDebugMacro;
    vtkErrorMacro25 = macro.vtkErrorMacro;
    SCREENSHOT_PLACEHOLDER = {
      position: "absolute",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%"
    };
    DEFAULT_RESET_FACTORS = {
      vr: {
        rescaleFactor: 1,
        translateZ: -0.7
      },
      ar: {
        rescaleFactor: 0.25,
        translateZ: -0.5
      }
    };
    GL_CONTEXT_COUNT = 0;
    GL_CONTEXT_LISTENERS = [];
    DEFAULT_VALUES82 = {
      cullFaceEnabled: false,
      shaderCache: null,
      initialized: false,
      context: null,
      canvas: null,
      cursorVisibility: true,
      cursor: "pointer",
      textureUnitManager: null,
      textureResourceIds: null,
      containerSize: null,
      renderPasses: [],
      notifyStartCaptureImage: false,
      webgl2: false,
      defaultToWebgl2: true,
      activeFramebuffer: null,
      xrSession: null,
      xrSessionIsAR: false,
      xrReferenceSpace: null,
      xrSupported: true,
      imageFormat: "image/png",
      useOffScreen: false,
      useBackgroundImage: false
    };
    newInstance83 = macro.newInstance(extend83, "vtkOpenGLRenderWindow");
    registerViewConstructor("WebGL", newInstance83);
    vtkRenderWindow2 = {
      newInstance: newInstance83,
      extend: extend83,
      pushMonitorGLContextCount,
      popMonitorGLContextCount
    };
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
var Actor_exports2 = {};
__export(Actor_exports2, {
  default: () => vtkActor2,
  extend: () => extend84,
  newInstance: () => newInstance84
});
function vtkOpenGLActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (var index = 0; index < model.children.length; index++) {
        var child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.traverseOpaqueZBufferPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = function() {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (var index = 0; index < model.ogltextures.length; index++) {
      var child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass, renderPass) {
    return publicAPI.opaquePass(prepass, renderPass);
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (var index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (var index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = function() {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat3_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
function extend84(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES83, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor(publicAPI, model);
}
var DEFAULT_VALUES83, newInstance84, vtkActor2;
var init_Actor2 = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js"() {
    init_esm();
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    DEFAULT_VALUES83 = {
      context: null,
      keyMatrixTime: null,
      keyMatrices: null,
      activeTextures: null
    };
    newInstance84 = newInstance(extend84);
    vtkActor2 = {
      newInstance: newInstance84,
      extend: extend84
    };
    registerOverride("vtkActor", newInstance84);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
var Actor2D_exports = {};
__export(Actor2D_exports, {
  default: () => vtkActor2D,
  extend: () => extend85,
  newInstance: () => newInstance85
});
function vtkOpenGLActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor2D");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (var index = 0; index < model.children.length; index++) {
        var child = model.children[index];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };
  publicAPI.traverseOpaquePass = function(renderPass) {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = function(renderPass) {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = function(renderPass) {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = function() {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (var index = 0; index < model.ogltextures.length; index++) {
      var child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (var index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (var index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
  publicAPI.overlayPass = function(prepass, renderPass) {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (var index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };
}
function extend85(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES84, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor2D(publicAPI, model);
}
var DEFAULT_VALUES84, newInstance85, vtkActor2D;
var init_Actor2D = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js"() {
    init_macros();
    init_ViewNode();
    init_ViewNodeFactory2();
    DEFAULT_VALUES84 = {
      context: null,
      activeTextures: null
    };
    newInstance85 = newInstance(extend85);
    vtkActor2D = {
      newInstance: newInstance85,
      extend: extend85
    };
    registerOverride("vtkActor2D", newInstance85);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var PolyDataMapper_exports = {};
__export(PolyDataMapper_exports, {
  default: () => vtkOpenGLPolyDataMapper$1,
  extend: () => extend86,
  newInstance: () => newInstance86,
  primTypes: () => primTypes
});
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType("vtkOpenGLActor");
      model.openGLRenderer = model.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(model.openGLRenderer.getRenderable().getActiveCamera());
    }
  };
  publicAPI.translucentPass = function(prepass, renderPass) {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.opaqueZBufferPass = function(prepass) {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaquePass = function(prepass) {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = function() {
    var ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (var i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    var actor = model.openGLActor.getRenderable();
    var ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.buildShaders = function(shaders, ren, actor) {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    var openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    var shaderReplacements = null;
    if (openGLSpec) {
      shaderReplacements = openGLSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (var i = 0; i < shaderReplacements.length; i++) {
        var currReplacement = shaderReplacements[i];
        if (currReplacement.replaceFirst) {
          var shaderType = currReplacement.shaderType;
          var ssrc = shaders[shaderType];
          var substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
    publicAPI.replaceShaderValues(shaders, ren, actor);
    if (shaderReplacements) {
      for (var _i = 0; _i < shaderReplacements.length; _i++) {
        var _currReplacement = shaderReplacements[_i];
        if (!_currReplacement.replaceFirst) {
          var _shaderType = _currReplacement.shaderType;
          var _ssrc = shaders[_shaderType];
          var _substituteRes = vtkShaderProgram$1.substitute(_ssrc, _currReplacement.originalValue, _currReplacement.replacementValue, _currReplacement.replaceAll);
          shaders[_shaderType] = _substituteRes.result;
        }
      }
    }
  };
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    var openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    var vertexShaderCode = vtkPolyDataVS;
    if (openGLSpecProp) {
      var vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== void 0 && vertexSpecProp !== "") {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    var fragmentShaderCode = vtkPolyDataFS;
    if (openGLSpecProp) {
      var fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== void 0 && fragmentSpecProp !== "") {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    var geometryShaderCode = "";
    if (openGLSpecProp) {
      var geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== void 0) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
  publicAPI.replaceShaderColor = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var GSSource = shaders.Geometry;
    var FSSource = shaders.Fragment;
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    var colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity", "uniform vec3 ambientColorUniform;", "uniform vec3 diffuseColorUniform;"];
    if (lastLightComplexity) {
      colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
    }
    var colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
    }
    colorImpl = colorImpl.concat(["  ambientColor = ambientColorUniform;", "  diffuseColor = diffuseColorUniform;", "  opacity = opacityUniform;"]);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else {
      if (model.renderable.getInterpolateScalarsBeforeMapping() && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  ambientColor = texColor.rgb;", "  opacity = opacity*texColor.a;"])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform float opacityUniformBF; // the fragment opacity", "uniform float ambientIntensityBF; // the material ambient", "uniform float diffuseIntensityBF; // the material diffuse", "uniform vec3 ambientColorUniformBF; // ambient material color", "uniform vec3 diffuseColorUniformBF; // diffuse material color"]);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(["uniform float specularIntensityBF; // the material specular intensity", "uniform vec3 specularColorUniformBF; // intensity weighted color", "uniform float specularPowerUniformBF;"]);
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  specularColor = specularIntensityBF * specularColorUniformBF;", "  specularPower = specularPowerUniformBF;", "  opacity = opacityUniformBF; }"]);
          } else {
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  opacity = opacityUniformBF; }"]);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform samplerBuffer texture1;"]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    var shadowFactor = "";
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    var lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    var sstring = [];
    switch (lastLightComplexity) {
      case 0:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 1:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  float df = max(0.0, normalVCVSOutput.z);", "  float sf = pow(df, specularPower);", "  vec3 diffuseL = df * diffuseColor;", "  vec3 specularL = sf * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 2:
        for (var lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat(["uniform vec3 lightColor".concat(lc, ";"), "uniform vec3 lightDirectionVC".concat(lc, "; // normalized"), "uniform vec3 lightHalfAngleVC".concat(lc, "; // normalized")]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  float df;"];
        for (var _lc = 0; _lc < lastLightCount; ++_lc) {
          sstring = sstring.concat(["  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC".concat(_lc, "));"), "  diffuseL += ((df".concat(shadowFactor, ") * lightColor").concat(_lc, ");"), "  if (dot(normalVCVSOutput, lightDirectionVC".concat(_lc, ") < 0.0)"), "    {", "    float sf = pow( max(0.0, dot(lightHalfAngleVC".concat(_lc, ",normalVCVSOutput)), specularPower);"), "    specularL += ((sf".concat(shadowFactor, ") * lightColor").concat(_lc, ");"), "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      case 3:
        for (var _lc2 = 0; _lc2 < lastLightCount; ++_lc2) {
          sstring = sstring.concat(["uniform vec3 lightColor".concat(_lc2, ";"), "uniform vec3 lightDirectionVC".concat(_lc2, "; // normalized"), "uniform vec3 lightHalfAngleVC".concat(_lc2, "; // normalized"), "uniform vec3 lightPositionVC".concat(_lc2, ";"), "uniform vec3 lightAttenuation".concat(_lc2, ";"), "uniform float lightConeAngle".concat(_lc2, ";"), "uniform float lightExponent".concat(_lc2, ";"), "uniform int lightPositional".concat(_lc2, ";")]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  vec3 vertLightDirectionVC;", "  float attenuation;", "  float df;"];
        for (var _lc3 = 0; _lc3 < lastLightCount; ++_lc3) {
          sstring = sstring.concat(["  attenuation = 1.0;", "  if (lightPositional".concat(_lc3, " == 0)"), "    {", "      vertLightDirectionVC = lightDirectionVC".concat(_lc3, ";"), "    }", "  else", "    {", "    vertLightDirectionVC = vertexVC.xyz - lightPositionVC".concat(_lc3, ";"), "    float distanceVC = length(vertLightDirectionVC);", "    vertLightDirectionVC = normalize(vertLightDirectionVC);", "    attenuation = 1.0 /", "      (lightAttenuation".concat(_lc3, ".x"), "       + lightAttenuation".concat(_lc3, ".y * distanceVC"), "       + lightAttenuation".concat(_lc3, ".z * distanceVC * distanceVC);"), "    // per OpenGL standard cone angle is 90 or less for a spot light", "    if (lightConeAngle".concat(_lc3, " <= 90.0)"), "      {", "      float coneDot = dot(vertLightDirectionVC, lightDirectionVC".concat(_lc3, ");"), "      // if inside the cone", "      if (coneDot >= cos(radians(lightConeAngle".concat(_lc3, ")))"), "        {", "        attenuation = attenuation * pow(coneDot, lightExponent".concat(_lc3, ");"), "        }", "      else", "        {", "        attenuation = 0.0;", "        }", "      }", "    }", "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));", "    diffuseL += ((df".concat(shadowFactor, ") * lightColor").concat(_lc3, ");"), "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)", "      {", "      float sf = attenuation*pow( max(0.0, dot(lightHalfAngleVC".concat(_lc3, ",normalVCVSOutput)), specularPower);"), "    specularL += ((sf".concat(shadowFactor, ") * lightColor").concat(_lc3, ");"), "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      default:
        vtkErrorMacro26("bad light complexity");
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = function(shaders, ren, actor) {
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      var VSSource = shaders.Vertex;
      var GSSource = shaders.Geometry;
      var FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * normalMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Dec", ["in vec3 normalVCVSOutput[];", "out vec3 normalVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Impl", ["normalVCGSOutput = normalVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["varying vec3 normalVCVSOutput;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform mat3 normalMatrix;", "uniform samplerBuffer textureN;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput = normalize(normalMatrix *", "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);", "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result;
        } else {
          if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation(), model.lastBoundBO.getPrimitiveType()) === model.context.LINES) {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["  vec3 fdx = dFdx(vertexVC.xyz);", "  vec3 fdy = dFdy(vertexVC.xyz);", "  //VTK::UniformFlow::Impl"]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput;", "  if (abs(fdx.x) > 0.0)", "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }", "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform int cameraParallel;"]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", [
              "  vec3 fdx = dFdx(vertexVC.xyz);",
              "  vec3 fdy = dFdy(vertexVC.xyz);",
              "  //VTK::UniformFlow::Impl"
            ]).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
              "  fdx = normalize(fdx);",
              "  fdy = normalize(fdy);",
              "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
              "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
              "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
            ]).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var GSSource = shaders.Geometry;
    var FSSource = shaders.Fragment;
    if (actor.getProperty().getRepresentation() === Representation5.POINTS || model.lastBoundBO.getPrimitiveType() === primTypes.Points) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = ".concat(actor.getProperty().getPointSize(), ".0;")], false).result;
    }
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vertexVCVSOutput = MCVCMatrix * vertexMC;", "  gl_Position = MCPCMatrix * vertexMC;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Dec", ["in vec4 vertexVCVSOutput[];", "out vec4 vertexVCGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Impl", ["vertexVCGSOutput = vertexVCVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;"]).result;
    } else {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = function(shaders, ren, actor) {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      var VSSource = shaders.Vertex;
      var GSSource = shaders.Geometry;
      var FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
      var tus = model.openGLActor.getActiveTextures();
      var tNumComp = 2;
      var tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
          }
        }
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec3 tcoordVCVSOutput[];", "out vec3 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec3 tcoordVCVSOutput;", "uniform samplerCube texture1;"]).result;
        switch (tNumComp) {
          case 1:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
            break;
          case 2:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
            break;
          default:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "uniform vec4 clipPlanes[".concat(numClipPlanes, "];"), "varying float clipDistancesVSOutput[".concat(numClipPlanes, "];")]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < ".concat(numClipPlanes, "; planeNum++)"), "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", "varying float clipDistancesVSOutput[".concat(numClipPlanes, "];")]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", ["for (int planeNum = 0; planeNum < ".concat(numClipPlanes, "; planeNum++)"), "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = function(ren, actor) {
    var cp = null;
    var prop = actor.getProperty();
    if (model.renderable.getResolveCoincidentTopology() || prop.getEdgeVisibility() && prop.getRepresentation() === Representation5.SURFACE) {
      var primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes.Points || prop.getRepresentation() === Representation5.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes.Lines || prop.getRepresentation() === Representation5.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes.Tris || primType === primTypes.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes.TrisEdges || primType === primTypes.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2;
        cp.offset /= 2;
      }
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = function(shaders, ren, actor) {
    var FSSource = shaders.Fragment;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform vec3 mapperIndex;", "uniform int picking;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      var FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = function(cellBO, ren, actor) {
    var lightComplexity = 0;
    var numberOfLights = 0;
    var primType = cellBO.getPrimitiveType();
    var poly = model.currentInput;
    var needLighting = false;
    var pointNormals = poly.getPointData().getNormals();
    var cellNormals = poly.getCellData().getNormals();
    var flat = actor.getProperty().getInterpolation() === Shading2.FLAT;
    var representation = actor.getProperty().getRepresentation();
    var mode = publicAPI.getOpenGLMode(representation, primType);
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
    } else if (!flat && pointNormals) {
      needLighting = true;
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    if (actor.getProperty().getLighting() && needLighting) {
      lightComplexity = 0;
      var lights = ren.getLightsByReference();
      for (var index = 0; index < lights.length; ++index) {
        var light = lights[index];
        var status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    var needRebuild = false;
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    var lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement) {
      needRebuild = true;
      model.lastRenderPassShaderReplacement = null;
    }
    if (model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement = model.currentRenderPass.getShaderReplacement();
      needRebuild = true;
    }
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getProgram() === 0 || cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() || cellBO.getShaderSourceTime().getMTime() < actor.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = function(cellBO, ren, actor) {
    model.lastBoundBO = cellBO;
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      var shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      publicAPI.buildShaders(shaders, ren, actor);
      var newShader = model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        cellBO.getVAO().releaseGraphicsResources();
      }
      cellBO.getShaderSourceTime().modified();
    } else {
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(cellBO.getProgram());
    }
    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setLightingShaderParameters(cellBO, ren, actor);
    var listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach(function(object) {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro26("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("normalMC") && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "normalMC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro26("Error setting normalMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("normalMC");
      }
      model.renderable.getCustomShaderAttributes().forEach(function(attrName, idx) {
        if (cellBO.getProgram().isAttributeUsed("".concat(attrName, "MC"))) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "".concat(attrName, "MC"), cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro26("Error setting ".concat(attrName, "MC in shader VAO."));
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro26("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro26("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      var numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      var planeEquations = [];
      var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      var mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      for (var i = 0; i < numClipPlanes; i++) {
        var planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (var j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
      cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
    }
    var tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (var index = 0; index < tus.length; ++index) {
        var tex = tus[index];
        var texUnit = tex.getTextureUnit();
        var tname = "texture".concat(texUnit + 1);
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      var cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    var selector = model.openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
    cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = function(cellBO, ren, actor) {
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 2) {
      return;
    }
    var program = cellBO.getProgram();
    var numberOfLights = 0;
    var lights = ren.getLightsByReference();
    for (var index = 0; index < lights.length; ++index) {
      var light = lights[index];
      var status = light.getSwitch();
      if (status > 0) {
        var dColor = light.getColorByReference();
        var intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        var ld = light.getDirection();
        var transform = ren.getActiveCamera().getViewMatrix();
        var newLightDirection = _toConsumableArray(ld);
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          normalize(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        model.lightHalfAngle[0] = -model.lightDirection[0];
        model.lightHalfAngle[1] = -model.lightDirection[1];
        model.lightHalfAngle[2] = -model.lightDirection[2] + 1;
        normalize(model.lightDirection);
        program.setUniform3fArray("lightColor".concat(numberOfLights), model.lightColor);
        program.setUniform3fArray("lightDirectionVC".concat(numberOfLights), model.lightDirection);
        program.setUniform3fArray("lightHalfAngleVC".concat(numberOfLights), model.lightHalfAngle);
        numberOfLights++;
      }
    }
    if (lastLightComplexity < 3) {
      return;
    }
    var cam = ren.getActiveCamera();
    var viewTF = cam.getViewMatrix();
    mat4_exports.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (var _index = 0; _index < lights.length; ++_index) {
      var _light = lights[_index];
      var _status = _light.getSwitch();
      if (_status > 0) {
        var lp = _light.getTransformedPosition();
        var np = new Float64Array(3);
        vec3_exports.transformMat4(np, lp, viewTF);
        program.setUniform3fArray("lightAttenuation".concat(numberOfLights), _light.getAttenuationValuesByReference());
        program.setUniformi("lightPositional".concat(numberOfLights), _light.getPositional());
        program.setUniformf("lightExponent".concat(numberOfLights), _light.getExponent());
        program.setUniformf("lightConeAngle".concat(numberOfLights), _light.getConeAngle());
        program.setUniform3fArray("lightPositionVC".concat(numberOfLights), [np[0], np[1], np[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce(function(res, matrix, index) {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    var cam = ren.getActiveCamera();
    var camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    var progm = program.getLastCameraMTime();
    var shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    var inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    var actorIsIdentity = actor.getIsIdentity();
    var actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    if (program.isUniformUsed("MCVCMatrix")) {
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("normalMatrix")) {
      program.setUniformMatrix3x3("normalMatrix", safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3_exports, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed("cameraParallel")) {
        program.setUniformi("cameraParallel", cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var ppty = actor.getProperty();
    var opacity = ppty.getOpacity();
    var aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    var dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    var aIntensity = model.drawingEdges ? 1 : ppty.getAmbient();
    var dIntensity = model.drawingEdges ? 0 : ppty.getDiffuse();
    var sIntensity = model.drawingEdges ? 0 : ppty.getSpecular();
    var specularPower = ppty.getSpecularPower();
    program.setUniformf("opacityUniform", opacity);
    program.setUniform3fArray("ambientColorUniform", aColor);
    program.setUniform3fArray("diffuseColorUniform", dColor);
    program.setUniformf("ambient", aIntensity);
    program.setUniformf("diffuse", dIntensity);
    var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 1) {
      return;
    }
    var sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray("specularColorUniform", sColor);
    program.setUniformf("specularPowerUniform", specularPower);
    program.setUniformf("specular", sIntensity);
    if (program.isUniformUsed("ambientIntensityBF")) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf("ambientIntensityBF", aIntensity);
      program.setUniformf("diffuseIntensityBF", dIntensity);
      program.setUniformf("opacityUniformBF", opacity);
      program.setUniform3fArray("ambientColorUniformBF", aColor);
      program.setUniform3fArray("diffuseColorUniformBF", dColor);
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf("specularIntensityBF", sIntensity);
      program.setUniform3fArray("specularColorUniformBF", sColor);
      program.setUniformf("specularPowerUniformBF", specularPower);
    }
  };
  publicAPI.renderPieceStart = function(ren, actor) {
    model.primitiveIDOffset = 0;
    if (model.openGLRenderer.getSelector()) {
      switch (model.openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model.openGLRenderer.getSelector().renderProp(actor);
      }
    }
    publicAPI.updateBufferObjects(ren, actor);
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var representation = actor.getProperty().getRepresentation();
    var gl = model.context;
    var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation5.SURFACE;
    gl.lineWidth(actor.getProperty().getLineWidth());
    for (var i = primTypes.Start; i < primTypes.End; i++) {
      var cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);
        var mode = publicAPI.getOpenGLMode(representation, i);
        if (!model.drawingEdges || !model.renderDepth) {
          publicAPI.updateShaders(model.primitives[i], ren, actor);
          gl.drawArrays(mode, 0, cabo.getElementCount());
        }
        var stride = (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
        model.primitiveIDOffset += cabo.getElementCount() / stride;
      }
    }
    gl.lineWidth(1);
  };
  publicAPI.getOpenGLMode = function(rep, type) {
    if (rep === Representation5.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation5.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.renderPieceFinish = function(ren, actor) {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro26("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    var gl = model.context;
    var backfaceCulling = actor.getProperty().getBackfaceCulling();
    var frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.computeBounds = function(ren, actor) {
    if (!publicAPI.getInput()) {
      uninitializeBounds(model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };
  publicAPI.updateBufferObjects = function(ren, actor) {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    var vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    var c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    var scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      if ((scalarMode === ScalarMode3.USE_CELL_DATA || scalarMode === ScalarMode3.USE_CELL_FIELD_DATA || scalarMode === ScalarMode3.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode3.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    var n = actor.getProperty().getInterpolation() !== Shading2.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }
    var representation = actor.getProperty().getRepresentation();
    var tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance();
      }
      var tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter3.NEAREST);
      tex.setMagnificationFilter(Filter3.NEAREST);
      tex.setWrapS(Wrap3.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap3.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      var input = model.renderable.getColorTextureMap();
      var ext = input.getExtent();
      var inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw(ext[1] - ext[0] + 1, ext[3] - ext[2] + 1, inScalars.getNumberOfComponents(), inScalars.getDataType(), inScalars.getData());
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    var toString = "".concat(poly.getMTime(), "A").concat(representation, "B").concat(poly.getMTime()) + "C".concat(n ? n.getMTime() : 1, "D").concat(c ? c.getMTime() : 1) + "E".concat(actor.getProperty().getEdgeVisibility()) + "F".concat(tcoords ? tcoords.getMTime() : 1);
    if (model.VBOBuildString !== toString) {
      var points = poly.getPoints();
      var options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable.getCustomShaderAttributes().map(function(arrayName) {
          return poly.getPointData().getArrayByName(arrayName);
        })
      };
      options.cellOffset += model.primitives[primTypes.Points].getCABO().createVBO(poly.getVerts(), "verts", representation, options);
      options.cellOffset += model.primitives[primTypes.Lines].getCABO().createVBO(poly.getLines(), "lines", representation, options);
      options.cellOffset += model.primitives[primTypes.Tris].getCABO().createVBO(poly.getPolys(), "polys", representation, options);
      options.cellOffset += model.primitives[primTypes.TriStrips].getCABO().createVBO(poly.getStrips(), "strips", representation, options);
      var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation5.SURFACE;
      if (drawSurfaceWithEdges) {
        model.primitives[primTypes.TrisEdges].getCABO().createVBO(poly.getPolys(), "polys", Representation5.WIREFRAME, {
          points,
          normals: n,
          tcoords: null,
          colors: null,
          cellOffset: 0,
          haveCellScalars: false,
          haveCellNormals: false
        });
        model.primitives[primTypes.TriStripsEdges].getCABO().createVBO(poly.getStrips(), "strips", Representation5.WIREFRAME, {
          points,
          normals: n,
          tcoords: null,
          colors: null,
          cellOffset: 0,
          haveCellScalars: false,
          haveCellNormals: false
        });
      } else {
        model.primitives[primTypes.TrisEdges].releaseGraphicsResources(model._openGLRenderWindow);
        model.primitives[primTypes.TriStripsEdges].releaseGraphicsResources(model._openGLRenderWindow);
      }
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
}
function extend86(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES85, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes;
  model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  for (var i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper(publicAPI, model);
}
var primTypes, Representation5, Shading2, ScalarMode3, Filter3, Wrap3, vtkErrorMacro26, StartEvent, EndEvent, DEFAULT_VALUES85, newInstance86, vtkOpenGLPolyDataMapper$1;
var init_PolyDataMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js"() {
    init_toConsumableArray();
    init_esm();
    init_macros();
    init_Helper();
    init_Mapper();
    init_Math();
    init_Texture();
    init_Property();
    init_ShaderProgram();
    init_ViewNode();
    init_vtkPolyDataVS_glsl();
    init_vtkPolyDataFS_glsl();
    init_ReplacementShaderMapper();
    init_ViewNodeFactory2();
    primTypes = {
      Start: 0,
      Points: 0,
      Lines: 1,
      Tris: 2,
      TriStrips: 3,
      TrisEdges: 4,
      TriStripsEdges: 5,
      End: 6
    };
    Representation5 = vtkProperty$1.Representation;
    Shading2 = vtkProperty$1.Shading;
    ScalarMode3 = vtkMapper$1.ScalarMode;
    Filter3 = vtkOpenGLTexture$1.Filter;
    Wrap3 = vtkOpenGLTexture$1.Wrap;
    vtkErrorMacro26 = vtkErrorMacro;
    StartEvent = {
      type: "StartEvent"
    };
    EndEvent = {
      type: "EndEvent"
    };
    DEFAULT_VALUES85 = {
      context: null,
      VBOBuildTime: 0,
      VBOBuildString: null,
      primitives: null,
      primTypes: null,
      shaderRebuildString: null,
      tmpMat4: null,
      ambientColor: [],
      diffuseColor: [],
      specularColor: [],
      lightColor: [],
      lightHalfAngle: [],
      lightDirection: [],
      lastHaveSeenDepthRequest: false,
      haveSeenDepthRequest: false
    };
    newInstance86 = newInstance(extend86, "vtkOpenGLPolyDataMapper");
    vtkOpenGLPolyDataMapper$1 = {
      newInstance: newInstance86,
      extend: extend86,
      primTypes
    };
    registerOverride("vtkMapper", newInstance86);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js
var Glyph3DMapper_exports = {};
__export(Glyph3DMapper_exports, {
  default: () => vtkGlyph3DMapper,
  extend: () => extend87,
  newInstance: () => newInstance87
});
function ownKeys27(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread27(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys27(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys27(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLGlyph3DMapper");
  var superClass = _objectSpread27({}, publicAPI);
  publicAPI.renderPiece = function(ren, actor) {
    publicAPI.invokeEvent(StartEvent2);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent2);
    if (!model.currentInput) {
      vtkErrorMacro27("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    var gl = model.context;
    if (model._openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension("ANGLE_instanced_arrays");
      model.hardwareSupport = !!model.extension;
    }
    var backfaceCulling = actor.getProperty().getBackfaceCulling();
    var frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.multiply4x4WithOffset = function(out, a, b, off) {
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    var a30 = a[12];
    var a31 = a[13];
    var a32 = a[14];
    var a33 = a[15];
    var b0 = b[off];
    var b1 = b[off + 1];
    var b2 = b[off + 2];
    var b3 = b[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 4];
    b1 = b[off + 5];
    b2 = b[off + 6];
    b3 = b[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 8];
    b1 = b[off + 9];
    b2 = b[off + 10];
    b3 = b[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[off + 12];
    b1 = b[off + 13];
    b2 = b[off + 14];
    b3 = b[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  };
  publicAPI.replaceShaderNormal = function(shaders, ren, actor) {
    if (model.hardwareSupport) {
      var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        var VSSource = shaders.Vertex;
        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "attribute mat3 gNormal;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
          VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = function(shaders, ren, actor) {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      var VSSource = shaders.Vertex;
      var GSSource = shaders.Geometry;
      var FSSource = shaders.Fragment;
      var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      var colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity"];
      if (lastLightComplexity) {
        colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
      }
      var colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
      }
      colorImpl = colorImpl.concat(["  opacity = opacityUniform;"]);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
      }
      if (!model.drawingEdges) {
        colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 gColor;", "varying vec4 vertexColorVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput = gColor;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
        colorImpl = colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"]);
      }
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };
  publicAPI.replaceShaderPositionVC = function(shaders, ren, actor) {
    if (model.hardwareSupport) {
      var VSSource = shaders.Vertex;
      var lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (lastLightComplexity > 0) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "vertexVCVSOutput = MCVCMatrix * gVertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["attribute mat4 gMatrix;", "uniform mat4 MCPCMatrix;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vec4 gVertexMC = gMatrix * vertexMC;", "  gl_Position = MCPCMatrix * gVertexMC;"]).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderPicking = function(shaders, ren, actor) {
    if (model.hardwareSupport) {
      var FSSource = shaders.Fragment;
      var VSSource = shaders.Vertex;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["attribute vec3 mapperIndexVS;", "varying vec3 mapperIndexVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  mapperIndexVSOutput = mapperIndexVS;").result;
      shaders.Vertex = VSSource;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["varying vec3 mapperIndexVSOutput;", "uniform vec3 mapperIndex;", "uniform int picking;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);", "  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };
  publicAPI.updateGlyphShaderParameters = function(normalMatrixUsed, mcvcMatrixUsed, cellBO, carray, garray, narray, p, selector) {
    var program = cellBO.getProgram();
    if (normalMatrixUsed) {
      var a = model.normalMatrix;
      var b = narray;
      var ofs = p * 9;
      var out = model.tmpMat3;
      var a00 = a[0];
      var a01 = a[1];
      var a02 = a[2];
      var a10 = a[3];
      var a11 = a[4];
      var a12 = a[5];
      var a20 = a[6];
      var a21 = a[7];
      var a22 = a[8];
      var b00 = b[ofs];
      var b01 = b[ofs + 1];
      var b02 = b[ofs + 2];
      var b10 = b[ofs + 3];
      var b11 = b[ofs + 4];
      var b12 = b[ofs + 5];
      var b20 = b[ofs + 6];
      var b21 = b[ofs + 7];
      var b22 = b[ofs + 8];
      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;
      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;
      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;
      program.setUniformMatrix3x3("normalMatrix", model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcpcMatrix, garray, p * 16);
    program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(model.tmpMat4, model.mcvcMatrix, garray, p * 16);
      program.setUniformMatrix("MCVCMatrix", model.tmpMat4);
    }
    if (carray) {
      var cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255;
      program.setUniform3fArray("ambientColorUniform", model.tmpColor);
      program.setUniform3fArray("diffuseColorUniform", model.tmpColor);
    }
    if (selector) {
      program.setUniform3fArray("mapperIndex", selector.getPropColorValue());
    }
  };
  publicAPI.renderPieceDraw = function(ren, actor) {
    var representation = actor.getProperty().getRepresentation();
    var gl = model.context;
    var drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation6.SURFACE;
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    var actMats = model.openGLActor.getKeyMatrices();
    mat3_exports.multiply(model.normalMatrix, keyMats.normalMatrix, actMats.normalMatrix);
    mat4_exports.multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    mat4_exports.multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);
    var garray = model.renderable.getMatrixArray();
    var narray = model.renderable.getNormalArray();
    var carray = model.renderable.getColorArray();
    var numPts = garray.length / 16;
    var compositePass = false;
    if (model.openGLRenderer.getSelector()) {
      if (model.openGLRenderer.getSelector().getCurrentPass() === PassTypes3.COMPOSITE_INDEX_PASS) {
        compositePass = true;
      }
    }
    for (var i = model.primTypes.Start; i < model.primTypes.End; i++) {
      var cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === model.primTypes.TrisEdges || i === model.primTypes.TriStripsEdges);
        publicAPI.updateShaders(model.primitives[i], ren, actor);
        var program = model.primitives[i].getProgram();
        var mode = publicAPI.getOpenGLMode(representation, i);
        var normalMatrixUsed = program.isUniformUsed("normalMatrix");
        var mcvcMatrixUsed = program.isUniformUsed("MCVCMatrix");
        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(mode, 0, cabo.getElementCount(), numPts);
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          for (var p = 0; p < numPts; ++p) {
            if (compositePass) {
              model.openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(normalMatrixUsed, mcvcMatrixUsed, model.primitives[i], carray, garray, narray, p, compositePass ? model.openGLRenderer.getSelector() : null);
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.glyphBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("gMatrix")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.matrixBuffer, "gMatrix", 0, 64, model.context.FLOAT, 4, false, 1)) {
          vtkErrorMacro27("Error setting gMatrix in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gMatrix");
      }
      if (cellBO.getProgram().isAttributeUsed("gNormal")) {
        if (!cellBO.getVAO().addAttributeMatrixWithDivisor(cellBO.getProgram(), model.normalBuffer, "gNormal", 0, 36, model.context.FLOAT, 3, false, 1)) {
          vtkErrorMacro27("Error setting gNormal in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gNormal");
      }
      if (cellBO.getProgram().isAttributeUsed("gColor")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.colorBuffer, "gColor", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro27("Error setting gColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("gColor");
      }
      if (cellBO.getProgram().isAttributeUsed("mapperIndexVS")) {
        if (!cellBO.getVAO().addAttributeArrayWithDivisor(cellBO.getProgram(), model.pickBuffer, "mapperIndexVS", 0, 4, model.context.UNSIGNED_BYTE, 4, true, 1, false)) {
          vtkErrorMacro27("Error setting mapperIndexVS in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("mapperIndexVS");
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.getNeedToRebuildBufferObjects = function(ren, actor) {
    model.renderable.buildArrays();
    var vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    if (model.hardwareSupport) {
      var garray = model.renderable.getMatrixArray();
      var narray = model.renderable.getNormalArray();
      var carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = vtkBufferObject.newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.normalBuffer = vtkBufferObject.newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.colorBuffer = vtkBufferObject.newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
        model.pickBuffer = vtkBufferObject.newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model._openGLRenderWindow);
      }
      if (model.renderable.getBuildTime().getMTime() > model.glyphBOBuildTime.getMTime()) {
        model.matrixBuffer.upload(garray, ObjectType3.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType3.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType3.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        var numPts = garray.length / 16;
        var parray = new Uint8Array(4 * numPts);
        for (var i = 0; i < numPts; ++i) {
          var value = i + 1;
          var offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType3.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    return superClass.buildBufferObjects(ren, actor);
  };
}
function extend87(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES86, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model.normalMatrix = mat3_exports.identity(new Float64Array(9));
  model.mcpcMatrix = mat4_exports.identity(new Float64Array(16));
  model.mcvcMatrix = mat4_exports.identity(new Float64Array(16));
  model.tmpColor = [];
  model.glyphBOBuildTime = {};
  obj(model.glyphBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}
var vtkErrorMacro27, Representation6, ObjectType3, PassTypes3, StartEvent2, EndEvent2, DEFAULT_VALUES86, newInstance87, vtkGlyph3DMapper;
var init_Glyph3DMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper.js"() {
    init_defineProperty();
    init_esm();
    init_macros();
    init_BufferObject();
    init_HardwareSelector2();
    init_Property();
    init_PolyDataMapper();
    init_ShaderProgram();
    init_ViewNodeFactory2();
    vtkErrorMacro27 = vtkErrorMacro;
    Representation6 = vtkProperty$1.Representation;
    ObjectType3 = vtkBufferObject.ObjectType;
    PassTypes3 = vtkHardwareSelector2.PassTypes;
    StartEvent2 = {
      type: "StartEvent"
    };
    EndEvent2 = {
      type: "EndEvent"
    };
    DEFAULT_VALUES86 = {
      normalMatrix: null,
      mcpcMatrix: null,
      mcwcMatrix: null
    };
    newInstance87 = newInstance(extend87, "vtkOpenGLGlyph3DMapper");
    vtkGlyph3DMapper = {
      newInstance: newInstance87,
      extend: extend87
    };
    registerOverride("vtkGlyph3DMapper", newInstance87);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var Skybox_exports = {};
__export(Skybox_exports, {
  default: () => vtkSkybox,
  extend: () => extend88,
  newInstance: () => newInstance88
});
function vtkOpenGLSkybox(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSkybox");
  publicAPI.buildPass = function(prepass) {
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      var ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(ren.getActiveCamera());
    }
  };
  publicAPI.queryPass = function(prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = function(prepass, renderPass) {
    if (prepass && !model.openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      var texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi("sbtexture", texUnit);
      var ren = model.openGLRenderer.getRenderable();
      var keyMats = model.openGLCamera.getKeyMatrices(ren);
      var imat = new Float64Array(16);
      mat4_exports.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix("IMCPCMatrix", imat);
      if (model.lastFormat === "box") {
        var camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f("camPos", camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = function() {
    if (!model.tris.getCABO().getElementCount()) {
      var ptsArray = new Float32Array(12);
      for (var i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = 1;
      }
      var points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      var cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      var cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === "box") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }", "//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }", ""));
      }
      if (model.lastFormat === "background") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }", "//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }", ""));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), "vertexMC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro28("Error setting vertexMC in shader VAO.");
      }
    }
    var tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro28("vtkSkybox requires a texture map");
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}
function extend88(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES87, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.tris = vtkHelper.newInstance();
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLSkybox(publicAPI, model);
}
var vtkErrorMacro28, DEFAULT_VALUES87, newInstance88, vtkSkybox;
var init_Skybox = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js"() {
    init_esm();
    init_macros();
    init_DataArray();
    init_Helper();
    init_ViewNode();
    init_Texture();
    init_Constants9();
    init_ViewNodeFactory2();
    vtkErrorMacro28 = vtkErrorMacro;
    DEFAULT_VALUES87 = {
      context: null
    };
    newInstance88 = newInstance(extend88);
    vtkSkybox = {
      newInstance: newInstance88,
      extend: extend88
    };
    registerOverride("vtkSkybox", newInstance88);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js
var vtkSphereMapperVS;
var init_vtkSphereMapperVS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl.js"() {
    vtkSphereMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(offsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + offsetMC.x*base1 + offsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + offsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js
var SphereMapper_exports = {};
__export(SphereMapper_exports, {
  default: () => vtkSphereMapper,
  extend: () => extend89,
  newInstance: () => newInstance89
});
function ownKeys28(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread28(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys28(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys28(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkOpenGLSphereMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSphereMapper");
  var superClass = _objectSpread28({}, publicAPI);
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkSphereMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 VCPCMatrix;\n", "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;\n"]).result;
    var replacement = ["uniform float invertedDepth;\n", "uniform int cameraParallel;\n", "varying float radiusVCVSOutput;\n", "varying vec3 centerVCVSOutput;\n", "uniform mat4 VCPCMatrix;\n"];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    var fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = "gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = "gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      "  vec3 EyePos;\n",
      "  vec3 EyeDir;\n",
      "  if (cameraParallel != 0) {\n",
      "    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n",
      "    EyeDir = vec3(0.0,0.0,-1.0); }\n",
      "  else {\n",
      "    EyeDir = vertexVC.xyz;\n",
      "    EyePos = vec3(0.0,0.0,0.0);\n",
      "    float lengthED = length(EyeDir);\n",
      "    EyeDir = normalize(EyeDir);\n",
      "    if (lengthED > radiusVCVSOutput*3.0) {\n",
      "      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n",
      "    }\n",
      "  EyePos = EyePos - centerVCVSOutput;\n",
      "  EyePos = EyePos/radiusVCVSOutput;\n",
      "  float b = 2.0*dot(EyePos,EyeDir);\n",
      "  float c = dot(EyePos,EyePos) - 1.0;\n",
      "  float d = b*b - 4.0*c;\n",
      "  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n",
      "  if (d < 0.0) { discard; }\n",
      "  else {\n",
      "    float t = (-b - invertedDepth*sqrt(d))*0.5;\n",
      "    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n",
      "    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n",
      "    }\n",
      "  vec4 pos = VCPCMatrix * vertexVC;\n",
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime()) && cellBO.getProgram().isAttributeUsed("offsetMC")) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "offsetMC", 12, cellBO.getCABO().getStride(), model.context.FLOAT, 2, false)) {
        vtkErrorMacro29("Error setting 'offsetMC' in shader VAO.");
      }
    }
    if (cellBO.getProgram().isUniformUsed("invertedDepth")) {
      cellBO.getProgram().setUniformf("invertedDepth", model.invert ? -1 : 1);
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var cam = ren.getActiveCamera();
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      if (!actor.getIsIdentity()) {
        var actMats = model.openGLActor.getKeyMatrices();
        var tmp4 = new Float64Array(16);
        mat4_exports.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix("MCVCMatrix", tmp4);
      } else {
        program.setUniformMatrix("MCVCMatrix", keyMats.wcvc);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = function(rep, type) {
    return model.context.TRIANGLES;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    var c = model.renderable.getColorMapColors();
    var vbo = model.primitives[model.primTypes.Tris].getCABO();
    var pointData = poly.getPointData();
    var points = poly.getPoints();
    var numPoints2 = points.getNumberOfPoints();
    var pointArray = points.getData();
    var pointSize = 5;
    var scales = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    var colorData = null;
    var colorComponents = 0;
    var packedUCVBO = null;
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c.getData();
      packedUCVBO = new Uint8Array(3 * numPoints2 * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(vtkBufferObject.newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);
    var packedVBO = new Float32Array(pointSize * numPoints2 * 3);
    vbo.setStride(pointSize * 4);
    var cos30 = Math.cos(radiansFromDegrees(30));
    var pointIdx = 0;
    var colorIdx = 0;
    var vboIdx = 0;
    var ucIdx = 0;
    for (var i = 0; i < numPoints2; ++i) {
      var radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = -2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 2 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 0;
      packedVBO[vboIdx++] = 2 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (c) {
      vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    model.VBOBuildTime.modified();
  };
}
function extend89(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES88, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLSphereMapper(publicAPI, model);
}
var vtkErrorMacro29, DEFAULT_VALUES88, newInstance89, vtkSphereMapper;
var init_SphereMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/SphereMapper.js"() {
    init_defineProperty();
    init_esm();
    init_Constants8();
    init_macros();
    init_BufferObject();
    init_Math();
    init_ShaderProgram();
    init_PolyDataMapper();
    init_vtkSphereMapperVS_glsl();
    init_vtkPolyDataFS_glsl();
    init_ViewNodeFactory2();
    vtkErrorMacro29 = vtkErrorMacro;
    DEFAULT_VALUES88 = {};
    newInstance89 = newInstance(extend89, "vtkOpenGLSphereMapper");
    vtkSphereMapper = {
      newInstance: newInstance89,
      extend: extend89
    };
    registerOverride("vtkSphereMapper", newInstance89);
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js
var vtkStickMapperVS;
var init_vtkStickMapperVS_glsl = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl.js"() {
    vtkStickMapperVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n";
  }
});

// node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js
var StickMapper_exports = {};
__export(StickMapper_exports, {
  default: () => vtkStickMapper,
  extend: () => extend90,
  newInstance: () => newInstance90
});
function ownKeys29(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread29(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys29(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys29(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function vtkOpenGLStickMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLStickMapper");
  var superClass = _objectSpread29({}, publicAPI);
  publicAPI.getShaderTemplate = function(shaders, ren, actor) {
    shaders.Vertex = vtkStickMapperVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderValues = function(shaders, ren, actor) {
    var VSSource = shaders.Vertex;
    var FSSource = shaders.Fragment;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 VCPCMatrix;\n", "uniform mat4 MCVCMatrix;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", "varying vec4 vertexVCVSOutput;").result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", "  vec4 vertexVC = vertexVCVSOutput;\n").result;
    var replacement = ["uniform int cameraParallel;\n", "varying float radiusVCVSOutput;\n", "varying vec3 orientVCVSOutput;\n", "varying float lengthVCVSOutput;\n", "varying vec3 centerVCVSOutput;\n", "uniform mat4 VCPCMatrix;\n"];
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", replacement).result;
    var fragString = "";
    if (model.context.getExtension("EXT_frag_depth")) {
      fragString = "  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    if (model._openGLRenderWindow.getWebgl2()) {
      fragString = "gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n";
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", [
      "  vec3 EyePos;\n",
      "  vec3 EyeDir;\n",
      "  if (cameraParallel != 0) {\n",
      "    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n",
      "    EyeDir = vec3(0.0,0.0,-1.0); }\n",
      "  else {\n",
      "    EyeDir = vertexVC.xyz;\n",
      "    EyePos = vec3(0.0,0.0,0.0);\n",
      "    float lengthED = length(EyeDir);\n",
      "    EyeDir = normalize(EyeDir);\n",
      "    if (lengthED > radiusVCVSOutput*3.0) {\n",
      "      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n",
      "    }\n",
      "  EyePos = EyePos - centerVCVSOutput;\n",
      "  vec3 base1;\n",
      "  if (abs(orientVCVSOutput.z) < 0.99) {\n",
      "    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n",
      "  else {\n",
      "    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n",
      "  vec3 base2 = cross(orientVCVSOutput,base1);\n",
      "  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n",
      "  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n",
      "  EyePos = EyePos/radiusVCVSOutput;\n",
      "  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n",
      "  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n",
      "  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n",
      "  float d = b*b - 4.0*a*c;\n",
      "  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n",
      "  if (d < 0.0) { discard; }\n",
      "  else {\n",
      "    float t =  (-b - sqrt(d))/(2.0*a);\n",
      "    float tz = EyePos.z + t*EyeDir.z;\n",
      "    vec3 iPoint = EyePos + t*EyeDir;\n",
      "    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n",
      "      float t2 = (-b + sqrt(d))/(2.0*a);\n",
      "      float tz2 = EyePos.z + t2*EyeDir.z;\n",
      "      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n",
      "      else {\n",
      "        normalVCVSOutput = orientVCVSOutput;\n",
      "        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n",
      "        iPoint = EyePos + t3*EyeDir;\n",
      "        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n",
      "        }\n",
      "      }\n",
      "    else {\n",
      "      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n",
      "      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n",
      "      }\n",
      "    }\n",
      "  vec4 pos = VCPCMatrix * vertexVC;\n",
      fragString
    ]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", "").result;
    if (model.haveSeenDepthRequest) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float computedZ = (pos.z / pos.w + 1.0) / 2.0;", "float iz = floor(computedZ * 65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
    superClass.replaceShaderValues(shaders, ren, actor);
  };
  publicAPI.setMapperShaderParameters = function(cellBO, ren, actor) {
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      if (cellBO.getProgram().isAttributeUsed("orientMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "orientMC", 12, cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro30("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("offsetMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "offsetMC", 0, cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 3, true)) {
          vtkErrorMacro30("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("radiusMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "radiusMC", 24, cellBO.getCABO().getStride(), model.context.FLOAT, 1, false)) {
          vtkErrorMacro30("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }
    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };
  publicAPI.setCameraShaderParameters = function(cellBO, ren, actor) {
    var program = cellBO.getProgram();
    var cam = ren.getActiveCamera();
    var keyMats = model.openGLCamera.getKeyMatrices(ren);
    if (program.isUniformUsed("VCPCMatrix")) {
      program.setUniformMatrix("VCPCMatrix", keyMats.vcpc);
    }
    if (!actor.getIsIdentity()) {
      var actMats = model.openGLActor.getKeyMatrices();
      if (program.isUniformUsed("MCVCMatrix")) {
        var tmp4 = new Float64Array(16);
        mat4_exports.multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix("MCVCMatrix", tmp4);
      }
      if (program.isUniformUsed("normalMatrix")) {
        var anorms = new Float64Array(9);
        mat3_exports.multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3("normalMatrix", anorms);
      }
    } else {
      if (program.isUniformUsed("MCVCMatrix")) {
        program.setUniformMatrix("MCVCMatrix", keyMats.wcvc);
      }
      if (program.isUniformUsed("normalMatrix")) {
        program.setUniformMatrix3x3("normalMatrix", keyMats.normalMatrix);
      }
    }
    if (program.isUniformUsed("cameraParallel")) {
      cellBO.getProgram().setUniformi("cameraParallel", cam.getParallelProjection());
    }
  };
  publicAPI.getOpenGLMode = function(rep, type) {
    return model.context.TRIANGLES;
  };
  publicAPI.buildBufferObjects = function(ren, actor) {
    var poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    var c = model.renderable.getColorMapColors();
    var vbo = model.primitives[model.primTypes.Tris].getCABO();
    var pointData = poly.getPointData();
    var points = poly.getPoints();
    var numPoints2 = points.getNumberOfPoints();
    var pointArray = points.getData();
    var pointSize = 3;
    pointSize += 4;
    var colorData = null;
    var colorComponents = 0;
    vbo.setColorBOStride(4);
    if (!vbo.getColorBO()) {
      vbo.setColorBO(vtkBufferObject.newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model._openGLRenderWindow);
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);
    vbo.setStride(pointSize * 4);
    var packedVBO = new Float32Array(pointSize * numPoints2 * 12);
    var packedUCVBO = new Uint8Array(12 * numPoints2 * (colorData ? 8 : 4));
    var scales = null;
    var orientationArray = null;
    if (model.renderable.getScaleArray() != null && pointData.hasArray(model.renderable.getScaleArray())) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }
    if (model.renderable.getOrientationArray() != null && pointData.hasArray(model.renderable.getOrientationArray())) {
      orientationArray = pointData.getArray(model.renderable.getOrientationArray()).getData();
    } else {
      vtkErrorMacro30(["Error setting orientationArray.\n", "You have to specify the stick orientation"]);
    }
    var verticesArray = [0, 1, 3, 0, 3, 2, 2, 3, 5, 2, 5, 4];
    var pointIdx = 0;
    var colorIdx = 0;
    var vboIdx = 0;
    var ucIdx = 0;
    for (var i = 0; i < numPoints2; ++i) {
      var length = model.renderable.getLength();
      var radius = model.renderable.getRadius();
      if (scales) {
        length = scales[i * 2];
        radius = scales[i * 2 + 1];
      }
      for (var j = 0; j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = radius;
        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;
        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}
function extend90(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES89, initialValues);
  vtkOpenGLPolyDataMapper$1.extend(publicAPI, model, initialValues);
  vtkOpenGLStickMapper(publicAPI, model);
}
var vtkErrorMacro30, DEFAULT_VALUES89, newInstance90, vtkStickMapper;
var init_StickMapper = __esm({
  "node_modules/@kitware/vtk.js/Rendering/OpenGL/StickMapper.js"() {
    init_defineProperty();
    init_esm();
    init_Constants8();
    init_macros();
    init_BufferObject();
    init_vtkStickMapperVS_glsl();
    init_vtkPolyDataFS_glsl();
    init_ShaderProgram();
    init_PolyDataMapper();
    init_ViewNodeFactory2();
    vtkErrorMacro30 = vtkErrorMacro;
    DEFAULT_VALUES89 = {};
    newInstance90 = newInstance(extend90, "vtkOpenGLStickMapper");
    vtkStickMapper = {
      newInstance: newInstance90,
      extend: extend90
    };
    registerOverride("vtkStickMapper", newInstance90);
  }
});

// node_modules/@cornerstonejs/core/dist/umd/index.js
var require_umd = __commonJS({
  "node_modules/@cornerstonejs/core/dist/umd/index.js"(exports, module) {
    !function(e, t) {
      typeof exports == "object" && typeof module == "object" ? module.exports = t((init_Constants(), __toCommonJS(Constants_exports)), (init_esm(), __toCommonJS(esm_exports)), (init_macros(), __toCommonJS(macros_exports)), (init_Camera(), __toCommonJS(Camera_exports)), (init_Math2(), __toCommonJS(Math_exports)), (init_Volume(), __toCommonJS(Volume_exports)), (init_Volume4(), __toCommonJS(Volume_exports3)), (init_ImageData(), __toCommonJS(ImageData_exports)), (init_DataArray(), __toCommonJS(DataArray_exports)), (init_Texture(), __toCommonJS(Texture_exports)), (init_VolumeMapper2(), __toCommonJS(VolumeMapper_exports2)), (init_MatrixBuilder(), __toCommonJS(MatrixBuilder_exports)), (init_Renderer3(), __toCommonJS(Renderer_exports2)), (init_RenderWindow(), __toCommonJS(RenderWindow_exports)), (init_RenderWindowInteractor(), __toCommonJS(RenderWindowInteractor_exports)), (init_Points(), __toCommonJS(Points_exports)), (init_PolyData(), __toCommonJS(PolyData_exports)), (init_Actor(), __toCommonJS(Actor_exports)), (init_Mapper(), __toCommonJS(Mapper_exports)), (init_RenderWindow2(), __toCommonJS(RenderWindow_exports2)), (init_Actor2(), __toCommonJS(Actor_exports2)), (init_Actor2D(), __toCommonJS(Actor2D_exports)), (init_Camera2(), __toCommonJS(Camera_exports2)), (init_Glyph3DMapper(), __toCommonJS(Glyph3DMapper_exports)), (init_ImageMapper(), __toCommonJS(ImageMapper_exports)), (init_ImageSlice(), __toCommonJS(ImageSlice_exports)), (init_PixelSpaceCallbackMapper(), __toCommonJS(PixelSpaceCallbackMapper_exports)), (init_PolyDataMapper(), __toCommonJS(PolyDataMapper_exports)), (init_Renderer(), __toCommonJS(Renderer_exports)), (init_Skybox(), __toCommonJS(Skybox_exports)), (init_SphereMapper(), __toCommonJS(SphereMapper_exports)), (init_StickMapper(), __toCommonJS(StickMapper_exports)), (init_Volume2(), __toCommonJS(Volume_exports2)), (init_VolumeMapper(), __toCommonJS(VolumeMapper_exports)), (init_ViewNodeFactory(), __toCommonJS(ViewNodeFactory_exports)), (init_Constants10(), __toCommonJS(Constants_exports4)), (init_Constants2(), __toCommonJS(Constants_exports2)), (init_Constants9(), __toCommonJS(Constants_exports3))) : typeof define == "function" && define.amd ? define(["@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants", "gl-matrix", "@kitware/vtk.js/macros", "@kitware/vtk.js/Rendering/Core/Camera", "@kitware/vtk.js/Common/Core/Math", "@kitware/vtk.js/Rendering/Core/Volume", "@kitware/vtk.js/Rendering/Profiles/Volume", "@kitware/vtk.js/Common/DataModel/ImageData", "@kitware/vtk.js/Common/Core/DataArray", "@kitware/vtk.js/Rendering/OpenGL/Texture", "@kitware/vtk.js/Rendering/Core/VolumeMapper", "@kitware/vtk.js/Common/Core/MatrixBuilder", "@kitware/vtk.js/Rendering/Core/Renderer", "@kitware/vtk.js/Rendering/Core/RenderWindow", "@kitware/vtk.js/Rendering/Core/RenderWindowInteractor", "@kitware/vtk.js/Common/Core/Points", "@kitware/vtk.js/Common/DataModel/PolyData", "@kitware/vtk.js/Rendering/Core/Actor", "@kitware/vtk.js/Rendering/Core/Mapper", "@kitware/vtk.js/Rendering/OpenGL/RenderWindow", "@kitware/vtk.js/Rendering/OpenGL/Actor", "@kitware/vtk.js/Rendering/OpenGL/Actor2D", "@kitware/vtk.js/Rendering/OpenGL/Camera", "@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper", "@kitware/vtk.js/Rendering/OpenGL/ImageMapper", "@kitware/vtk.js/Rendering/OpenGL/ImageSlice", "@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper", "@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper", "@kitware/vtk.js/Rendering/OpenGL/Renderer", "@kitware/vtk.js/Rendering/OpenGL/Skybox", "@kitware/vtk.js/Rendering/OpenGL/SphereMapper", "@kitware/vtk.js/Rendering/OpenGL/StickMapper", "@kitware/vtk.js/Rendering/OpenGL/Volume", "@kitware/vtk.js/Rendering/OpenGL/VolumeMapper", "@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory", "@kitware/vtk.js/Rendering/OpenGL/Texture/Constants", "@kitware/vtk.js/Common/Core/DataArray/Constants", "@kitware/vtk.js/Rendering/Core/Property/Constants"], t) : typeof exports == "object" ? exports.cornerstone3D = t((init_Constants(), __toCommonJS(Constants_exports)), (init_esm(), __toCommonJS(esm_exports)), (init_macros(), __toCommonJS(macros_exports)), (init_Camera(), __toCommonJS(Camera_exports)), (init_Math2(), __toCommonJS(Math_exports)), (init_Volume(), __toCommonJS(Volume_exports)), (init_Volume4(), __toCommonJS(Volume_exports3)), (init_ImageData(), __toCommonJS(ImageData_exports)), (init_DataArray(), __toCommonJS(DataArray_exports)), (init_Texture(), __toCommonJS(Texture_exports)), (init_VolumeMapper2(), __toCommonJS(VolumeMapper_exports2)), (init_MatrixBuilder(), __toCommonJS(MatrixBuilder_exports)), (init_Renderer3(), __toCommonJS(Renderer_exports2)), (init_RenderWindow(), __toCommonJS(RenderWindow_exports)), (init_RenderWindowInteractor(), __toCommonJS(RenderWindowInteractor_exports)), (init_Points(), __toCommonJS(Points_exports)), (init_PolyData(), __toCommonJS(PolyData_exports)), (init_Actor(), __toCommonJS(Actor_exports)), (init_Mapper(), __toCommonJS(Mapper_exports)), (init_RenderWindow2(), __toCommonJS(RenderWindow_exports2)), (init_Actor2(), __toCommonJS(Actor_exports2)), (init_Actor2D(), __toCommonJS(Actor2D_exports)), (init_Camera2(), __toCommonJS(Camera_exports2)), (init_Glyph3DMapper(), __toCommonJS(Glyph3DMapper_exports)), (init_ImageMapper(), __toCommonJS(ImageMapper_exports)), (init_ImageSlice(), __toCommonJS(ImageSlice_exports)), (init_PixelSpaceCallbackMapper(), __toCommonJS(PixelSpaceCallbackMapper_exports)), (init_PolyDataMapper(), __toCommonJS(PolyDataMapper_exports)), (init_Renderer(), __toCommonJS(Renderer_exports)), (init_Skybox(), __toCommonJS(Skybox_exports)), (init_SphereMapper(), __toCommonJS(SphereMapper_exports)), (init_StickMapper(), __toCommonJS(StickMapper_exports)), (init_Volume2(), __toCommonJS(Volume_exports2)), (init_VolumeMapper(), __toCommonJS(VolumeMapper_exports)), (init_ViewNodeFactory(), __toCommonJS(ViewNodeFactory_exports)), (init_Constants10(), __toCommonJS(Constants_exports4)), (init_Constants2(), __toCommonJS(Constants_exports2)), (init_Constants9(), __toCommonJS(Constants_exports3))) : e.cornerstone3D = t(e["@kitware/vtk.js/Rendering/Core/VolumeMapper/Constants"], e.window, e["@kitware/vtk.js/macros"], e["@kitware/vtk.js/Rendering/Core/Camera"], e["@kitware/vtk.js/Common/Core/Math"], e["@kitware/vtk.js/Rendering/Core/Volume"], e["@kitware/vtk.js/Rendering/Profiles/Volume"], e["@kitware/vtk.js/Common/DataModel/ImageData"], e["@kitware/vtk.js/Common/Core/DataArray"], e["@kitware/vtk.js/Rendering/OpenGL/Texture"], e["@kitware/vtk.js/Rendering/Core/VolumeMapper"], e["@kitware/vtk.js/Common/Core/MatrixBuilder"], e["@kitware/vtk.js/Rendering/Core/Renderer"], e["@kitware/vtk.js/Rendering/Core/RenderWindow"], e["@kitware/vtk.js/Rendering/Core/RenderWindowInteractor"], e["@kitware/vtk.js/Common/Core/Points"], e["@kitware/vtk.js/Common/DataModel/PolyData"], e["@kitware/vtk.js/Rendering/Core/Actor"], e["@kitware/vtk.js/Rendering/Core/Mapper"], e["@kitware/vtk.js/Rendering/OpenGL/RenderWindow"], e["@kitware/vtk.js/Rendering/OpenGL/Actor"], e["@kitware/vtk.js/Rendering/OpenGL/Actor2D"], e["@kitware/vtk.js/Rendering/OpenGL/Camera"], e["@kitware/vtk.js/Rendering/OpenGL/Glyph3DMapper"], e["@kitware/vtk.js/Rendering/OpenGL/ImageMapper"], e["@kitware/vtk.js/Rendering/OpenGL/ImageSlice"], e["@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper"], e["@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper"], e["@kitware/vtk.js/Rendering/OpenGL/Renderer"], e["@kitware/vtk.js/Rendering/OpenGL/Skybox"], e["@kitware/vtk.js/Rendering/OpenGL/SphereMapper"], e["@kitware/vtk.js/Rendering/OpenGL/StickMapper"], e["@kitware/vtk.js/Rendering/OpenGL/Volume"], e["@kitware/vtk.js/Rendering/OpenGL/VolumeMapper"], e["@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory"], e["@kitware/vtk.js/Rendering/OpenGL/Texture/Constants"], e["@kitware/vtk.js/Common/Core/DataArray/Constants"], e["@kitware/vtk.js/Rendering/Core/Property/Constants"]);
    }(self, function(e, t, r, n, i, a, o, s, c, u, l, d, h, f, v, p, g, m, w, y, C, b, I, k, E, R, A, x, _, O, P, S, D, T, M, V, j, L) {
      return function() {
        var U = { 162: function(e2, t2, r2) {
          e2.exports = r2(47);
        }, 907: function(e2, t2, r2) {
          e2 = r2.nmd(e2);
          var n2 = "__lodash_hash_undefined__", i2 = 9007199254740991, a2 = "[object Arguments]", o2 = "[object Boolean]", s2 = "[object Date]", c2 = "[object Function]", u2 = "[object GeneratorFunction]", l2 = "[object Map]", d2 = "[object Number]", h2 = "[object Object]", f2 = "[object Promise]", v2 = "[object RegExp]", p2 = "[object Set]", g2 = "[object String]", m2 = "[object Symbol]", w2 = "[object WeakMap]", y2 = "[object ArrayBuffer]", C2 = "[object DataView]", b2 = "[object Float32Array]", I2 = "[object Float64Array]", k2 = "[object Int8Array]", E2 = "[object Int16Array]", R2 = "[object Int32Array]", A2 = "[object Uint8Array]", x2 = "[object Uint8ClampedArray]", _2 = "[object Uint16Array]", O2 = "[object Uint32Array]", P2 = /\w*$/, S2 = /^\[object .+?Constructor\]$/, D2 = /^(?:0|[1-9]\d*)$/, T2 = {};
          T2[a2] = T2["[object Array]"] = T2[y2] = T2[C2] = T2[o2] = T2[s2] = T2[b2] = T2[I2] = T2[k2] = T2[E2] = T2[R2] = T2[l2] = T2[d2] = T2[h2] = T2[v2] = T2[p2] = T2[g2] = T2[m2] = T2[A2] = T2[x2] = T2[_2] = T2[O2] = true, T2["[object Error]"] = T2[c2] = T2[w2] = false;
          var M2 = typeof r2.g == "object" && r2.g && r2.g.Object === Object && r2.g, V2 = typeof self == "object" && self && self.Object === Object && self, j2 = M2 || V2 || Function("return this")(), L2 = t2 && !t2.nodeType && t2, U2 = L2 && e2 && !e2.nodeType && e2, F2 = U2 && U2.exports === L2;
          function N2(e3, t3) {
            return e3.set(t3[0], t3[1]), e3;
          }
          function G2(e3, t3) {
            return e3.add(t3), e3;
          }
          function W(e3, t3, r3, n3) {
            var i3 = -1, a3 = e3 ? e3.length : 0;
            for (n3 && a3 && (r3 = e3[++i3]); ++i3 < a3; )
              r3 = t3(r3, e3[i3], i3, e3);
            return r3;
          }
          function q(e3) {
            var t3 = false;
            if (e3 != null && typeof e3.toString != "function")
              try {
                t3 = !!(e3 + "");
              } catch (e4) {
              }
            return t3;
          }
          function B(e3) {
            var t3 = -1, r3 = Array(e3.size);
            return e3.forEach(function(e4, n3) {
              r3[++t3] = [n3, e4];
            }), r3;
          }
          function z(e3, t3) {
            return function(r3) {
              return e3(t3(r3));
            };
          }
          function H(e3) {
            var t3 = -1, r3 = Array(e3.size);
            return e3.forEach(function(e4) {
              r3[++t3] = e4;
            }), r3;
          }
          var K, $ = Array.prototype, X = Function.prototype, Y = Object.prototype, Z = j2["__core-js_shared__"], J = (K = /[^.]+$/.exec(Z && Z.keys && Z.keys.IE_PROTO || "")) ? "Symbol(src)_1." + K : "", Q = X.toString, ee = Y.hasOwnProperty, te = Y.toString, re = RegExp("^" + Q.call(ee).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), ne = F2 ? j2.Buffer : void 0, ie = j2.Symbol, ae = j2.Uint8Array, oe = z(Object.getPrototypeOf, Object), se = Object.create, ce = Y.propertyIsEnumerable, ue = $.splice, le = Object.getOwnPropertySymbols, de = ne ? ne.isBuffer : void 0, he = z(Object.keys, Object), fe = je(j2, "DataView"), ve = je(j2, "Map"), pe = je(j2, "Promise"), ge = je(j2, "Set"), me = je(j2, "WeakMap"), we = je(Object, "create"), ye = Ge(fe), Ce = Ge(ve), be = Ge(pe), Ie = Ge(ge), ke = Ge(me), Ee = ie ? ie.prototype : void 0, Re = Ee ? Ee.valueOf : void 0;
          function Ae(e3) {
            var t3 = -1, r3 = e3 ? e3.length : 0;
            for (this.clear(); ++t3 < r3; ) {
              var n3 = e3[t3];
              this.set(n3[0], n3[1]);
            }
          }
          function xe(e3) {
            var t3 = -1, r3 = e3 ? e3.length : 0;
            for (this.clear(); ++t3 < r3; ) {
              var n3 = e3[t3];
              this.set(n3[0], n3[1]);
            }
          }
          function _e(e3) {
            var t3 = -1, r3 = e3 ? e3.length : 0;
            for (this.clear(); ++t3 < r3; ) {
              var n3 = e3[t3];
              this.set(n3[0], n3[1]);
            }
          }
          function Oe(e3) {
            this.__data__ = new xe(e3);
          }
          function Pe(e3, t3, r3) {
            var n3 = e3[t3];
            ee.call(e3, t3) && We(n3, r3) && (r3 !== void 0 || t3 in e3) || (e3[t3] = r3);
          }
          function Se(e3, t3) {
            for (var r3 = e3.length; r3--; )
              if (We(e3[r3][0], t3))
                return r3;
            return -1;
          }
          function De(e3, t3, r3, n3, i3, f3, w3) {
            var S3;
            if (n3 && (S3 = f3 ? n3(e3, i3, f3, w3) : n3(e3)), S3 !== void 0)
              return S3;
            if (!Ke(e3))
              return e3;
            var D3 = qe(e3);
            if (D3) {
              if (S3 = function(e4) {
                var t4 = e4.length, r4 = e4.constructor(t4);
                return t4 && typeof e4[0] == "string" && ee.call(e4, "index") && (r4.index = e4.index, r4.input = e4.input), r4;
              }(e3), !t3)
                return function(e4, t4) {
                  var r4 = -1, n4 = e4.length;
                  for (t4 || (t4 = Array(n4)); ++r4 < n4; )
                    t4[r4] = e4[r4];
                  return t4;
                }(e3, S3);
            } else {
              var M3 = Ue(e3), V3 = M3 == c2 || M3 == u2;
              if (ze(e3))
                return function(e4, t4) {
                  if (t4)
                    return e4.slice();
                  var r4 = new e4.constructor(e4.length);
                  return e4.copy(r4), r4;
                }(e3, t3);
              if (M3 == h2 || M3 == a2 || V3 && !f3) {
                if (q(e3))
                  return f3 ? e3 : {};
                if (S3 = function(e4) {
                  return typeof e4.constructor != "function" || Ne(e4) ? {} : Ke(t4 = oe(e4)) ? se(t4) : {};
                  var t4;
                }(V3 ? {} : e3), !t3)
                  return function(e4, t4) {
                    return Me(e4, Le(e4), t4);
                  }(e3, function(e4, t4) {
                    return e4 && Me(t4, $e(t4), e4);
                  }(S3, e3));
              } else {
                if (!T2[M3])
                  return f3 ? e3 : {};
                S3 = function(e4, t4, r4, n4) {
                  var i4, a3 = e4.constructor;
                  switch (t4) {
                    case y2:
                      return Te(e4);
                    case o2:
                    case s2:
                      return new a3(+e4);
                    case C2:
                      return function(e5, t5) {
                        var r5 = t5 ? Te(e5.buffer) : e5.buffer;
                        return new e5.constructor(r5, e5.byteOffset, e5.byteLength);
                      }(e4, n4);
                    case b2:
                    case I2:
                    case k2:
                    case E2:
                    case R2:
                    case A2:
                    case x2:
                    case _2:
                    case O2:
                      return function(e5, t5) {
                        var r5 = t5 ? Te(e5.buffer) : e5.buffer;
                        return new e5.constructor(r5, e5.byteOffset, e5.length);
                      }(e4, n4);
                    case l2:
                      return function(e5, t5, r5) {
                        return W(t5 ? r5(B(e5), true) : B(e5), N2, new e5.constructor());
                      }(e4, n4, r4);
                    case d2:
                    case g2:
                      return new a3(e4);
                    case v2:
                      return function(e5) {
                        var t5 = new e5.constructor(e5.source, P2.exec(e5));
                        return t5.lastIndex = e5.lastIndex, t5;
                      }(e4);
                    case p2:
                      return function(e5, t5, r5) {
                        return W(t5 ? r5(H(e5), true) : H(e5), G2, new e5.constructor());
                      }(e4, n4, r4);
                    case m2:
                      return i4 = e4, Re ? Object(Re.call(i4)) : {};
                  }
                }(e3, M3, De, t3);
              }
            }
            w3 || (w3 = new Oe());
            var j3 = w3.get(e3);
            if (j3)
              return j3;
            if (w3.set(e3, S3), !D3)
              var L3 = r3 ? function(e4) {
                return function(e5, t4, r4) {
                  var n4 = t4(e5);
                  return qe(e5) ? n4 : function(e6, t5) {
                    for (var r5 = -1, n5 = t5.length, i4 = e6.length; ++r5 < n5; )
                      e6[i4 + r5] = t5[r5];
                    return e6;
                  }(n4, r4(e5));
                }(e4, $e, Le);
              }(e3) : $e(e3);
            return function(e4, t4) {
              for (var r4 = -1, n4 = e4 ? e4.length : 0; ++r4 < n4 && t4(e4[r4], r4) !== false; )
                ;
            }(L3 || e3, function(i4, a3) {
              L3 && (i4 = e3[a3 = i4]), Pe(S3, a3, De(i4, t3, r3, n3, a3, e3, w3));
            }), S3;
          }
          function Te(e3) {
            var t3 = new e3.constructor(e3.byteLength);
            return new ae(t3).set(new ae(e3)), t3;
          }
          function Me(e3, t3, r3, n3) {
            r3 || (r3 = {});
            for (var i3 = -1, a3 = t3.length; ++i3 < a3; ) {
              var o3 = t3[i3], s3 = n3 ? n3(r3[o3], e3[o3], o3, r3, e3) : void 0;
              Pe(r3, o3, s3 === void 0 ? e3[o3] : s3);
            }
            return r3;
          }
          function Ve(e3, t3) {
            var r3, n3, i3 = e3.__data__;
            return ((n3 = typeof (r3 = t3)) == "string" || n3 == "number" || n3 == "symbol" || n3 == "boolean" ? r3 !== "__proto__" : r3 === null) ? i3[typeof t3 == "string" ? "string" : "hash"] : i3.map;
          }
          function je(e3, t3) {
            var r3 = function(e4, t4) {
              return e4 == null ? void 0 : e4[t4];
            }(e3, t3);
            return function(e4) {
              return !(!Ke(e4) || (t4 = e4, J && J in t4)) && (He(e4) || q(e4) ? re : S2).test(Ge(e4));
              var t4;
            }(r3) ? r3 : void 0;
          }
          Ae.prototype.clear = function() {
            this.__data__ = we ? we(null) : {};
          }, Ae.prototype.delete = function(e3) {
            return this.has(e3) && delete this.__data__[e3];
          }, Ae.prototype.get = function(e3) {
            var t3 = this.__data__;
            if (we) {
              var r3 = t3[e3];
              return r3 === n2 ? void 0 : r3;
            }
            return ee.call(t3, e3) ? t3[e3] : void 0;
          }, Ae.prototype.has = function(e3) {
            var t3 = this.__data__;
            return we ? t3[e3] !== void 0 : ee.call(t3, e3);
          }, Ae.prototype.set = function(e3, t3) {
            return this.__data__[e3] = we && t3 === void 0 ? n2 : t3, this;
          }, xe.prototype.clear = function() {
            this.__data__ = [];
          }, xe.prototype.delete = function(e3) {
            var t3 = this.__data__, r3 = Se(t3, e3);
            return !(r3 < 0 || (r3 == t3.length - 1 ? t3.pop() : ue.call(t3, r3, 1), 0));
          }, xe.prototype.get = function(e3) {
            var t3 = this.__data__, r3 = Se(t3, e3);
            return r3 < 0 ? void 0 : t3[r3][1];
          }, xe.prototype.has = function(e3) {
            return Se(this.__data__, e3) > -1;
          }, xe.prototype.set = function(e3, t3) {
            var r3 = this.__data__, n3 = Se(r3, e3);
            return n3 < 0 ? r3.push([e3, t3]) : r3[n3][1] = t3, this;
          }, _e.prototype.clear = function() {
            this.__data__ = { hash: new Ae(), map: new (ve || xe)(), string: new Ae() };
          }, _e.prototype.delete = function(e3) {
            return Ve(this, e3).delete(e3);
          }, _e.prototype.get = function(e3) {
            return Ve(this, e3).get(e3);
          }, _e.prototype.has = function(e3) {
            return Ve(this, e3).has(e3);
          }, _e.prototype.set = function(e3, t3) {
            return Ve(this, e3).set(e3, t3), this;
          }, Oe.prototype.clear = function() {
            this.__data__ = new xe();
          }, Oe.prototype.delete = function(e3) {
            return this.__data__.delete(e3);
          }, Oe.prototype.get = function(e3) {
            return this.__data__.get(e3);
          }, Oe.prototype.has = function(e3) {
            return this.__data__.has(e3);
          }, Oe.prototype.set = function(e3, t3) {
            var r3 = this.__data__;
            if (r3 instanceof xe) {
              var n3 = r3.__data__;
              if (!ve || n3.length < 199)
                return n3.push([e3, t3]), this;
              r3 = this.__data__ = new _e(n3);
            }
            return r3.set(e3, t3), this;
          };
          var Le = le ? z(le, Object) : function() {
            return [];
          }, Ue = function(e3) {
            return te.call(e3);
          };
          function Fe(e3, t3) {
            return !!(t3 = t3 == null ? i2 : t3) && (typeof e3 == "number" || D2.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t3;
          }
          function Ne(e3) {
            var t3 = e3 && e3.constructor;
            return e3 === (typeof t3 == "function" && t3.prototype || Y);
          }
          function Ge(e3) {
            if (e3 != null) {
              try {
                return Q.call(e3);
              } catch (e4) {
              }
              try {
                return e3 + "";
              } catch (e4) {
              }
            }
            return "";
          }
          function We(e3, t3) {
            return e3 === t3 || e3 != e3 && t3 != t3;
          }
          (fe && Ue(new fe(new ArrayBuffer(1))) != C2 || ve && Ue(new ve()) != l2 || pe && Ue(pe.resolve()) != f2 || ge && Ue(new ge()) != p2 || me && Ue(new me()) != w2) && (Ue = function(e3) {
            var t3 = te.call(e3), r3 = t3 == h2 ? e3.constructor : void 0, n3 = r3 ? Ge(r3) : void 0;
            if (n3)
              switch (n3) {
                case ye:
                  return C2;
                case Ce:
                  return l2;
                case be:
                  return f2;
                case Ie:
                  return p2;
                case ke:
                  return w2;
              }
            return t3;
          });
          var qe = Array.isArray;
          function Be(e3) {
            return e3 != null && function(e4) {
              return typeof e4 == "number" && e4 > -1 && e4 % 1 == 0 && e4 <= i2;
            }(e3.length) && !He(e3);
          }
          var ze = de || function() {
            return false;
          };
          function He(e3) {
            var t3 = Ke(e3) ? te.call(e3) : "";
            return t3 == c2 || t3 == u2;
          }
          function Ke(e3) {
            var t3 = typeof e3;
            return !!e3 && (t3 == "object" || t3 == "function");
          }
          function $e(e3) {
            return Be(e3) ? function(e4, t3) {
              var r3 = qe(e4) || function(e5) {
                return function(e6) {
                  return function(e7) {
                    return !!e7 && typeof e7 == "object";
                  }(e6) && Be(e6);
                }(e5) && ee.call(e5, "callee") && (!ce.call(e5, "callee") || te.call(e5) == a2);
              }(e4) ? function(e5, t4) {
                for (var r4 = -1, n4 = Array(e5); ++r4 < e5; )
                  n4[r4] = t4(r4);
                return n4;
              }(e4.length, String) : [], n3 = r3.length, i3 = !!n3;
              for (var o3 in e4)
                !t3 && !ee.call(e4, o3) || i3 && (o3 == "length" || Fe(o3, n3)) || r3.push(o3);
              return r3;
            }(e3) : function(e4) {
              if (!Ne(e4))
                return he(e4);
              var t3 = [];
              for (var r3 in Object(e4))
                ee.call(e4, r3) && r3 != "constructor" && t3.push(r3);
              return t3;
            }(e3);
          }
          e2.exports = function(e3) {
            return De(e3, true, true);
          };
        }, 47: function(e2) {
          var t2 = function(e3) {
            "use strict";
            var t3, r2 = Object.prototype, n2 = r2.hasOwnProperty, i2 = typeof Symbol == "function" ? Symbol : {}, a2 = i2.iterator || "@@iterator", o2 = i2.asyncIterator || "@@asyncIterator", s2 = i2.toStringTag || "@@toStringTag";
            function c2(e4, t4, r3) {
              return Object.defineProperty(e4, t4, { value: r3, enumerable: true, configurable: true, writable: true }), e4[t4];
            }
            try {
              c2({}, "");
            } catch (e4) {
              c2 = function(e5, t4, r3) {
                return e5[t4] = r3;
              };
            }
            function u2(e4, t4, r3, n3) {
              var i3 = t4 && t4.prototype instanceof g2 ? t4 : g2, a3 = Object.create(i3.prototype), o3 = new _2(n3 || []);
              return a3._invoke = function(e5, t5, r4) {
                var n4 = d2;
                return function(i4, a4) {
                  if (n4 === f2)
                    throw new Error("Generator is already running");
                  if (n4 === v2) {
                    if (i4 === "throw")
                      throw a4;
                    return P2();
                  }
                  for (r4.method = i4, r4.arg = a4; ; ) {
                    var o4 = r4.delegate;
                    if (o4) {
                      var s3 = R2(o4, r4);
                      if (s3) {
                        if (s3 === p2)
                          continue;
                        return s3;
                      }
                    }
                    if (r4.method === "next")
                      r4.sent = r4._sent = r4.arg;
                    else if (r4.method === "throw") {
                      if (n4 === d2)
                        throw n4 = v2, r4.arg;
                      r4.dispatchException(r4.arg);
                    } else
                      r4.method === "return" && r4.abrupt("return", r4.arg);
                    n4 = f2;
                    var c3 = l2(e5, t5, r4);
                    if (c3.type === "normal") {
                      if (n4 = r4.done ? v2 : h2, c3.arg === p2)
                        continue;
                      return { value: c3.arg, done: r4.done };
                    }
                    c3.type === "throw" && (n4 = v2, r4.method = "throw", r4.arg = c3.arg);
                  }
                };
              }(e4, r3, o3), a3;
            }
            function l2(e4, t4, r3) {
              try {
                return { type: "normal", arg: e4.call(t4, r3) };
              } catch (e5) {
                return { type: "throw", arg: e5 };
              }
            }
            e3.wrap = u2;
            var d2 = "suspendedStart", h2 = "suspendedYield", f2 = "executing", v2 = "completed", p2 = {};
            function g2() {
            }
            function m2() {
            }
            function w2() {
            }
            var y2 = {};
            c2(y2, a2, function() {
              return this;
            });
            var C2 = Object.getPrototypeOf, b2 = C2 && C2(C2(O2([])));
            b2 && b2 !== r2 && n2.call(b2, a2) && (y2 = b2);
            var I2 = w2.prototype = g2.prototype = Object.create(y2);
            function k2(e4) {
              ["next", "throw", "return"].forEach(function(t4) {
                c2(e4, t4, function(e5) {
                  return this._invoke(t4, e5);
                });
              });
            }
            function E2(e4, t4) {
              function r3(i4, a3, o3, s3) {
                var c3 = l2(e4[i4], e4, a3);
                if (c3.type !== "throw") {
                  var u3 = c3.arg, d3 = u3.value;
                  return d3 && typeof d3 == "object" && n2.call(d3, "__await") ? t4.resolve(d3.__await).then(function(e5) {
                    r3("next", e5, o3, s3);
                  }, function(e5) {
                    r3("throw", e5, o3, s3);
                  }) : t4.resolve(d3).then(function(e5) {
                    u3.value = e5, o3(u3);
                  }, function(e5) {
                    return r3("throw", e5, o3, s3);
                  });
                }
                s3(c3.arg);
              }
              var i3;
              this._invoke = function(e5, n3) {
                function a3() {
                  return new t4(function(t5, i4) {
                    r3(e5, n3, t5, i4);
                  });
                }
                return i3 = i3 ? i3.then(a3, a3) : a3();
              };
            }
            function R2(e4, r3) {
              var n3 = e4.iterator[r3.method];
              if (n3 === t3) {
                if (r3.delegate = null, r3.method === "throw") {
                  if (e4.iterator.return && (r3.method = "return", r3.arg = t3, R2(e4, r3), r3.method === "throw"))
                    return p2;
                  r3.method = "throw", r3.arg = new TypeError("The iterator does not provide a 'throw' method");
                }
                return p2;
              }
              var i3 = l2(n3, e4.iterator, r3.arg);
              if (i3.type === "throw")
                return r3.method = "throw", r3.arg = i3.arg, r3.delegate = null, p2;
              var a3 = i3.arg;
              return a3 ? a3.done ? (r3[e4.resultName] = a3.value, r3.next = e4.nextLoc, r3.method !== "return" && (r3.method = "next", r3.arg = t3), r3.delegate = null, p2) : a3 : (r3.method = "throw", r3.arg = new TypeError("iterator result is not an object"), r3.delegate = null, p2);
            }
            function A2(e4) {
              var t4 = { tryLoc: e4[0] };
              1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
            }
            function x2(e4) {
              var t4 = e4.completion || {};
              t4.type = "normal", delete t4.arg, e4.completion = t4;
            }
            function _2(e4) {
              this.tryEntries = [{ tryLoc: "root" }], e4.forEach(A2, this), this.reset(true);
            }
            function O2(e4) {
              if (e4) {
                var r3 = e4[a2];
                if (r3)
                  return r3.call(e4);
                if (typeof e4.next == "function")
                  return e4;
                if (!isNaN(e4.length)) {
                  var i3 = -1, o3 = function r4() {
                    for (; ++i3 < e4.length; )
                      if (n2.call(e4, i3))
                        return r4.value = e4[i3], r4.done = false, r4;
                    return r4.value = t3, r4.done = true, r4;
                  };
                  return o3.next = o3;
                }
              }
              return { next: P2 };
            }
            function P2() {
              return { value: t3, done: true };
            }
            return m2.prototype = w2, c2(I2, "constructor", w2), c2(w2, "constructor", m2), m2.displayName = c2(w2, s2, "GeneratorFunction"), e3.isGeneratorFunction = function(e4) {
              var t4 = typeof e4 == "function" && e4.constructor;
              return !!t4 && (t4 === m2 || (t4.displayName || t4.name) === "GeneratorFunction");
            }, e3.mark = function(e4) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(e4, w2) : (e4.__proto__ = w2, c2(e4, s2, "GeneratorFunction")), e4.prototype = Object.create(I2), e4;
            }, e3.awrap = function(e4) {
              return { __await: e4 };
            }, k2(E2.prototype), c2(E2.prototype, o2, function() {
              return this;
            }), e3.AsyncIterator = E2, e3.async = function(t4, r3, n3, i3, a3) {
              a3 === void 0 && (a3 = Promise);
              var o3 = new E2(u2(t4, r3, n3, i3), a3);
              return e3.isGeneratorFunction(r3) ? o3 : o3.next().then(function(e4) {
                return e4.done ? e4.value : o3.next();
              });
            }, k2(I2), c2(I2, s2, "Generator"), c2(I2, a2, function() {
              return this;
            }), c2(I2, "toString", function() {
              return "[object Generator]";
            }), e3.keys = function(e4) {
              var t4 = [];
              for (var r3 in e4)
                t4.push(r3);
              return t4.reverse(), function r4() {
                for (; t4.length; ) {
                  var n3 = t4.pop();
                  if (n3 in e4)
                    return r4.value = n3, r4.done = false, r4;
                }
                return r4.done = true, r4;
              };
            }, e3.values = O2, _2.prototype = { constructor: _2, reset: function(e4) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = t3, this.done = false, this.delegate = null, this.method = "next", this.arg = t3, this.tryEntries.forEach(x2), !e4)
                for (var r3 in this)
                  r3.charAt(0) === "t" && n2.call(this, r3) && !isNaN(+r3.slice(1)) && (this[r3] = t3);
            }, stop: function() {
              this.done = true;
              var e4 = this.tryEntries[0].completion;
              if (e4.type === "throw")
                throw e4.arg;
              return this.rval;
            }, dispatchException: function(e4) {
              if (this.done)
                throw e4;
              var r3 = this;
              function i3(n3, i4) {
                return s3.type = "throw", s3.arg = e4, r3.next = n3, i4 && (r3.method = "next", r3.arg = t3), !!i4;
              }
              for (var a3 = this.tryEntries.length - 1; a3 >= 0; --a3) {
                var o3 = this.tryEntries[a3], s3 = o3.completion;
                if (o3.tryLoc === "root")
                  return i3("end");
                if (o3.tryLoc <= this.prev) {
                  var c3 = n2.call(o3, "catchLoc"), u3 = n2.call(o3, "finallyLoc");
                  if (c3 && u3) {
                    if (this.prev < o3.catchLoc)
                      return i3(o3.catchLoc, true);
                    if (this.prev < o3.finallyLoc)
                      return i3(o3.finallyLoc);
                  } else if (c3) {
                    if (this.prev < o3.catchLoc)
                      return i3(o3.catchLoc, true);
                  } else {
                    if (!u3)
                      throw new Error("try statement without catch or finally");
                    if (this.prev < o3.finallyLoc)
                      return i3(o3.finallyLoc);
                  }
                }
              }
            }, abrupt: function(e4, t4) {
              for (var r3 = this.tryEntries.length - 1; r3 >= 0; --r3) {
                var i3 = this.tryEntries[r3];
                if (i3.tryLoc <= this.prev && n2.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
                  var a3 = i3;
                  break;
                }
              }
              a3 && (e4 === "break" || e4 === "continue") && a3.tryLoc <= t4 && t4 <= a3.finallyLoc && (a3 = null);
              var o3 = a3 ? a3.completion : {};
              return o3.type = e4, o3.arg = t4, a3 ? (this.method = "next", this.next = a3.finallyLoc, p2) : this.complete(o3);
            }, complete: function(e4, t4) {
              if (e4.type === "throw")
                throw e4.arg;
              return e4.type === "break" || e4.type === "continue" ? this.next = e4.arg : e4.type === "return" ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : e4.type === "normal" && t4 && (this.next = t4), p2;
            }, finish: function(e4) {
              for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
                var r3 = this.tryEntries[t4];
                if (r3.finallyLoc === e4)
                  return this.complete(r3.completion, r3.afterLoc), x2(r3), p2;
              }
            }, catch: function(e4) {
              for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
                var r3 = this.tryEntries[t4];
                if (r3.tryLoc === e4) {
                  var n3 = r3.completion;
                  if (n3.type === "throw") {
                    var i3 = n3.arg;
                    x2(r3);
                  }
                  return i3;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(e4, r3, n3) {
              return this.delegate = { iterator: O2(e4), resultName: r3, nextLoc: n3 }, this.method === "next" && (this.arg = t3), p2;
            } }, e3;
          }(e2.exports);
          try {
            regeneratorRuntime = t2;
          } catch (e3) {
            typeof globalThis == "object" ? globalThis.regeneratorRuntime = t2 : Function("r", "regeneratorRuntime = r")(t2);
          }
        }, 785: function(e2) {
          "use strict";
          e2.exports = c;
        }, 948: function(e2) {
          "use strict";
          e2.exports = j;
        }, 807: function(e2) {
          "use strict";
          e2.exports = i;
        }, 847: function(e2) {
          "use strict";
          e2.exports = d;
        }, 348: function(e2) {
          "use strict";
          e2.exports = p;
        }, 283: function(e2) {
          "use strict";
          e2.exports = s;
        }, 70: function(e2) {
          "use strict";
          e2.exports = g;
        }, 474: function(e2) {
          "use strict";
          e2.exports = m;
        }, 821: function(e2) {
          "use strict";
          e2.exports = n;
        }, 610: function(e2) {
          "use strict";
          e2.exports = w;
        }, 478: function(e2) {
          "use strict";
          e2.exports = L;
        }, 329: function(e2) {
          "use strict";
          e2.exports = f;
        }, 673: function(e2) {
          "use strict";
          e2.exports = v;
        }, 281: function(e2) {
          "use strict";
          e2.exports = h;
        }, 739: function(e2) {
          "use strict";
          e2.exports = a;
        }, 9: function(e2) {
          "use strict";
          e2.exports = l;
        }, 468: function(t2) {
          "use strict";
          t2.exports = e;
        }, 643: function(e2) {
          "use strict";
          e2.exports = C;
        }, 128: function(e2) {
          "use strict";
          e2.exports = b;
        }, 664: function(e2) {
          "use strict";
          e2.exports = I;
        }, 973: function(e2) {
          "use strict";
          e2.exports = k;
        }, 394: function(e2) {
          "use strict";
          e2.exports = E;
        }, 582: function(e2) {
          "use strict";
          e2.exports = R;
        }, 482: function(e2) {
          "use strict";
          e2.exports = A;
        }, 343: function(e2) {
          "use strict";
          e2.exports = x;
        }, 21: function(e2) {
          "use strict";
          e2.exports = y;
        }, 363: function(e2) {
          "use strict";
          e2.exports = _;
        }, 982: function(e2) {
          "use strict";
          e2.exports = O;
        }, 130: function(e2) {
          "use strict";
          e2.exports = P;
        }, 298: function(e2) {
          "use strict";
          e2.exports = S;
        }, 953: function(e2) {
          "use strict";
          e2.exports = u;
        }, 395: function(e2) {
          "use strict";
          e2.exports = V;
        }, 398: function(e2) {
          "use strict";
          e2.exports = D;
        }, 388: function(e2) {
          "use strict";
          e2.exports = T;
        }, 215: function(e2) {
          "use strict";
          e2.exports = o;
        }, 120: function(e2) {
          "use strict";
          e2.exports = M;
        }, 197: function(e2) {
          "use strict";
          e2.exports = r;
        }, 976: function(e2) {
          "use strict";
          e2.exports = t;
        } }, F = {};
        function N(e2) {
          var t2 = F[e2];
          if (t2 !== void 0)
            return t2.exports;
          var r2 = F[e2] = { id: e2, loaded: false, exports: {} };
          return U[e2](r2, r2.exports, N), r2.loaded = true, r2.exports;
        }
        N.n = function(e2) {
          var t2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return N.d(t2, { a: t2 }), t2;
        }, N.d = function(e2, t2) {
          for (var r2 in t2)
            N.o(t2, r2) && !N.o(e2, r2) && Object.defineProperty(e2, r2, { enumerable: true, get: t2[r2] });
        }, N.g = function() {
          if (typeof globalThis == "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e2) {
            if (typeof window == "object")
              return window;
          }
        }(), N.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, N.r = function(e2) {
          typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, N.nmd = function(e2) {
          return e2.paths = [], e2.children || (e2.children = []), e2;
        };
        var G = {};
        return function() {
          "use strict";
          N.r(G), N.d(G, { CONSTANTS: function() {
            return Gi;
          }, EVENTS: function() {
            return c2;
          }, Enums: function() {
            return Ni;
          }, ImageVolume: function() {
            return H;
          }, RenderingEngine: function() {
            return ni;
          }, Settings: function() {
            return fi;
          }, StackViewport: function() {
            return Hn;
          }, Viewport: function() {
            return rr;
          }, VolumeViewport: function() {
            return Pr;
          }, addVolumesToViewports: function() {
            return Fi;
          }, cache: function() {
            return zt;
          }, createVolumeActor: function() {
            return Ce;
          }, createVolumeMapper: function() {
            return we;
          }, eventTarget: function() {
            return $;
          }, getEnabledElement: function() {
            return si;
          }, getEnabledElementByIds: function() {
            return ci;
          }, getOrCreateCanvas: function() {
            return ke;
          }, getRenderingEngine: function() {
            return Qn;
          }, getRenderingEngines: function() {
            return ei;
          }, getShouldUseCPURendering: function() {
            return xr;
          }, imageLoadPoolManager: function() {
            return wn;
          }, imageLoader: function() {
            return i2;
          }, imageRetrievalPoolManager: function() {
            return ai;
          }, init: function() {
            return kr;
          }, isCornerstoneInitialized: function() {
            return _r;
          }, metaData: function() {
            return r2;
          }, registerImageLoader: function() {
            return xn;
          }, renderToCanvas: function() {
            return ri;
          }, requestPoolManager: function() {
            return wn;
          }, resetUseCPURendering: function() {
            return Ar;
          }, setMaxSimultaneousRequests: function() {
            return oi;
          }, setUseCPURendering: function() {
            return Rr;
          }, setVolumesForViewports: function() {
            return Li;
          }, triggerEvent: function() {
            return X;
          }, utilities: function() {
            return o2;
          }, volumeLoader: function() {
            return e2;
          } });
          var e2 = {};
          N.r(e2), N.d(e2, { createAndCacheDerivedVolume: function() {
            return ce;
          }, createAndCacheVolume: function() {
            return oe;
          }, createLocalVolume: function() {
            return ue;
          }, loadVolume: function() {
            return ae;
          }, registerUnknownVolumeLoader: function() {
            return de;
          }, registerVolumeLoader: function() {
            return le;
          } });
          var t2 = {};
          N.r(t2), N.d(t2, { linePlaneIntersection: function() {
            return Zt;
          }, planeEquation: function() {
            return Jt;
          }, threePlaneIntersection: function() {
            return Qt;
          } });
          var r2 = {};
          N.r(r2), N.d(r2, { addProvider: function() {
            return Dr;
          }, get: function() {
            return Vr;
          }, removeAllProviders: function() {
            return Mr;
          }, removeProvider: function() {
            return Tr;
          } });
          var n2 = {};
          N.r(n2), N.d(n2, { toLowHighRange: function() {
            return Ur;
          }, toWindowLevel: function() {
            return Lr;
          } });
          var i2 = {};
          N.r(i2), N.d(i2, { cancelLoadAll: function() {
            return An;
          }, cancelLoadImage: function() {
            return En;
          }, cancelLoadImages: function() {
            return Rn;
          }, loadAndCacheImage: function() {
            return In;
          }, loadAndCacheImages: function() {
            return kn;
          }, loadImage: function() {
            return bn;
          }, registerImageLoader: function() {
            return xn;
          }, registerUnknownImageLoader: function() {
            return _n;
          }, unregisterAllImageLoaders: function() {
            return On;
          } });
          var a2, o2 = {};
          N.r(o2), N.d(o2, { calibratedPixelSpacingMetadataProvider: function() {
            return Ei;
          }, createFloat32SharedArray: function() {
            return xi;
          }, createUint8SharedArray: function() {
            return Ai;
          }, getClosestImageId: function() {
            return Oi;
          }, getMinMax: function() {
            return yi;
          }, getRuntimeId: function() {
            return Ii;
          }, getSpacingInNormalDirection: function() {
            return _i;
          }, getTargetVolumeAndSpacingInNormalDir: function() {
            return Pi3;
          }, getVolumeActorCorners: function() {
            return Si;
          }, getVolumeViewportsContainingSameVolumes: function() {
            return Mi;
          }, getVolumeViewportsContainingVolumeId: function() {
            return Vi;
          }, imageIdToURI: function() {
            return Y;
          }, indexWithinDimensions: function() {
            return Di;
          }, invertRgbTransferFunction: function() {
            return jr;
          }, isEqual: function() {
            return Fr;
          }, isOpposite: function() {
            return Ri;
          }, planar: function() {
            return t2;
          }, scaleRgbTransferFunction: function() {
            return wi;
          }, triggerEvent: function() {
            return X;
          }, uuidv4: function() {
            return ee;
          }, windowLevel: function() {
            return n2;
          } }), function(e3) {
            e3.CACHE_SIZE_EXCEEDED = "CACHE_SIZE_EXCEEDED", e3.IMAGE_LOAD_ERROR = "IMAGE_LOAD_ERROR", e3.CAMERA_MODIFIED = "CORNERSTONE_CAMERA_MODIFIED", e3.VOI_MODIFIED = "CORNERSTONE_VOI_MODIFIED", e3.ELEMENT_DISABLED = "CORNERSTONE_ELEMENT_DISABLED", e3.ELEMENT_ENABLED = "CORNERSTONE_ELEMENT_ENABLED", e3.IMAGE_RENDERED = "CORNERSTONE_IMAGE_RENDERED", e3.IMAGE_VOLUME_MODIFIED = "CORNERSTONE_IMAGE_VOLUME_MODIFIED", e3.IMAGE_LOADED = "CORNERSTONE_IMAGE_LOADED", e3.IMAGE_LOAD_FAILED = "CORNERSTONE_IMAGE_LOAD_FAILED", e3.VOLUME_LOADED = "CORNERSTONE_VOLUME_LOADED", e3.VOLUME_LOADED_FAILED = "CORNERSTONE_VOLUME_LOADED_FAILED", e3.IMAGE_CACHE_IMAGE_ADDED = "CORNERSTONE_IMAGE_CACHE_IMAGE_ADDED", e3.IMAGE_CACHE_IMAGE_REMOVED = "CORNERSTONE_IMAGE_CACHE_IMAGE_REMOVED", e3.VOLUME_CACHE_VOLUME_ADDED = "CORNERSTONE_VOLUME_CACHE_VOLUME_ADDED", e3.VOLUME_CACHE_VOLUME_REMOVED = "CORNERSTONE_VOLUME_CACHE_VOLUME_REMOVED", e3.STACK_NEW_IMAGE = "CORNERSTONE_STACK_NEW_IMAGE", e3.IMAGE_SPACING_CALIBRATED = "CORNERSTONE_IMAGE_SPACING_CALIBRATED", e3.IMAGE_LOAD_PROGRESS = "CORNERSTONE_IMAGE_LOAD_PROGRESS";
          }(a2 || (a2 = {}));
          var s2, c2 = a2;
          !function(e3) {
            e3.Interaction = "interaction", e3.Thumbnail = "thumbnail", e3.Prefetch = "prefetch";
          }(s2 || (s2 = {}));
          var u2, l2 = s2;
          !function(e3) {
            e3.STACK = "stack", e3.ORTHOGRAPHIC = "orthographic", e3.PERSPECTIVE = "perspective";
          }(u2 || (u2 = {}));
          var d2, h2 = u2;
          !function(e3) {
            e3[e3.NEAREST = 0] = "NEAREST", e3[e3.LINEAR = 1] = "LINEAR", e3[e3.FAST_LINEAR = 2] = "FAST_LINEAR";
          }(d2 || (d2 = {}));
          var f2, v2 = d2, p2 = N(468), g2 = N.n(p2)().BlendMode;
          !function(e3) {
            e3[e3.COMPOSITE = g2.COMPOSITE] = "COMPOSITE", e3[e3.MAXIMUM_INTENSITY_BLEND = g2.MAXIMUM_INTENSITY_BLEND] = "MAXIMUM_INTENSITY_BLEND", e3[e3.MINIMUM_INTENSITY_BLEND = g2.MINIMUM_INTENSITY_BLEND] = "MINIMUM_INTENSITY_BLEND", e3[e3.AVERAGE_INTENSITY_BLEND = g2.AVERAGE_INTENSITY_BLEND] = "AVERAGE_INTENSITY_BLEND";
          }(f2 || (f2 = {}));
          var m2 = f2, w2 = { AXIAL: { sliceNormal: [0, 0, -1], viewUp: [0, -1, 0] }, SAGITTAL: { sliceNormal: [1, 0, 0], viewUp: [0, 0, 1] }, CORONAL: { sliceNormal: [0, 1, 0], viewUp: [0, 0, 1] } };
          Object.freeze(w2);
          var y2 = w2;
          function C2(e3, t3, r3, n3, i3, a3, o3) {
            try {
              var s3 = e3[a3](o3), c3 = s3.value;
            } catch (e4) {
              return void r3(e4);
            }
            s3.done ? t3(c3) : Promise.resolve(c3).then(n3, i3);
          }
          function b2(e3) {
            return function() {
              var t3 = this, r3 = arguments;
              return new Promise(function(n3, i3) {
                var a3 = e3.apply(t3, r3);
                function o3(e4) {
                  C2(a3, n3, i3, o3, s3, "next", e4);
                }
                function s3(e4) {
                  C2(a3, n3, i3, o3, s3, "throw", e4);
                }
                o3(void 0);
              });
            };
          }
          var I2 = N(162), k2 = N.n(I2), E2 = N(739), R2 = N.n(E2), A2 = (N(215), N(283)), x2 = N.n(A2), _2 = N(785), O2 = N.n(_2), P2 = N(907), S2 = N.n(P2);
          function D2(e3, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n3 = t3[r3];
              n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e3, n3.key, n3);
            }
          }
          function T2(e3, t3, r3) {
            return t3 && D2(e3.prototype, t3), r3 && D2(e3, r3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
          }
          function M2(e3, t3) {
            if (!(e3 instanceof t3))
              throw new TypeError("Cannot call a class as a function");
          }
          function V2(e3, t3, r3) {
            return t3 in e3 ? Object.defineProperty(e3, t3, { value: r3, enumerable: true, configurable: true, writable: true }) : e3[t3] = r3, e3;
          }
          var j2 = N(197), L2 = N.n(j2), U2 = N(953), F2 = N.n(U2);
          function W(e3, t3) {
            t3.classHierarchy.push("vtkStreamingOpenGLTexture");
            var r3 = e3.create3DFilterableFromRaw;
            e3.create3DFilterableFromRaw = function(e4, n3, i3, a3, o3, s3) {
              t3.inputDataType = o3, t3.inputNumComps = a3, r3(e4, n3, i3, a3, o3, s3);
            }, e3.update3DFromRaw = function(r4) {
              var n3 = t3.updatedFrames;
              if (n3.length) {
                var i3, a3;
                if (t3._openGLRenderWindow.activateTexture(e3), e3.createTexture(), e3.bind(), r4 instanceof Uint8Array)
                  i3 = 1, a3 = Uint8Array;
                else if (r4 instanceof Int16Array)
                  i3 = 2, a3 = Int16Array;
                else {
                  if (!(r4 instanceof Float32Array))
                    throw new Error("No support for given TypedArray.");
                  i3 = 4, a3 = Float32Array;
                }
                for (var o3 = 0; o3 < n3.length; o3++)
                  n3[o3] && t3.fillSubImage3D(r4, o3, i3, a3);
                return t3.updatedFrames = [], t3.generateMipmap && t3.context.generateMipmap(t3.target), e3.deactivate(), true;
              }
            }, t3.fillSubImage3D = function(e4, r4, n3, i3) {
              for (var a3 = e4.buffer, o3 = r4 * (t3.width * t3.height * t3.components * n3), s3 = t3.width * t3.components, c3 = t3.context, u3 = c3.getParameter(c3.MAX_TEXTURE_SIZE), l3 = Math.floor(n3 * u3 / t3.width), d3 = s3 * (l3 = Math.min(l3, t3.height)), h3 = d3 * n3, f3 = Math.floor(t3.height / l3), v3 = t3.height % l3, p3 = s3 * v3, g3 = 0; g3 < f3; g3++) {
                var m3 = g3 * l3, w3 = new i3(a3, o3 + g3 * h3, d3);
                c3.texSubImage3D(t3.target, 0, 0, m3, r4, t3.width, l3, 1, t3.format, t3.openGLDataType, w3);
              }
              if (v3 !== 0) {
                var y3 = f3 * l3, C3 = new i3(a3, o3 + f3 * h3, p3);
                c3.texSubImage3D(t3.target, 0, 0, y3, r4, t3.width, v3, 1, t3.format, t3.openGLDataType, C3);
              }
            }, e3.getTextureParameters = function() {
              return { width: t3.width, height: t3.height, depth: t3.depth, numComps: t3.inputNumComps, dataType: t3.inputDataType };
            }, e3.setUpdatedFrame = function(e4) {
              t3.updatedFrames[e4] = true;
            };
          }
          var q = { updatedFrames: [] };
          function B(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, q, r3), F2().extend(e3, t3, r3), W(e3, t3);
          }
          var z = { newInstance: L2().newInstance(B, "vtkStreamingOpenGLTexture"), extend: B }, H = T2(function e3(t3) {
            M2(this, e3), V2(this, "volumeId", void 0), V2(this, "dimensions", void 0), V2(this, "direction", void 0), V2(this, "metadata", void 0), V2(this, "origin", void 0), V2(this, "scalarData", void 0), V2(this, "scaling", void 0), V2(this, "sizeInBytes", void 0), V2(this, "spacing", void 0), V2(this, "numVoxels", void 0), V2(this, "imageData", void 0), V2(this, "vtkOpenGLTexture", void 0), V2(this, "loadStatus", void 0), V2(this, "imageIds", void 0), V2(this, "referencedVolumeId", void 0), this.volumeId = t3.volumeId, this.metadata = t3.metadata, this.dimensions = t3.dimensions, this.spacing = t3.spacing, this.origin = t3.origin, this.direction = t3.direction, this.imageData = t3.imageData, this.scalarData = t3.scalarData, this.sizeInBytes = t3.sizeInBytes, this.vtkOpenGLTexture = z.newInstance(), this.numVoxels = this.dimensions[0] * this.dimensions[1] * this.dimensions[2], t3.scaling && (this.scaling = t3.scaling), t3.referencedVolumeId && (this.referencedVolumeId = t3.referencedVolumeId);
          }), K = function() {
            function e3() {
              M2(this, e3), V2(this, "listeners", void 0), this.listeners = {};
            }
            return T2(e3, [{ key: "reset", value: function() {
              this.listeners = {};
            } }, { key: "addEventListener", value: function(e4, t3) {
              this.listeners[e4] || (this.listeners[e4] = []), this.listeners[e4].push(t3);
            } }, { key: "removeEventListener", value: function(e4, t3) {
              if (this.listeners[e4]) {
                for (var r3 = this.listeners[e4], n3 = r3.length, i3 = 0; i3 < n3; i3++)
                  if (r3[i3] === t3)
                    return void r3.splice(i3, 1);
              }
            } }, { key: "dispatchEvent", value: function(e4) {
              if (this.listeners[e4.type]) {
                for (var t3 = this.listeners[e4.type].slice(), r3 = t3.length, n3 = 0; n3 < r3; n3++)
                  t3[n3].call(this, e4);
                return !e4.defaultPrevented;
              }
            } }]), e3;
          }(), $ = new K();
          function X() {
            var e3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $, t3 = arguments.length > 1 ? arguments[1] : void 0, r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!t3)
              throw new Error("Event type was not defined");
            var n3 = new CustomEvent(t3, { detail: r3, cancelable: true });
            return e3.dispatchEvent(n3);
          }
          function Y(e3) {
            var t3 = e3.indexOf(":");
            return e3.substring(t3 + 1);
          }
          function Z(e3, t3) {
            var r3 = typeof Symbol != "undefined" && e3[Symbol.iterator] || e3["@@iterator"];
            if (!r3) {
              if (Array.isArray(e3) || (r3 = function(e4, t4) {
                if (e4) {
                  if (typeof e4 == "string")
                    return J(e4, t4);
                  var r4 = Object.prototype.toString.call(e4).slice(8, -1);
                  return r4 === "Object" && e4.constructor && (r4 = e4.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(e4) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? J(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && typeof e3.length == "number") {
                r3 && (e3 = r3);
                var n3 = 0, i3 = function() {
                };
                return { s: i3, n: function() {
                  return n3 >= e3.length ? { done: true } : { done: false, value: e3[n3++] };
                }, e: function(e4) {
                  throw e4;
                }, f: i3 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a3, o3 = true, s3 = false;
            return { s: function() {
              r3 = r3.call(e3);
            }, n: function() {
              var e4 = r3.next();
              return o3 = e4.done, e4;
            }, e: function(e4) {
              s3 = true, a3 = e4;
            }, f: function() {
              try {
                o3 || r3.return == null || r3.return();
              } finally {
                if (s3)
                  throw a3;
              }
            } };
          }
          function J(e3, t3) {
            (t3 == null || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++)
              n3[r3] = e3[r3];
            return n3;
          }
          var Q = new (function() {
            function e3() {
              var t3 = this;
              M2(this, e3), V2(this, "_imageCache", void 0), V2(this, "_volumeCache", void 0), V2(this, "_imageCacheSize", void 0), V2(this, "_volumeCacheSize", void 0), V2(this, "_maxCacheSize", void 0), V2(this, "setMaxCacheSize", function(e4) {
                if (!e4 || typeof e4 != "number") {
                  var r3 = "New max cacheSize ".concat(t3._maxCacheSize, " should be defined and should be a number.");
                  throw new Error(r3);
                }
                t3._maxCacheSize = e4;
              }), V2(this, "isCacheable", function(e4) {
                return t3.getBytesAvailable() + t3._imageCacheSize > e4;
              }), V2(this, "getMaxCacheSize", function() {
                return t3._maxCacheSize;
              }), V2(this, "getCacheSize", function() {
                return t3._imageCacheSize + t3._volumeCacheSize;
              }), V2(this, "_decacheImage", function(e4) {
                var r3 = t3._imageCache.get(e4).imageLoadObject;
                r3.cancel && r3.cancel(), r3.decache && r3.decache(), t3._imageCache.delete(e4);
              }), V2(this, "_decacheVolume", function(e4) {
                var r3 = t3._volumeCache.get(e4).volumeLoadObject;
                r3.cancel && r3.cancel(), r3.decache && r3.decache(), t3._volumeCache.delete(e4);
              }), V2(this, "purgeCache", function() {
                for (var e4 = t3._imageCache.keys(); ; ) {
                  var r3 = e4.next(), n3 = r3.value;
                  if (r3.done)
                    break;
                  t3.removeImageLoadObject(n3), X($, c2.IMAGE_CACHE_IMAGE_REMOVED, { imageId: n3 });
                }
                for (var i3 = t3._volumeCache.keys(); ; ) {
                  var a3 = i3.next(), o3 = a3.value;
                  if (a3.done)
                    break;
                  t3.removeVolumeLoadObject(o3), X($, c2.VOLUME_CACHE_VOLUME_REMOVED, { volumeId: o3 });
                }
              }), V2(this, "getVolumeLoadObject", function(e4) {
                if (e4 === void 0)
                  throw new Error("getVolumeLoadObject: volumeId must not be undefined");
                var r3 = t3._volumeCache.get(e4);
                if (r3 !== void 0)
                  return r3.timeStamp = Date.now(), r3.volumeLoadObject;
              }), V2(this, "getVolume", function(e4) {
                if (e4 === void 0)
                  throw new Error("getVolume: volumeId must not be undefined");
                var r3 = t3._volumeCache.get(e4);
                if (r3 !== void 0)
                  return r3.timeStamp = Date.now(), r3.volume;
              }), V2(this, "removeImageLoadObject", function(e4) {
                if (e4 === void 0)
                  throw new Error("removeImageLoadObject: imageId must not be undefined");
                var r3 = t3._imageCache.get(e4);
                if (r3 === void 0)
                  throw new Error("removeImageLoadObject: imageId was not present in imageCache");
                t3._incrementImageCacheSize(-r3.sizeInBytes);
                var n3 = { imageId: e4 };
                X($, c2.IMAGE_CACHE_IMAGE_REMOVED, n3), t3._decacheImage(e4);
              }), V2(this, "removeVolumeLoadObject", function(e4) {
                if (e4 === void 0)
                  throw new Error("removeVolumeLoadObject: volumeId must not be undefined");
                var r3 = t3._volumeCache.get(e4);
                if (r3 === void 0)
                  throw new Error("removeVolumeLoadObject: volumeId was not present in volumeCache");
                t3._incrementVolumeCacheSize(-r3.sizeInBytes);
                var n3 = { volume: r3, volumeId: e4 };
                X($, c2.VOLUME_CACHE_VOLUME_REMOVED, n3), t3._decacheVolume(e4);
              }), V2(this, "_incrementImageCacheSize", function(e4) {
                t3._imageCacheSize += e4;
              }), V2(this, "_incrementVolumeCacheSize", function(e4) {
                t3._volumeCacheSize += e4;
              }), this._imageCache = /* @__PURE__ */ new Map(), this._volumeCache = /* @__PURE__ */ new Map(), this._imageCacheSize = 0, this._volumeCacheSize = 0, this._maxCacheSize = 1073741824;
            }
            return T2(e3, [{ key: "getBytesAvailable", value: function() {
              return this.getMaxCacheSize() - this.getCacheSize();
            } }, { key: "decacheIfNecessaryUntilBytesAvailable", value: function(e4, t3) {
              var r3 = this.getBytesAvailable();
              if (r3 >= e4)
                return r3;
              var n3 = Array.from(this._imageCache.values());
              n3.sort(function(e5, t4) {
                return e5.timeStamp > t4.timeStamp ? 1 : e5.timeStamp < t4.timeStamp ? -1 : 0;
              });
              var i3 = n3.map(function(e5) {
                return e5.imageId;
              }), a3 = i3;
              t3 && (a3 = i3.filter(function(e5) {
                return !t3.includes(e5);
              }));
              var o3, s3 = Z(a3);
              try {
                for (s3.s(); !(o3 = s3.n()).done; ) {
                  var u3 = o3.value;
                  if (this.removeImageLoadObject(u3), X($, c2.IMAGE_CACHE_IMAGE_REMOVED, { imageId: u3 }), (r3 = this.getBytesAvailable()) >= e4)
                    return r3;
                }
              } catch (e5) {
                s3.e(e5);
              } finally {
                s3.f();
              }
              var l3, d3 = Z(i3 = (n3 = Array.from(this._imageCache.values())).map(function(e5) {
                return e5.imageId;
              }));
              try {
                for (d3.s(); !(l3 = d3.n()).done; ) {
                  var h3 = l3.value;
                  if (this.removeImageLoadObject(h3), X($, c2.IMAGE_CACHE_IMAGE_REMOVED, { imageId: h3 }), (r3 = this.getBytesAvailable()) >= e4)
                    return r3;
                }
              } catch (e5) {
                d3.e(e5);
              } finally {
                d3.f();
              }
            } }, { key: "putImageLoadObject", value: function(e4, t3) {
              var r3 = this;
              if (e4 === void 0)
                throw new Error("putImageLoadObject: imageId must not be undefined");
              if (t3.promise === void 0)
                throw new Error("putImageLoadObject: imageLoadObject.promise must not be undefined");
              if (this._imageCache.has(e4))
                throw new Error("putImageLoadObject: imageId already in cache");
              if (t3.cancel && typeof t3.cancel != "function")
                throw new Error("putImageLoadObject: imageLoadObject.cancel must be a function");
              var n3 = { loaded: false, imageId: e4, sharedCacheKey: void 0, imageLoadObject: t3, timeStamp: Date.now(), sizeInBytes: 0 };
              return this._imageCache.set(e4, n3), t3.promise.then(function(t4) {
                if (r3._imageCache.get(e4)) {
                  if (t4.sizeInBytes === void 0)
                    throw new Error("putImageLoadObject: image.sizeInBytes must not be undefined");
                  if (t4.sizeInBytes.toFixed === void 0)
                    throw new Error("putImageLoadObject: image.sizeInBytes is not a number");
                  if (!r3.isCacheable(t4.sizeInBytes))
                    throw new Error(c2.CACHE_SIZE_EXCEEDED);
                  r3.decacheIfNecessaryUntilBytesAvailable(t4.sizeInBytes), n3.loaded = true, n3.image = t4, n3.sizeInBytes = t4.sizeInBytes, r3._incrementImageCacheSize(n3.sizeInBytes);
                  var i3 = { image: n3 };
                  X($, c2.IMAGE_CACHE_IMAGE_ADDED, i3), n3.sharedCacheKey = t4.sharedCacheKey;
                } else
                  console.warn("The image was purged from the cache before it completed loading.");
              }).catch(function(t4) {
                throw r3._imageCache.delete(e4), t4;
              });
            } }, { key: "getImageLoadObject", value: function(e4) {
              if (e4 === void 0)
                throw new Error("getImageLoadObject: imageId must not be undefined");
              var t3 = this._imageCache.get(e4);
              if (t3 !== void 0)
                return t3.timeStamp = Date.now(), t3.imageLoadObject;
            } }, { key: "getVolumeContainingImageId", value: function(e4) {
              for (var t3 = Array.from(this._volumeCache.keys()), r3 = Y(e4), n3 = 0, i3 = t3; n3 < i3.length; n3++) {
                var a3 = i3[n3], o3 = this._volumeCache.get(a3);
                if (!o3.volume)
                  return;
                var s3 = o3.volume.imageIds;
                if (s3 && s3.length !== 0) {
                  var c3 = (s3 = s3.map(function(e5) {
                    return Y(e5);
                  })).indexOf(r3);
                  if (c3 > -1)
                    return { volume: o3.volume, imageIdIndex: c3 };
                }
              }
            } }, { key: "getCachedImageBasedOnImageURI", value: function(e4) {
              var t3 = Y(e4), r3 = Array.from(this._imageCache.keys()).find(function(e5) {
                return e5.indexOf(t3) !== -1;
              });
              return this._imageCache.get(r3);
            } }, { key: "putVolumeLoadObject", value: function(e4, t3) {
              var r3 = this;
              if (e4 === void 0)
                throw new Error("putVolumeLoadObject: volumeId must not be undefined");
              if (t3.promise === void 0)
                throw new Error("putVolumeLoadObject: volumeLoadObject.promise must not be undefined");
              if (this._volumeCache.has(e4))
                throw new Error("putVolumeLoadObject: volumeId:".concat(e4, " already in cache"));
              if (t3.cancel && typeof t3.cancel != "function")
                throw new Error("putVolumeLoadObject: volumeLoadObject.cancel must be a function");
              var n3 = { loaded: false, volumeId: e4, volumeLoadObject: t3, timeStamp: Date.now(), sizeInBytes: 0 };
              return this._volumeCache.set(e4, n3), t3.promise.then(function(t4) {
                if (r3._volumeCache.get(e4)) {
                  if (t4.sizeInBytes === void 0)
                    throw new Error("putVolumeLoadObject: volume.sizeInBytes must not be undefined");
                  if (t4.sizeInBytes.toFixed === void 0)
                    throw new Error("putVolumeLoadObject: volume.sizeInBytes is not a number");
                  r3.decacheIfNecessaryUntilBytesAvailable(t4.sizeInBytes, t4.imageIds), n3.volume = t4, n3.sizeInBytes = t4.sizeInBytes, r3._incrementVolumeCacheSize(n3.sizeInBytes);
                  var i3 = { volume: n3 };
                  X($, c2.VOLUME_CACHE_VOLUME_ADDED, i3);
                } else
                  console.warn("The image was purged from the cache before it completed loading.");
              }).catch(function(t4) {
                throw r3._volumeCache.delete(e4), t4;
              });
            } }]), e3;
          }())();
          function ee() {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, function(e3) {
              return (e3 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> e3 / 4).toString(16);
            });
          }
          function te(e3) {
            var t3 = e3.dimensions, r3 = e3.metadata, n3 = e3.spacing, i3 = e3.direction, a3 = e3.origin, o3 = e3.scalarData, s3 = 1;
            r3.PhotometricInterpretation === "RGB" && (s3 = 3);
            var c3 = O2().newInstance({ name: "Pixels", numberOfComponents: s3, values: o3 }), u3 = x2().newInstance();
            return u3.setDimensions(t3), u3.setSpacing(n3), u3.setDirection(i3), u3.setOrigin(a3), u3.getPointData().setScalars(c3), u3;
          }
          var re, ne = {};
          function ie(e3, t3) {
            var r3 = e3.indexOf(":"), n3 = e3.substring(0, r3), i3 = ne[n3];
            if (i3 == null) {
              if (re !== void 0)
                return re(e3, t3);
              throw new Error("loadVolumeFromVolumeLoader: no volume loader for volumeId");
            }
            var a3 = i3(e3, t3);
            return a3.promise.then(function(e4) {
              X($, c2.VOLUME_LOADED, { volume: e4 });
            }, function(t4) {
              var r4 = { volumeId: e3, error: t4 };
              X($, c2.VOLUME_LOADED_FAILED, r4);
            }), a3;
          }
          function ae(e3) {
            var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { imageIds: [] };
            if (e3 === void 0)
              throw new Error("loadVolume: parameter volumeId must not be undefined");
            var r3 = Q.getVolumeLoadObject(e3);
            return r3 !== void 0 ? r3.promise : (r3 = ie(e3, t3)).promise.then(function(e4) {
              return e4.imageData = te(e4), e4;
            });
          }
          function oe(e3, t3) {
            return se.apply(this, arguments);
          }
          function se() {
            return (se = b2(k2().mark(function e3(t3, r3) {
              var n3;
              return k2().wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      if (t3 !== void 0) {
                        e4.next = 2;
                        break;
                      }
                      throw new Error("createAndCacheVolume: parameter volumeId must not be undefined");
                    case 2:
                      if ((n3 = Q.getVolumeLoadObject(t3)) === void 0) {
                        e4.next = 5;
                        break;
                      }
                      return e4.abrupt("return", n3.promise);
                    case 5:
                      return (n3 = ie(t3, r3)).promise.then(function(e5) {
                        e5.imageData = te(e5);
                      }), Q.putVolumeLoadObject(t3, n3).catch(function(e5) {
                        throw e5;
                      }), e4.abrupt("return", n3.promise);
                    case 9:
                    case "end":
                      return e4.stop();
                  }
              }, e3);
            }))).apply(this, arguments);
          }
          function ce(e3, t3) {
            var r3 = Q.getVolume(e3);
            if (!r3)
              throw new Error("Cannot created derived volume: Referenced volume with id ".concat(e3, " does not exist."));
            var n3 = t3.volumeId, i3 = t3.targetBuffer;
            n3 === void 0 && (n3 = ee());
            var a3, o3, s3 = r3.metadata, u3 = r3.dimensions, l3 = r3.spacing, d3 = r3.origin, h3 = r3.direction, f3 = r3.scalarData.length;
            if (i3)
              if (i3.type === "Float32Array")
                a3 = 4 * f3, o3 = Float32Array;
              else {
                if (i3.type !== "Uint8Array")
                  throw new Error("TargetBuffer should be Float32Array or Uint8Array");
                a3 = f3, o3 = Uint8Array;
              }
            else
              a3 = 4 * f3, o3 = Float32Array;
            if (!Q.isCacheable(a3))
              throw new Error(c2.CACHE_SIZE_EXCEEDED);
            var v3 = new o3(f3), p3 = O2().newInstance({ name: "Pixels", numberOfComponents: 1, values: v3 }), g3 = x2().newInstance();
            g3.setDimensions(u3), g3.setSpacing(l3), g3.setDirection(h3), g3.setOrigin(d3), g3.getPointData().setScalars(p3);
            var m3 = new H({ volumeId: n3, metadata: S2()(s3), dimensions: [u3[0], u3[1], u3[2]], spacing: l3, origin: d3, direction: h3, imageData: g3, scalarData: v3, sizeInBytes: a3, referencedVolumeId: e3 }), w3 = { promise: Promise.resolve(m3) };
            return Q.putVolumeLoadObject(n3, w3), m3;
          }
          function ue(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], n3 = e3.scalarData, i3 = e3.metadata, a3 = e3.dimensions, o3 = e3.spacing, s3 = e3.origin, u3 = e3.direction;
            if (!n3 || !(n3 instanceof Uint8Array || n3 instanceof Float32Array))
              throw new Error("To use createLocalVolume you should pass scalarData of type Uint8Array or Float32Array");
            t3 === void 0 && (t3 = ee());
            var l3 = Q.getVolume(t3);
            if (l3)
              return l3;
            var d3 = a3[0] * a3[1] * a3[2], h3 = n3 ? n3.buffer.byteLength : 4 * d3, f3 = Q.isCacheable(h3);
            if (!f3)
              throw new Error(c2.CACHE_SIZE_EXCEEDED);
            var v3 = O2().newInstance({ name: "Pixels", numberOfComponents: 1, values: n3 }), p3 = x2().newInstance();
            p3.setDimensions(a3), p3.setSpacing(o3), p3.setDirection(u3), p3.setOrigin(s3), p3.getPointData().setScalars(v3);
            var g3 = new H({ volumeId: t3, metadata: S2()(i3), dimensions: [a3[0], a3[1], a3[2]], spacing: o3, origin: s3, direction: u3, imageData: p3, scalarData: n3, sizeInBytes: h3 });
            if (r3)
              return g3;
            var m3 = { promise: Promise.resolve(g3) };
            return Q.putVolumeLoadObject(t3, m3), g3;
          }
          function le(e3, t3) {
            ne[e3] = t3;
          }
          function de(e3) {
            var t3 = re;
            return re = e3, t3;
          }
          var he = N(9), fe = N.n(he);
          function ve(e3, t3) {
            t3.classHierarchy.push("vtkSharedVolumeMapper");
          }
          var pe = { scalarTexture: null };
          function ge(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, pe, r3), fe().extend(e3, t3, r3), L2().setGet(e3, t3, ["scalarTexture"]), ve(0, t3);
          }
          var me = { newInstance: L2().newInstance(ge, "vtkSharedVolumeMapper"), extend: ge };
          function we(e3, t3) {
            var r3 = me.newInstance();
            r3.setInputData(e3);
            var n3 = e3.getSpacing(), i3 = (n3[0] + n3[1] + n3[2]) / 6;
            return r3.setMaximumSamplesPerRay(4e3), r3.setSampleDistance(i3), r3.setScalarTexture(t3), r3;
          }
          function ye() {
            return (ye = b2(k2().mark(function e3(t3) {
              var r3, n3, i3, a3, o3, s3, c3, u3;
              return k2().wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      return r3 = t3.volumeId, n3 = t3.callback, i3 = t3.blendMode, e4.next = 3, ae(r3);
                    case 3:
                      if (a3 = e4.sent) {
                        e4.next = 6;
                        break;
                      }
                      throw new Error("imageVolume with id: ".concat(a3.volumeId, " does not exist"));
                    case 6:
                      return o3 = a3.imageData, s3 = a3.vtkOpenGLTexture, c3 = we(o3, s3), i3 && c3.setBlendMode(i3), (u3 = R2().newInstance()).setMapper(c3), n3 && n3({ volumeActor: u3, volumeId: r3 }), e4.abrupt("return", u3);
                    case 13:
                    case "end":
                      return e4.stop();
                  }
              }, e3);
            }))).apply(this, arguments);
          }
          var Ce = function(e3) {
            return ye.apply(this, arguments);
          }, be = "viewport-element", Ie = "cornerstone-canvas";
          function ke(e3) {
            var t3 = "canvas.".concat(Ie), r3 = "div.".concat(be), n3 = e3.querySelector(r3) || function(e4) {
              var t4 = document.createElement("div");
              return t4.style.position = "relative", t4.style.width = "100%", t4.style.height = "100%", t4.classList.add(be), e4.appendChild(t4), t4;
            }(e3);
            return n3.querySelector(t3) || function(e4) {
              var t4 = document.createElement("canvas");
              return t4.style.position = "absolute", t4.style.width = "100%", t4.style.height = "100%", t4.classList.add(Ie), e4.appendChild(t4), t4;
            }(n3);
          }
          function Ee(e3, t3) {
            (t3 == null || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++)
              n3[r3] = e3[r3];
            return n3;
          }
          function Re(e3, t3) {
            if (e3) {
              if (typeof e3 == "string")
                return Ee(e3, t3);
              var r3 = Object.prototype.toString.call(e3).slice(8, -1);
              return r3 === "Object" && e3.constructor && (r3 = e3.constructor.name), r3 === "Map" || r3 === "Set" ? Array.from(e3) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? Ee(e3, t3) : void 0;
            }
          }
          function Ae(e3) {
            return function(e4) {
              if (Array.isArray(e4))
                return Ee(e4);
            }(e3) || function(e4) {
              if (typeof Symbol != "undefined" && e4[Symbol.iterator] != null || e4["@@iterator"] != null)
                return Array.from(e4);
            }(e3) || Re(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          var xe = {}, _e = function(e3) {
            return xe[e3];
          }, Oe = function(e3) {
            var t3 = e3.id;
            xe[t3] = e3;
          }, Pe = function(e3) {
            return delete xe[e3];
          }, Se = function() {
            return Object.keys(xe).map(function(e3) {
              return xe[e3];
            });
          }, De = N(21), Te = N.n(De), Me = N(643), Ve = N.n(Me), je = N(128), Le = N.n(je), Ue = N(664), Fe = N.n(Ue), Ne = N(973), Ge = N.n(Ne), We = N(394), qe = N.n(We), Be = N(582), ze = N.n(Be), He = N(482), Ke = N.n(He), $e = N(343), Xe = N.n($e), Ye = N(363), Ze = N.n(Ye), Je = N(982), Qe = N.n(Je), et = N(130), tt = N.n(et), rt = N(298), nt = N.n(rt), it = N(398), at = N.n(it), ot = N(388), st = N.n(ot), ct = N(120), ut = N.n(ct), lt = N(976), dt = N(395), ht = N(948), ft = N(478), vt = L2().vtkWarningMacro;
          function pt(e3, t3) {
            t3.classHierarchy.push("vtkStreamingOpenGLVolumeMapper"), e3.buildBufferObjects = function(e4, r3) {
              var n3 = t3.currentInput;
              if (n3) {
                var i3 = n3.getPointData() && n3.getPointData().getScalars();
                if (i3) {
                  var a3 = r3.getProperty();
                  if (!t3.jitterTexture.getHandle()) {
                    for (var o3 = new Uint8Array(1024), s3 = 0; s3 < 1024; ++s3)
                      o3[s3] = 255 * Math.random();
                    t3.jitterTexture.setMinificationFilter(dt.Filter.LINEAR), t3.jitterTexture.setMagnificationFilter(dt.Filter.LINEAR), t3.jitterTexture.create2DFromRaw(32, 32, 1, ht.VtkDataTypes.UNSIGNED_CHAR, o3);
                  }
                  var c3 = i3.getNumberOfComponents(), u3 = a3.getIndependentComponents() ? c3 : 1, l3 = "".concat(a3.getMTime());
                  if (t3.opacityTextureString !== l3) {
                    for (var d3 = 1024, h3 = 2048 * u3, f3 = new Float32Array(h3), v3 = new Float32Array(d3), p3 = 0; p3 < u3; ++p3) {
                      var g3 = a3.getScalarOpacity(p3), m3 = t3.renderable.getSampleDistance() / a3.getScalarOpacityUnitDistance(p3), w3 = g3.getRange();
                      g3.getTable(w3[0], w3[1], d3, v3, 1);
                      for (var y3 = 0; y3 < d3; ++y3)
                        f3[p3 * d3 * 2 + y3] = 1 - Math.pow(1 - v3[y3], m3), f3[p3 * d3 * 2 + y3 + d3] = f3[p3 * d3 * 2 + y3];
                    }
                    if (t3.opacityTexture.releaseGraphicsResources(t3._openGLRenderWindow), t3.opacityTexture.setMinificationFilter(dt.Filter.LINEAR), t3.opacityTexture.setMagnificationFilter(dt.Filter.LINEAR), t3._openGLRenderWindow.getWebgl2() || t3.context.getExtension("OES_texture_float") && t3.context.getExtension("OES_texture_float_linear"))
                      t3.opacityTexture.create2DFromRaw(d3, 2 * u3, 1, ht.VtkDataTypes.FLOAT, f3);
                    else {
                      for (var C3 = new Uint8Array(h3), b3 = 0; b3 < h3; ++b3)
                        C3[b3] = 255 * f3[b3];
                      t3.opacityTexture.create2DFromRaw(d3, 2 * u3, 1, ht.VtkDataTypes.UNSIGNED_CHAR, C3);
                    }
                    t3.opacityTextureString = l3;
                  }
                  if (l3 = "".concat(a3.getMTime()), t3.colorTextureString !== l3) {
                    for (var I3 = 1024, k3 = new Uint8Array(2048 * u3 * 3), E3 = new Float32Array(3072), R3 = 0; R3 < u3; ++R3) {
                      var A3 = a3.getRGBTransferFunction(R3), x3 = A3.getRange();
                      A3.getTable(x3[0], x3[1], I3, E3, 1);
                      for (var _3 = 0; _3 < 3072; ++_3)
                        k3[R3 * I3 * 6 + _3] = 255 * E3[_3], k3[R3 * I3 * 6 + _3 + 3072] = 255 * E3[_3];
                    }
                    t3.colorTexture.releaseGraphicsResources(t3._openGLRenderWindow), t3.colorTexture.setMinificationFilter(dt.Filter.LINEAR), t3.colorTexture.setMagnificationFilter(dt.Filter.LINEAR), t3.colorTexture.create2DFromRaw(I3, 2 * u3, 3, ht.VtkDataTypes.UNSIGNED_CHAR, k3), t3.colorTextureString = l3;
                  }
                  if (l3 = "".concat(n3.getMTime()), t3.scalarTextureString !== l3) {
                    var P3 = n3.getDimensions(), S3 = t3.scalarTexture.getTextureParameters(), D3 = n3.getPointData().getScalars().getDataType(), T3 = n3.getPointData().getScalars().getData(), M3 = true;
                    if (S3.dataType && S3.dataType === D3) {
                      var V3 = S3.width * S3.height * S3.depth * S3.numComps;
                      T3.length === V3 && (M3 = false);
                    }
                    M3 ? (t3.scalarTexture.releaseGraphicsResources(t3._openGLRenderWindow), t3.scalarTexture.resetFormatAndType(), t3.scalarTexture.create3DFilterableFromRaw(P3[0], P3[1], P3[2], c3, i3.getDataType(), i3.getData(), t3.renderable.getPreferSizeOverAccuracy())) : (t3.scalarTexture.deactivate(), t3.scalarTexture.update3DFromRaw(T3)), t3.scalarTextureString = l3;
                  }
                  if (!t3.tris.getCABO().getElementCount()) {
                    for (var j3 = new Float32Array(12), L3 = 0; L3 < 4; L3++)
                      j3[3 * L3] = L3 % 2 * 2 - 1, j3[3 * L3 + 1] = L3 > 1 ? 1 : -1, j3[3 * L3 + 2] = -1;
                    var U3 = new Uint16Array(8);
                    U3[0] = 3, U3[1] = 0, U3[2] = 1, U3[3] = 3, U3[4] = 3, U3[5] = 0, U3[6] = 3, U3[7] = 2;
                    var F3 = O2().newInstance({ numberOfComponents: 3, values: j3 });
                    F3.setName("points");
                    var N2 = O2().newInstance({ numberOfComponents: 1, values: U3 });
                    t3.tris.getCABO().createVBO(N2, "polys", ft.Representation.SURFACE, { points: F3, cellOffset: 0 });
                  }
                  t3.VBOBuildTime.modified();
                }
              }
            }, e3.setCameraShaderParameters = function(r3, n3, i3) {
              var a3 = r3.getProgram(), o3 = t3.openGLCamera.getRenderable(), s3 = i3.getMapper().getBlendMode(), c3 = o3.getSlabThickness(), u3 = o3.getClippingRange(), l3 = 0.5 * (u3[1] + u3[0]);
              s3 !== p2.BlendMode.COMPOSITE_BLEND && c3 !== null ? (u3[0] = l3 - c3, u3[1] = l3 + c3, o3.setSlabThicknessActive(true)) : o3.setSlabThicknessActive(false), a3.setUniformf("camThick", u3[1] - u3[0]), a3.setUniformf("camNear", u3[0]), a3.setUniformf("camFar", u3[1]);
              var d3 = t3.openGLCamera.getKeyMatrices(n3), h3 = t3.openGLVolume.getKeyMatrices();
              lt.mat4.multiply(t3.modelToView, d3.wcvc, h3.mcwc);
              for (var f3 = t3.currentInput.getBounds(), v3 = t3.currentInput.getSpacing(), g3 = t3.currentInput.getDimensions(), m3 = new Float64Array(3), w3 = new Float64Array(3), y3 = 1, C3 = -1, b3 = 1, I3 = -1, k3 = 0; k3 < 8; ++k3) {
                if (lt.vec3.set(m3, f3[k3 % 2], f3[2 + Math.floor(k3 / 2) % 2], f3[4 + Math.floor(k3 / 4)]), lt.vec3.transformMat4(m3, m3, t3.modelToView), !o3.getParallelProjection()) {
                  lt.vec3.normalize(w3, m3);
                  var E3 = -u3[0] / m3[2];
                  lt.vec3.scale(m3, w3, E3);
                }
                lt.vec3.transformMat4(m3, m3, d3.vcpc), y3 = Math.min(m3[0], y3), C3 = Math.max(m3[0], C3), b3 = Math.min(m3[1], b3), I3 = Math.max(m3[1], I3);
              }
              a3.setUniformf("dcxmin", y3), a3.setUniformf("dcxmax", C3), a3.setUniformf("dcymin", b3), a3.setUniformf("dcymax", I3), a3.isUniformUsed("cameraParallel") && a3.setUniformi("cameraParallel", o3.getParallelProjection());
              var R3 = t3.currentInput.getSpatialExtent(), A3 = new Float64Array(3);
              lt.vec3.set(A3, (R3[1] - R3[0]) * v3[0], (R3[3] - R3[2]) * v3[1], (R3[5] - R3[4]) * v3[2]), a3.setUniform3f("vSpacing", v3[0], v3[1], v3[2]), lt.vec3.set(m3, R3[0], R3[2], R3[4]), t3.currentInput.indexToWorldVec3(m3, m3), lt.vec3.transformMat4(m3, m3, t3.modelToView), a3.setUniform3f("vOriginVC", m3[0], m3[1], m3[2]);
              var x3 = t3.currentInput.getIndexToWorld();
              lt.mat4.multiply(t3.idxToView, t3.modelToView, x3), lt.mat3.multiply(t3.idxNormalMatrix, d3.normalMatrix, h3.normalMatrix), lt.mat3.multiply(t3.idxNormalMatrix, t3.idxNormalMatrix, t3.currentInput.getDirection());
              var _3 = lt.vec3.length(A3) / t3.renderable.getSampleDistance();
              _3 > t3.renderable.getMaximumSamplesPerRay() && vt("The number of steps required ".concat(Math.ceil(_3), " is larger than the\n        specified maximum number of steps ").concat(t3.renderable.getMaximumSamplesPerRay(), ".\n        Please either change the\n        volumeMapper sampleDistance or its maximum number of samples."));
              var O3 = new Float64Array(3);
              if (lt.vec3.set(O3, 1, 1, 1), lt.vec3.divide(O3, O3, A3), a3.setUniform3f("vVCToIJK", O3[0], O3[1], O3[2]), a3.setUniform3i("volumeDimensions", g3[0], g3[1], g3[2]), !t3._openGLRenderWindow.getWebgl2()) {
                var P3 = t3.scalarTexture.getVolumeInfo();
                a3.setUniformf("texWidth", t3.scalarTexture.getWidth()), a3.setUniformf("texHeight", t3.scalarTexture.getHeight()), a3.setUniformi("xreps", P3.xreps), a3.setUniformi("xstride", P3.xstride), a3.setUniformi("ystride", P3.ystride);
              }
              for (var S3 = new Float64Array(3), D3 = new Float64Array(3), T3 = 0; T3 < 6; ++T3) {
                switch (T3) {
                  case 1:
                    lt.vec3.set(S3, -1, 0, 0), lt.vec3.set(D3, R3[0], R3[2], R3[4]);
                    break;
                  case 2:
                    lt.vec3.set(S3, 0, 1, 0), lt.vec3.set(D3, R3[1], R3[3], R3[5]);
                    break;
                  case 3:
                    lt.vec3.set(S3, 0, -1, 0), lt.vec3.set(D3, R3[0], R3[2], R3[4]);
                    break;
                  case 4:
                    lt.vec3.set(S3, 0, 0, 1), lt.vec3.set(D3, R3[1], R3[3], R3[5]);
                    break;
                  case 5:
                    lt.vec3.set(S3, 0, 0, -1), lt.vec3.set(D3, R3[0], R3[2], R3[4]);
                    break;
                  default:
                    lt.vec3.set(S3, 1, 0, 0), lt.vec3.set(D3, R3[1], R3[3], R3[5]);
                }
                lt.vec3.transformMat3(S3, S3, t3.idxNormalMatrix), lt.vec3.transformMat4(D3, D3, t3.idxToView);
                var M3 = -1 * lt.vec3.dot(D3, S3);
                if (a3.setUniform3f("vPlaneNormal".concat(T3), S3[0], S3[1], S3[2]), a3.setUniformf("vPlaneDistance".concat(T3), M3), i3.getProperty().getUseLabelOutline()) {
                  var V3 = t3.currentInput.getWorldToIndex();
                  a3.setUniformMatrix("vWCtoIDX", V3), lt.mat4.invert(t3.projectionToWorld, d3.wcpc), a3.setUniformMatrix("PCWCMatrix", t3.projectionToWorld);
                  var j3 = e3.getRenderTargetSize(), L3 = e3.getRenderTargetOffset();
                  a3.setUniformf("vpWidth", j3[0]), a3.setUniformf("vpHeight", j3[1]), a3.setUniformf("vpOffsetX", L3[0] / j3[0]), a3.setUniformf("vpOffsetY", L3[1] / j3[1]);
                }
              }
              switch (lt.mat4.invert(t3.projectionToView, d3.vcpc), a3.setUniformMatrix("PCVCMatrix", t3.projectionToView), t3.lastLightComplexity) {
                default:
                case 0:
                  break;
                case 1:
                case 2:
                case 3:
                  var U3 = 0, F3 = [];
                  n3.getLights().forEach(function(e4) {
                    if (e4.getSwitch() > 0) {
                      var t4 = e4.getColor(), r4 = e4.getIntensity();
                      F3[0] = t4[0] * r4, F3[1] = t4[1] * r4, F3[2] = t4[2] * r4, a3.setUniform3fArray("lightColor".concat(U3), F3);
                      var n4 = e4.getDirection();
                      lt.vec3.set(S3, n4[0], n4[1], n4[2]), lt.vec3.transformMat3(S3, S3, d3.normalMatrix), a3.setUniform3f("lightDirectionVC".concat(U3), S3[0], S3[1], S3[2]);
                      var i4 = [-0.5 * S3[0], -0.5 * S3[1], -0.5 * (S3[2] - 1)];
                      a3.setUniform3fArray("lightHalfAngleVC".concat(U3), i4), U3++;
                    }
                  });
              }
            }, e3.getRenderTargetSize = function() {
              if (t3._useSmallViewport)
                return [t3._smallViewportWidth, t3._smallViewportHeight];
              var e4 = t3.openGLRenderer.getTiledSizeAndOrigin();
              return [e4.usize, e4.vsize];
            }, e3.getRenderTargetOffset = function() {
              var e4 = t3.openGLRenderer.getTiledSizeAndOrigin();
              return [e4.lowerLeftU, e4.lowerLeftV];
            };
          }
          var gt = {};
          function mt(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, gt, r3), st().extend(e3, t3, r3), t3.scalarTexture = r3.scalarTexture, t3.previousState = {}, pt(e3, t3);
          }
          var wt = { newInstance: L2().newInstance(mt, "vtkStreamingOpenGLVolumeMapper"), extend: mt };
          function yt(e3, t3) {
            t3.classHierarchy.push("vtkStreamingOpenGLViewNodeFactory"), e3.createNode = function(r3) {
              if (r3.isDeleted())
                return null;
              for (var n3 = 0, i3 = r3.getClassName(n3++), a3 = false, o3 = Object.keys(t3.overrides); i3 && !a3; )
                o3.indexOf(i3) !== -1 ? a3 = true : i3 = r3.getClassName(n3++);
              if (!a3)
                return null;
              var s3 = t3.getModelInitialValues(r3), c3 = t3.overrides[i3](s3);
              return c3.setMyFactory(e3), c3;
            }, t3.getModelInitialValues = function(e4) {
              var t4 = {};
              return e4.getClassName() === "vtkSharedVolumeMapper" && (t4.scalarTexture = e4.getScalarTexture()), t4;
            };
          }
          var Ct = {};
          function bt(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, Ct, r3), ut().extend(e3, t3, r3), yt(e3, t3), e3.registerOverride("vtkActor", Ve().newInstance), e3.registerOverride("vtkActor2D", Le().newInstance), e3.registerOverride("vtkCamera", Fe().newInstance), e3.registerOverride("vtkGlyph3DMapper", Ge().newInstance), e3.registerOverride("vtkImageMapper", qe().newInstance), e3.registerOverride("vtkImageSlice", ze().newInstance), e3.registerOverride("vtkMapper", Xe().newInstance), e3.registerOverride("vtkPixelSpaceCallbackMapper", Ke().newInstance), e3.registerOverride("vtkRenderer", Ze().newInstance), e3.registerOverride("vtkSkybox", Qe().newInstance), e3.registerOverride("vtkSphereMapper", tt().newInstance), e3.registerOverride("vtkStickMapper", nt().newInstance), e3.registerOverride("vtkTexture", F2().newInstance), e3.registerOverride("vtkVolume", at().newInstance), e3.registerOverride("vtkVolumeMapper", st().newInstance), e3.registerOverride("vtkSharedVolumeMapper", wt.newInstance);
          }
          var It = { newInstance: L2().newInstance(bt, "vtkStreamingOpenGLViewNodeFactory"), extend: bt };
          function kt(e3, t3) {
            t3.classHierarchy.push("vtkStreamingOpenGLRenderWindow");
          }
          function Et(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, r3), Te().extend(e3, t3, r3), t3.myFactory = It.newInstance(), t3.myFactory.registerOverride("vtkRenderWindow", Rt), kt(0, t3);
          }
          var Rt = L2().newInstance(Et, "vtkStreamingOpenGLRenderWindow"), At = { newInstance: Rt, extend: Et }, xt = N(281), _t = N.n(xt), Ot = N(329), Pt = N.n(Ot), St = N(673), Dt = N.n(St);
          function Tt(e3, t3) {
            var r3 = e3.invokeResize;
            delete e3.invokeResize, t3.renderWindow = Pt().newInstance(), t3.rendererMap = {}, t3.openGLRenderWindow = At.newInstance(), t3.renderWindow.addView(t3.openGLRenderWindow), t3.interactor = Dt().newInstance(), t3.interactor.setView(t3.openGLRenderWindow), t3.interactor.initialize(), e3.addRenderer = function(e4) {
              var r4 = e4.viewport, n3 = e4.id, i3 = e4.background, a3 = _t().newInstance({ viewport: r4, background: i3 || t3.background });
              t3.renderWindow.addRenderer(a3), t3.rendererMap[n3] = a3;
            }, e3.removeRenderer = function(r4) {
              var n3 = e3.getRenderer(r4);
              t3.renderWindow.removeRenderer(n3), delete t3.rendererMap[r4];
            }, e3.getRenderer = function(e4) {
              return t3.rendererMap[e4];
            }, e3.getRenderers = function() {
              var e4 = t3.rendererMap;
              return Object.keys(e4).map(function(t4) {
                return { id: t4, renderer: e4[t4] };
              });
            }, e3.resize = function() {
              if (t3.container) {
                var e4 = t3.container, n3 = e4.width, i3 = e4.height;
                t3.openGLRenderWindow.setSize(Math.floor(1 * n3), Math.floor(1 * i3)), r3(), t3.renderWindow.render();
              }
            }, e3.setContainer = function(e4) {
              t3.container = e4, t3.openGLRenderWindow.setContainer(t3.container);
            }, e3.delete = L2().chain(e3.setContainer, t3.openGLRenderWindow.delete, e3.delete), e3.resize();
          }
          N(348), N(70), N(474), N(610);
          var Mt = { background: [0, 0, 0], container: null };
          function Vt(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, Mt, r3), L2().obj(e3, t3), L2().get(e3, t3, ["renderWindow", "openGLRenderWindow", "interactor", "container"]), L2().event(e3, t3, "resize"), Tt(e3, t3);
          }
          var jt = { newInstance: L2().newInstance(Vt), extend: Vt };
          function Lt(e3) {
            if (e3 === void 0)
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e3;
          }
          function Ut(e3) {
            return Ut = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
              return e4.__proto__ || Object.getPrototypeOf(e4);
            }, Ut(e3);
          }
          function Ft(e3, t3) {
            for (; !Object.prototype.hasOwnProperty.call(e3, t3) && (e3 = Ut(e3)) !== null; )
              ;
            return e3;
          }
          function Nt() {
            return Nt = typeof Reflect != "undefined" && Reflect.get ? Reflect.get : function(e3, t3, r3) {
              var n3 = Ft(e3, t3);
              if (n3) {
                var i3 = Object.getOwnPropertyDescriptor(n3, t3);
                return i3.get ? i3.get.call(arguments.length < 3 ? e3 : r3) : i3.value;
              }
            }, Nt.apply(this, arguments);
          }
          function Gt(e3, t3) {
            return Gt = Object.setPrototypeOf || function(e4, t4) {
              return e4.__proto__ = t4, e4;
            }, Gt(e3, t3);
          }
          function Wt(e3, t3) {
            if (typeof t3 != "function" && t3 !== null)
              throw new TypeError("Super expression must either be null or a function");
            e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && Gt(e3, t3);
          }
          function qt(e3) {
            return qt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && typeof Symbol == "function" && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, qt(e3);
          }
          function Bt(e3, t3) {
            if (t3 && (qt(t3) === "object" || typeof t3 == "function"))
              return t3;
            if (t3 !== void 0)
              throw new TypeError("Derived constructors may only return object or undefined");
            return Lt(e3);
          }
          var zt = Q;
          function Ht(e3, t3) {
            return function(e4) {
              if (Array.isArray(e4))
                return e4;
            }(e3) || function(e4, t4) {
              var r3 = e4 == null ? null : typeof Symbol != "undefined" && e4[Symbol.iterator] || e4["@@iterator"];
              if (r3 != null) {
                var n3, i3, a3 = [], o3 = true, s3 = false;
                try {
                  for (r3 = r3.call(e4); !(o3 = (n3 = r3.next()).done) && (a3.push(n3.value), !t4 || a3.length !== t4); o3 = true)
                    ;
                } catch (e5) {
                  s3 = true, i3 = e5;
                } finally {
                  try {
                    o3 || r3.return == null || r3.return();
                  } finally {
                    if (s3)
                      throw i3;
                  }
                }
                return a3;
              }
            }(e3, t3) || Re(e3, t3) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          var Kt = N(847), $t = N.n(Kt), Xt = N(807), Yt = N.n(Xt);
          function Zt(e3, t3, r3) {
            var n3 = Ht(e3, 3), i3 = n3[0], a3 = n3[1], o3 = n3[2], s3 = Ht(t3, 3), c3 = s3[0], u3 = s3[1], l3 = s3[2], d3 = Ht(r3, 4), h3 = d3[0], f3 = d3[1], v3 = d3[2], p3 = c3 - i3, g3 = u3 - a3, m3 = l3 - o3, w3 = -1 * (h3 * i3 + f3 * a3 + v3 * o3 - d3[3]) / (h3 * p3 + f3 * g3 + v3 * m3);
            return [p3 * w3 + i3, g3 * w3 + a3, m3 * w3 + o3];
          }
          function Jt(e3, t3) {
            var r3 = Ht(e3, 3), n3 = r3[0], i3 = r3[1], a3 = r3[2];
            return [n3, i3, a3, n3 * t3[0] + i3 * t3[1] + a3 * t3[2]];
          }
          function Qt(e3, t3, r3) {
            var n3 = Ht(e3, 4), i3 = n3[0], a3 = n3[1], o3 = n3[2], s3 = n3[3], c3 = Ht(t3, 4), u3 = c3[0], l3 = c3[1], d3 = c3[2], h3 = c3[3], f3 = Ht(r3, 4), v3 = f3[0], p3 = f3[1], g3 = f3[2], m3 = f3[3], w3 = lt.mat3.fromValues(i3, u3, v3, a3, l3, p3, o3, d3, g3), y3 = lt.mat3.fromValues(s3, h3, m3, a3, l3, p3, o3, d3, g3), C3 = lt.mat3.fromValues(i3, u3, v3, s3, h3, m3, o3, d3, g3), b3 = lt.mat3.fromValues(i3, u3, v3, a3, l3, p3, s3, h3, m3);
            return [lt.mat3.determinant(y3) / lt.mat3.determinant(w3), lt.mat3.determinant(C3) / lt.mat3.determinant(w3), lt.mat3.determinant(b3) / lt.mat3.determinant(w3)];
          }
          function er(e3, t3) {
            (t3 == null || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++)
              n3[r3] = e3[r3];
            return n3;
          }
          var tr = function() {
            function e3(t3) {
              var r3 = this;
              M2(this, e3), V2(this, "id", void 0), V2(this, "element", void 0), V2(this, "canvas", void 0), V2(this, "renderingEngineId", void 0), V2(this, "type", void 0), V2(this, "flipHorizontal", false), V2(this, "flipVertical", false), V2(this, "sx", void 0), V2(this, "sy", void 0), V2(this, "sWidth", void 0), V2(this, "sHeight", void 0), V2(this, "_actors", void 0), V2(this, "defaultOptions", void 0), V2(this, "options", void 0), V2(this, "_suppressCameraModifiedEvents", false), V2(this, "suppressEvents", void 0), V2(this, "getFrameOfReferenceUID", void 0), V2(this, "canvasToWorld", void 0), V2(this, "worldToCanvas", void 0), V2(this, "customRenderViewportToCanvas", void 0), V2(this, "resize", void 0), V2(this, "getProperties", void 0), V2(this, "applyFlipTx", function(e4) {
                var t4 = r3.getDefaultActor();
                if (!t4)
                  return e4;
                var n3 = t4.volumeActor.getMatrix(), i3 = lt.vec3.create(), a3 = lt.mat4.create();
                return lt.mat4.transpose(a3, n3), lt.vec3.transformMat4(i3, e4, a3), [i3[0], i3[1], i3[2]];
              }), this.id = t3.id, this.renderingEngineId = t3.renderingEngineId, this.type = t3.type, this.element = t3.element, this.canvas = t3.canvas, this.sx = t3.sx, this.sy = t3.sy, this.sWidth = t3.sWidth, this.sHeight = t3.sHeight, this._actors = /* @__PURE__ */ new Map(), this.element.setAttribute("data-viewport-uid", this.id), this.element.setAttribute("data-rendering-engine-uid", this.renderingEngineId), this.defaultOptions = S2()(t3.defaultOptions), this.suppressEvents = !!t3.defaultOptions.suppressEvents && t3.defaultOptions.suppressEvents, this.options = S2()(t3.defaultOptions);
            }
            return T2(e3, [{ key: "getRenderingEngine", value: function() {
              return _e(this.renderingEngineId);
            } }, { key: "getRenderer", value: function() {
              var e4 = this.getRenderingEngine();
              if (!e4 || e4.hasBeenDestroyed)
                throw new Error("Rendering engine has been destroyed");
              return e4.offscreenMultiRenderWindow.getRenderer(this.id);
            } }, { key: "render", value: function() {
              this.getRenderingEngine().renderViewport(this.id);
            } }, { key: "setOptions", value: function(e4) {
              var t3 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
              this.options = S2()(e4), t3 && this.render();
            } }, { key: "reset", value: function() {
              var e4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
              this.options = S2()(this.defaultOptions), e4 && this.render();
            } }, { key: "flip", value: function(e4) {
              var t3 = this, r3 = e4.flipHorizontal, n3 = e4.flipVertical, i3 = this.getDefaultImageData();
              if (i3) {
                var a3 = false, o3 = false;
                if (r3 !== void 0 && (r3 && !this.flipHorizontal || !r3 && this.flipHorizontal) && (a3 = true), n3 !== void 0 && (n3 && !this.flipVertical || !n3 && this.flipVertical) && (o3 = true), a3 || o3) {
                  var s3, c3, u3 = i3.getOrigin(), l3 = i3.getDirection(), d3 = i3.getSpacing(), h3 = i3.getDimensions(), f3 = l3.slice(0, 3), v3 = l3.slice(3, 6), p3 = l3.slice(6, 9), g3 = lt.vec3.create();
                  lt.vec3.scaleAndAdd(g3, u3, f3, h3[0] / 2 * d3[0]), lt.vec3.scaleAndAdd(g3, g3, v3, h3[1] / 2 * d3[1]), lt.vec3.scaleAndAdd(g3, g3, p3, h3[2] / 2 * d3[2]);
                  var m3 = $t().buildFromRadian().identity().translate(g3[0], g3[1], g3[2]).rotateFromDirections(v3, [0, 1, 0]).rotateFromDirections(f3, [1, 0, 0]), w3 = $t().buildFromRadian().identity().rotateFromDirections([1, 0, 0], f3).rotateFromDirections([0, 1, 0], v3).translate(-g3[0], -g3[1], -g3[2]);
                  a3 && (this.flipHorizontal = r3, s3 = $t().buildFromRadian().multiply(m3.getMatrix()).scale(-1, 1, 1).multiply(w3.getMatrix())), o3 && (this.flipVertical = n3, c3 = $t().buildFromRadian().multiply(m3.getMatrix()).scale(1, -1, 1).multiply(w3.getMatrix())), this.getActors().forEach(function(e5) {
                    var r4 = e5.volumeActor, n4 = r4.getUserMatrix();
                    s3 && lt.mat4.multiply(n4, n4, s3.getMatrix()), c3 && lt.mat4.multiply(n4, n4, c3.getMatrix()), r4.setUserMatrix(n4), t3.getRenderingEngine().render();
                  }), this.getRenderingEngine().render();
                }
              }
            } }, { key: "getDefaultImageData", value: function() {
              var e4 = this.getDefaultActor();
              if (e4)
                return e4.volumeActor.getMapper().getInputData();
            } }, { key: "getDefaultActor", value: function() {
              return this.getActors()[0];
            } }, { key: "getActors", value: function() {
              return Array.from(this._actors.values());
            } }, { key: "getActor", value: function(e4) {
              return this._actors.get(e4);
            } }, { key: "setActors", value: function(e4) {
              this.removeAllActors(), this.addActors(e4);
            } }, { key: "removeActor", value: function(e4) {
              var t3 = this.getActor(e4);
              t3 ? (this.getRenderer().removeViewProp(t3.volumeActor), this._actors.delete(e4)) : console.warn("Actor ".concat(e4, " does not exist for this viewport"));
            } }, { key: "removeActors", value: function(e4) {
              var t3 = this;
              e4.forEach(function(e5) {
                t3.removeActor(e5);
              });
            } }, { key: "addActors", value: function(e4) {
              var t3 = this;
              e4.forEach(function(e5) {
                return t3.addActor(e5);
              });
            } }, { key: "addActor", value: function(e4) {
              var t3 = e4.uid, r3 = e4.volumeActor, n3 = this.getRenderingEngine();
              if (n3 && !n3.hasBeenDestroyed) {
                if (!t3 || !r3)
                  throw new Error("Actors should have uid and vtk volumeActor properties");
                this.getActor(t3) ? console.warn("Actor ".concat(t3, " already exists for this viewport")) : (this.getRenderer().addActor(r3), this._actors.set(t3, Object.assign({}, e4)));
              } else
                console.warn("Cannot add actor UID of ".concat(t3, " Rendering Engine has been destroyed"));
            } }, { key: "removeAllActors", value: function() {
              this.getRenderer().removeAllViewProps(), this._actors = /* @__PURE__ */ new Map();
            } }, { key: "resetCameraNoEvent", value: function() {
              this._suppressCameraModifiedEvents = true, this.resetCamera(), this._suppressCameraModifiedEvents = false;
            } }, { key: "setCameraNoEvent", value: function(e4) {
              this._suppressCameraModifiedEvents = true, this.setCamera(e4), this._suppressCameraModifiedEvents = false;
            } }, { key: "_getViewImageDataIntersections", value: function(e4, t3, r3) {
              var n3, i3 = r3[0], a3 = r3[1], o3 = r3[2], s3 = i3 * t3[0] + a3 * t3[1] + o3 * t3[2], c3 = e4.getBounds(), u3 = [], l3 = function(e5, t4) {
                var r4 = typeof Symbol != "undefined" && e5[Symbol.iterator] || e5["@@iterator"];
                if (!r4) {
                  if (Array.isArray(e5) || (r4 = function(e6, t5) {
                    if (e6) {
                      if (typeof e6 == "string")
                        return er(e6, t5);
                      var r5 = Object.prototype.toString.call(e6).slice(8, -1);
                      return r5 === "Object" && e6.constructor && (r5 = e6.constructor.name), r5 === "Map" || r5 === "Set" ? Array.from(e6) : r5 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r5) ? er(e6, t5) : void 0;
                    }
                  }(e5)) || t4 && e5 && typeof e5.length == "number") {
                    r4 && (e5 = r4);
                    var n4 = 0, i4 = function() {
                    };
                    return { s: i4, n: function() {
                      return n4 >= e5.length ? { done: true } : { done: false, value: e5[n4++] };
                    }, e: function(e6) {
                      throw e6;
                    }, f: i4 };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var a4, o4 = true, s4 = false;
                return { s: function() {
                  r4 = r4.call(e5);
                }, n: function() {
                  var e6 = r4.next();
                  return o4 = e6.done, e6;
                }, e: function(e6) {
                  s4 = true, a4 = e6;
                }, f: function() {
                  try {
                    o4 || r4.return == null || r4.return();
                  } finally {
                    if (s4)
                      throw a4;
                  }
                } };
              }(this._getEdges(c3));
              try {
                for (l3.s(); !(n3 = l3.n()).done; ) {
                  var d3 = Ht(n3.value, 2), h3 = Ht(d3[0], 3), f3 = h3[0], v3 = h3[1], p3 = h3[2], g3 = Ht(d3[1], 3), m3 = g3[0], w3 = g3[1], y3 = g3[2];
                  if (i3 * (m3 - f3) + a3 * (w3 - v3) + o3 * (y3 - p3) != 0) {
                    var C3 = Zt([f3, v3, p3], [m3, w3, y3], [i3, a3, o3, s3]);
                    this._isInBounds(C3, c3) && u3.push(C3);
                  }
                }
              } catch (e5) {
                l3.e(e5);
              } finally {
                l3.f();
              }
              return u3;
            } }, { key: "resetCamera", value: function() {
              var e4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], t3 = this.getRenderer(), r3 = S2()(this.getCamera()), n3 = t3.computeVisiblePropBounds(), i3 = [0, 0, 0], a3 = this.getDefaultImageData();
              if (a3) {
                var o3 = a3.getSpacing();
                n3[0] = n3[0] + o3[0] / 2, n3[1] = n3[1] - o3[0] / 2, n3[2] = n3[2] + o3[1] / 2, n3[3] = n3[3] - o3[1] / 2, n3[4] = n3[4] + o3[2] / 2, n3[5] = n3[5] - o3[2] / 2;
              }
              var s3 = this.getVtkActiveCamera(), u3 = s3.getViewPlaneNormal(), l3 = s3.getViewUp();
              if (s3.setViewAngle(90), i3[0] = (n3[0] + n3[1]) / 2, i3[1] = (n3[2] + n3[3]) / 2, i3[2] = (n3[4] + n3[5]) / 2, a3) {
                var d3 = a3.getDimensions(), h3 = d3.map(function(e5) {
                  return Math.floor(e5 / 2);
                }), f3 = [h3[0], h3[1], h3[2]];
                a3.indexToWorld(f3, i3);
              }
              var v3, p3 = this._getWorldDistanceViewUpAndViewRight(n3, l3, u3), g3 = p3.widthWorld, m3 = p3.heightWorld, w3 = [this.sWidth, this.sHeight], y3 = g3 / m3, C3 = w3[0] / w3[1];
              if (y3 < C3)
                v3 = m3 / 2;
              else {
                var b3 = y3 / C3;
                v3 = m3 * b3 / 2;
              }
              var I3 = 1.1 * v3, k3 = n3[1] - n3[0], E3 = n3[3] - n3[2], R3 = n3[5] - n3[4];
              v3 = (v3 = (k3 *= k3) + (E3 *= E3) + (R3 *= R3)) == 0 ? 1 : v3;
              var A3 = 1.1 * (v3 = 0.5 * Math.sqrt(v3));
              Math.abs(Yt().dot(l3, u3)) > 0.999 && s3.setViewUp(-l3[2], l3[0], l3[1]);
              var x3 = i3;
              e4 && a3 && (x3 = this._getFocalPointForViewPlaneReset(a3)), s3.setFocalPoint(x3[0], x3[1], x3[2]), s3.setPosition(x3[0] + A3 * u3[0], x3[1] + A3 * u3[1], x3[2] + A3 * u3[2]), t3.resetCameraClippingRange(n3), s3.setParallelScale(I3), s3.setPhysicalScale(v3), s3.setPhysicalTranslation(-x3[0], -x3[1], -x3[2]), s3.setClippingRange(A3, A3 + 0.1);
              var _3 = { type: "ResetCameraEvent", renderer: t3 };
              if (t3.invokeEvent(_3), !this._suppressCameraModifiedEvents && !this.suppressEvents) {
                var O3 = { previousCamera: r3, camera: this.getCamera(), canvas: this.canvas, element: this.element, viewportId: this.id, renderingEngineId: this.renderingEngineId };
                X(this.element, c2.CAMERA_MODIFIED, O3);
              }
              return true;
            } }, { key: "_getFocalPointForViewPlaneReset", value: function(e4) {
              var t3 = this.getCamera(), r3 = t3.focalPoint, n3 = t3.viewPlaneNormal, i3 = this._getViewImageDataIntersections(e4, r3, n3), a3 = 0, o3 = 0, s3 = 0;
              return i3.forEach(function(e5) {
                var t4 = Ht(e5, 3), r4 = t4[0], n4 = t4[1], i4 = t4[2];
                a3 += r4, o3 += n4, s3 += i4;
              }), [a3 / i3.length, o3 / i3.length, s3 / i3.length];
            } }, { key: "getCanvas", value: function() {
              return this.canvas;
            } }, { key: "getVtkActiveCamera", value: function() {
              return this.getRenderer().getActiveCamera();
            } }, { key: "getCamera", value: function() {
              var e4, t3 = this.getVtkActiveCamera();
              return "getSlabThickness" in t3 && (e4 = t3.getSlabThickness()), { viewUp: t3.getViewUp(), viewPlaneNormal: t3.getViewPlaneNormal(), clippingRange: t3.getClippingRange(), position: this.applyFlipTx(t3.getPosition()), focalPoint: this.applyFlipTx(t3.getFocalPoint()), parallelProjection: t3.getParallelProjection(), parallelScale: t3.getParallelScale(), viewAngle: t3.getViewAngle(), slabThickness: e4 };
            } }, { key: "setCamera", value: function(e4) {
              var t3 = this.getVtkActiveCamera(), r3 = S2()(this.getCamera()), n3 = Object.assign({}, r3, e4), i3 = e4.viewUp, a3 = e4.viewPlaneNormal, o3 = e4.clippingRange, s3 = e4.position, u3 = e4.focalPoint, l3 = e4.parallelScale, d3 = e4.viewAngle, f3 = e4.slabThickness;
              if (i3 !== void 0 && t3.setViewUp(i3), a3 !== void 0 && t3.setDirectionOfProjection(-a3[0], -a3[1], -a3[2]), o3 !== void 0 && t3.setClippingRange(o3), s3 !== void 0 && t3.setPosition.apply(t3, Ae(this.applyFlipTx(s3))), u3 !== void 0 && t3.setFocalPoint.apply(t3, Ae(this.applyFlipTx(u3))), l3 !== void 0 && t3.setParallelScale(l3), d3 !== void 0 && t3.setViewAngle(d3), f3 !== void 0 && "setSlabThickness" in t3 && t3.setSlabThickness(f3), !this._suppressCameraModifiedEvents && !this.suppressEvents) {
                var v3 = { previousCamera: r3, camera: n3, canvas: this.canvas, element: this.element, viewportId: this.id, renderingEngineId: this.renderingEngineId };
                X(this.element, c2.CAMERA_MODIFIED, v3);
              }
              this.type == h2.PERSPECTIVE && this.getRenderer().resetCameraClippingRange();
            } }, { key: "_getWorldDistanceViewUpAndViewRight", value: function(e4, t3, r3) {
              var n3 = this._getCorners(e4), i3 = this._getCorners(e4), a3 = lt.vec3.create();
              lt.vec3.cross(a3, t3, r3), a3 = [-a3[0], -a3[1], -a3[2]];
              var o3 = $t().buildFromDegree().identity().rotateFromDirections(t3, [1, 0, 0]);
              n3.forEach(function(e5) {
                return o3.apply(e5);
              });
              for (var s3 = 1 / 0, c3 = -1 / 0, u3 = 0; u3 < 8; u3++) {
                var l3 = n3[u3][0];
                l3 > c3 && (c3 = l3), l3 < s3 && (s3 = l3);
              }
              o3 = $t().buildFromDegree().identity().rotateFromDirections(a3, [1, 0, 0]), i3.forEach(function(e5) {
                return o3.apply(e5);
              });
              for (var d3 = 1 / 0, h3 = -1 / 0, f3 = 0; f3 < 8; f3++) {
                var v3 = i3[f3][0];
                v3 > h3 && (h3 = v3), v3 < d3 && (d3 = v3);
              }
              return { widthWorld: h3 - d3, heightWorld: c3 - s3 };
            } }, { key: "_getCorners", value: function(e4) {
              return [[e4[0], e4[2], e4[4]], [e4[0], e4[2], e4[5]], [e4[0], e4[3], e4[4]], [e4[0], e4[3], e4[5]], [e4[1], e4[2], e4[4]], [e4[1], e4[2], e4[5]], [e4[1], e4[3], e4[4]], [e4[1], e4[3], e4[5]]];
            } }, { key: "_isInBounds", value: function(e4, t3) {
              var r3 = Ht(t3, 6), n3 = r3[0], i3 = r3[1], a3 = r3[2], o3 = r3[3], s3 = r3[4], c3 = r3[5], u3 = Ht(e4, 3), l3 = u3[0], d3 = u3[1], h3 = u3[2];
              return !(l3 < n3 || l3 > i3 || d3 < a3 || d3 > o3 || h3 < s3 || h3 > c3);
            } }, { key: "_getEdges", value: function(e4) {
              var t3 = Ht(this._getCorners(e4), 8), r3 = t3[0], n3 = t3[1], i3 = t3[2], a3 = t3[3], o3 = t3[4], s3 = t3[5], c3 = t3[6], u3 = t3[7];
              return [[r3, n3], [r3, o3], [r3, i3], [n3, a3], [n3, s3], [i3, a3], [i3, c3], [a3, u3], [o3, c3], [o3, s3], [s3, u3], [c3, u3]];
            } }], [{ key: "useCustomRenderingPipeline", get: function() {
              return false;
            } }]), e3;
          }(), rr = tr, nr = N(821), ir = N.n(nr);
          function ar(e3, t3) {
            t3.classHierarchy.push("vtkSlabCamera");
            var r3 = lt.mat4.create();
            e3.getProjectionMatrix = function(e4, n3, i3) {
              var a3 = lt.mat4.create();
              if (t3.projectionMatrix) {
                var o3 = 1 / t3.physicalScale;
                return lt.vec3.set(tmpvec1, o3, o3, o3), lt.mat4.copy(a3, t3.projectionMatrix), lt.mat4.scale(a3, a3, tmpvec1), lt.mat4.transpose(a3, a3), a3;
              }
              lt.mat4.identity(r3);
              var s3 = t3.clippingRange[0], c3 = t3.clippingRange[1];
              if (t3.slabThicknessActive) {
                var u3 = 0.5 * (t3.clippingRange[1] + t3.clippingRange[0]);
                s3 = u3 - t3.slabThickness, c3 = u3 + t3.slabThickness;
              }
              var l3 = c3 - s3, d3 = [s3 + (n3 + 1) * l3 / 2, s3 + (i3 + 1) * l3 / 2];
              if (t3.parallelProjection) {
                var h3 = t3.parallelScale * e4, f3 = t3.parallelScale, v3 = (t3.windowCenter[0] - 1) * h3, p3 = (t3.windowCenter[0] + 1) * h3, g3 = (t3.windowCenter[1] - 1) * f3, m3 = (t3.windowCenter[1] + 1) * f3;
                lt.mat4.ortho(r3, v3, p3, g3, m3, d3[0], d3[1]), lt.mat4.transpose(r3, r3);
              } else {
                if (t3.useOffAxisProjection)
                  throw new Error("Off-Axis projection is not supported at this time");
                var w3, y3, C3 = Math.tan(Yt().radiansFromDegrees(t3.viewAngle) / 2);
                t3.useHorizontalViewAngle === true ? (w3 = s3 * C3, y3 = s3 * C3 / e4) : (w3 = s3 * C3 * e4, y3 = s3 * C3);
                var b3 = (t3.windowCenter[0] - 1) * w3, I3 = (t3.windowCenter[0] + 1) * w3, k3 = (t3.windowCenter[1] - 1) * y3, E3 = (t3.windowCenter[1] + 1) * y3, R3 = d3[0], A3 = d3[1];
                r3[0] = 2 * R3 / (I3 - b3), r3[5] = 2 * R3 / (E3 - k3), r3[2] = (b3 + I3) / (I3 - b3), r3[6] = (k3 + E3) / (E3 - k3), r3[10] = -(R3 + A3) / (A3 - R3), r3[14] = -1, r3[11] = -2 * R3 * A3 / (A3 - R3), r3[15] = 0;
              }
              return lt.mat4.copy(a3, r3), a3;
            };
          }
          var or = { slabThickness: null, slabThicknessActive: false };
          function sr(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            Object.assign(t3, or, r3), ir().extend(e3, t3, r3), L2().setGet(e3, t3, ["slabThickness", "slabThicknessActive"]), ar(e3, t3);
          }
          var cr = { newInstance: L2().newInstance(sr, "vtkSlabCamera"), extend: sr };
          function ur(e3, t3, r3, n3) {
            return new (r3 || (r3 = Promise))(function(i3, a3) {
              function o3(e4) {
                try {
                  c3(n3.next(e4));
                } catch (e5) {
                  a3(e5);
                }
              }
              function s3(e4) {
                try {
                  c3(n3.throw(e4));
                } catch (e5) {
                  a3(e5);
                }
              }
              function c3(e4) {
                var t4;
                e4.done ? i3(e4.value) : (t4 = e4.value, t4 instanceof r3 ? t4 : new r3(function(e5) {
                  e5(t4);
                })).then(o3, s3);
              }
              c3((n3 = n3.apply(e3, t3 || [])).next());
            });
          }
          const lr = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "sgx 543", "sgx543"];
          function dr(e3) {
            return e3.toLowerCase().replace(/^angle ?\((.+)\)*$/, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "");
          }
          const hr = typeof window == "undefined", fr = (() => {
            if (hr)
              return;
            const { userAgent: e3, platform: t3, maxTouchPoints: r3 } = window.navigator, n3 = /(iphone|ipod|ipad)/i.test(e3), i3 = t3 === "iPad" || t3 === "MacIntel" && r3 > 0 && !window.MSStream;
            return { isIpad: i3, isMobile: /android/i.test(e3) || n3 || i3, isSafari12: /Version\/12.+Safari/.test(e3) };
          })(), vr = [], pr = [];
          function gr(e3, t3) {
            if (e3 === t3)
              return 0;
            const r3 = e3;
            e3.length > t3.length && (e3 = t3, t3 = r3);
            let n3 = e3.length, i3 = t3.length;
            for (; n3 > 0 && e3.charCodeAt(~-n3) === t3.charCodeAt(~-i3); )
              n3--, i3--;
            let a3, o3 = 0;
            for (; o3 < n3 && e3.charCodeAt(o3) === t3.charCodeAt(o3); )
              o3++;
            if (n3 -= o3, i3 -= o3, n3 === 0)
              return i3;
            let s3, c3, u3 = 0, l3 = 0, d3 = 0;
            for (; l3 < n3; )
              pr[l3] = e3.charCodeAt(o3 + l3), vr[l3] = ++l3;
            for (; d3 < i3; )
              for (a3 = t3.charCodeAt(o3 + d3), s3 = d3++, u3 = d3, l3 = 0; l3 < n3; l3++)
                c3 = a3 === pr[l3] ? s3 : s3 + 1, s3 = vr[l3], u3 = vr[l3] = s3 > u3 ? c3 > u3 ? u3 + 1 : c3 : c3 > s3 ? s3 + 1 : c3;
            return u3;
          }
          function mr(e3) {
            return e3 != null;
          }
          class wr extends Error {
            constructor(e3) {
              super(e3), Object.setPrototypeOf(this, new.target.prototype);
            }
          }
          const yr = ({ mobileTiers: e3 = [0, 15, 30, 60], desktopTiers: t3 = [0, 15, 30, 60], override: r3 = {}, glContext: n3, failIfMajorPerformanceCaveat: i3 = false, benchmarksURL: a3 = "https://unpkg.com/detect-gpu@4.0.15/dist/benchmarks" } = {}) => ur(void 0, void 0, void 0, function* () {
            const o3 = {};
            if (hr)
              return { tier: 0, type: "SSR" };
            const { isIpad: s3 = !!(fr == null ? void 0 : fr.isIpad), isMobile: c3 = !!(fr == null ? void 0 : fr.isMobile), screenSize: u3 = window.screen, loadBenchmarks: l3 = (e4) => ur(void 0, void 0, void 0, function* () {
              const t4 = yield fetch(`${a3}/${e4}`).then((e5) => e5.json());
              if (parseInt(t4.shift().split(".")[0], 10) < 4)
                throw new wr("Detect GPU benchmark data is out of date. Please update to version 4x");
              return t4;
            }) } = r3;
            let { renderer: d3 } = r3;
            const h3 = (e4, t4, r4, n4, i4) => ({ device: i4, fps: n4, gpu: r4, isMobile: c3, tier: e4, type: t4 });
            let f3, v3 = "";
            if (d3)
              d3 = dr(d3), f3 = [d3];
            else {
              const e4 = n3 || function(e5, t5 = false) {
                const r4 = { alpha: false, antialias: false, depth: false, failIfMajorPerformanceCaveat: t5, powerPreference: "high-performance", stencil: false };
                e5 && delete r4.powerPreference;
                const n4 = window.document.createElement("canvas"), i4 = n4.getContext("webgl", r4) || n4.getContext("experimental-webgl", r4);
                return i4 != null ? i4 : void 0;
              }(fr == null ? void 0 : fr.isSafari12, i3);
              if (!e4)
                return h3(0, "WEBGL_UNSUPPORTED");
              const t4 = e4.getExtension("WEBGL_debug_renderer_info");
              if (t4 && (d3 = e4.getParameter(t4.UNMASKED_RENDERER_WEBGL)), !d3)
                return h3(1, "FALLBACK");
              v3 = d3, d3 = dr(d3), f3 = function(e5, t5, r4) {
                return t5 === "apple gpu" ? function(e6, t6, r5) {
                  if (!r5)
                    return [t6];
                  const n4 = function(e7) {
                    const t7 = e7.createShader(35633), r6 = e7.createShader(35632), n5 = e7.createProgram();
                    if (!(r6 && t7 && n5))
                      return;
                    e7.shaderSource(t7, "\n    precision highp float;\n    attribute vec3 aPosition;\n    varying float vvv;\n    void main() {\n      vvv = 0.31622776601683794;\n      gl_Position = vec4(aPosition, 1.0);\n    }\n  "), e7.shaderSource(r6, "\n    precision highp float;\n    varying float vvv;\n    void main() {\n      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;\n      enc = fract(enc);\n      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n      gl_FragColor = enc;\n    }\n  "), e7.compileShader(t7), e7.compileShader(r6), e7.attachShader(n5, t7), e7.attachShader(n5, r6), e7.linkProgram(n5), e7.detachShader(n5, t7), e7.detachShader(n5, r6), e7.deleteShader(t7), e7.deleteShader(r6), e7.useProgram(n5);
                    const i5 = e7.createBuffer();
                    e7.bindBuffer(34962, i5), e7.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
                    const a5 = e7.getAttribLocation(n5, "aPosition");
                    e7.vertexAttribPointer(a5, 3, 5126, false, 0, 0), e7.enableVertexAttribArray(a5), e7.clearColor(1, 1, 1, 1), e7.clear(16384), e7.viewport(0, 0, 1, 1), e7.drawArrays(4, 0, 3);
                    const o5 = new Uint8Array(4);
                    return e7.readPixels(0, 0, 1, 1, 6408, 5121, o5), e7.deleteProgram(n5), e7.deleteBuffer(i5), o5.join("");
                  }(e6), i4 = "801621810", a4 = "8016218135", o4 = "80162181161", s4 = (fr == null ? void 0 : fr.isIpad) ? [["a7", o4, 12], ["a8", a4, 15], ["a8x", a4, 15], ["a9", a4, 15], ["a9x", a4, 15], ["a10", a4, 15], ["a10x", a4, 15], ["a12", i4, 15], ["a12x", i4, 15], ["a12z", i4, 15], ["a14", i4, 15], ["m1", i4, 15]] : [["a7", o4, 12], ["a8", a4, 12], ["a9", a4, 15], ["a10", a4, 15], ["a11", i4, 15], ["a12", i4, 15], ["a13", i4, 15], ["a14", i4, 15]];
                  let c4;
                  return n4 === "80162181255" ? c4 = s4.filter(([, , e7]) => e7 >= 14) : (c4 = s4.filter(([, e7]) => e7 === n4), c4.length || (c4 = s4)), c4.map(([e7]) => `apple ${e7} gpu`);
                }(e5, t5, r4) : [t5];
              }(e4, d3, c3);
            }
            const p3 = (yield Promise.all(f3.map((e4) => ur(void 0, void 0, void 0, function* () {
              var t4;
              const r4 = ((e5) => {
                const t5 = c3 ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr"] : ["intel", "apple", "amd", "radeon", "nvidia", "geforce"];
                for (const r5 of t5)
                  if (e5.includes(r5))
                    return r5;
              })(e4);
              if (!r4)
                return;
              const n4 = `${c3 ? "m" : "d"}-${r4}${s3 ? "-ipad" : ""}.json`, i4 = o3[n4] = (t4 = o3[n4]) !== null && t4 !== void 0 ? t4 : l3(n4);
              let a4;
              try {
                a4 = yield i4;
              } catch (t5) {
                if (t5 instanceof wr)
                  throw t5;
                return;
              }
              const d4 = function(e5) {
                var t5;
                const r5 = (e5 = e5.replace(/\([^)]+\)/, "")).match(/\d+/) || e5.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
                return (t5 = r5 == null ? void 0 : r5.join("").replace(/\W|amd/g, "")) !== null && t5 !== void 0 ? t5 : "";
              }(e4);
              let h4 = a4.filter(([, e5]) => e5 === d4);
              h4.length || (h4 = a4.filter(([t5]) => t5.includes(e4)));
              const f4 = h4.length;
              if (f4 === 0)
                return;
              let v4, [p4, , , g4] = f4 > 1 ? h4.map((t5) => [t5, gr(e4, t5[0])]).sort(([, e5], [, t5]) => e5 - t5)[0][0] : h4[0], m4 = Number.MAX_VALUE;
              const { devicePixelRatio: w4 } = window, y4 = u3.width * w4 * u3.height * w4;
              for (const e5 of g4) {
                const [t5, r5] = e5, n5 = t5 * r5, i5 = Math.abs(y4 - n5);
                i5 < m4 && (m4 = i5, v4 = e5);
              }
              if (!v4)
                return;
              const [, , C4, b3] = v4;
              return [m4, C4, p4, b3];
            })))).filter(mr).sort(([e4 = Number.MAX_VALUE, t4], [r4 = Number.MAX_VALUE, n4]) => e4 === r4 ? t4 - n4 : e4 - r4);
            if (!p3.length) {
              const e4 = lr.find((e5) => d3.includes(e5));
              return e4 ? h3(0, "BLOCKLISTED", e4) : h3(1, "FALLBACK", `${d3} (${v3})`);
            }
            const [, g3, m3, w3] = p3[0];
            if (g3 === -1)
              return h3(0, "BLOCKLISTED", m3, g3, w3);
            const y3 = c3 ? e3 : t3;
            let C3 = 0;
            for (let e4 = 0; e4 < y3.length; e4++)
              g3 >= y3[e4] && (C3 = e4);
            return h3(C3, "BENCHMARK", m3, g3, w3);
          });
          var Cr = false, br = false;
          function Ir() {
            var e3 = document.createElement("canvas"), t3 = e3.getContext("webgl") || e3.getContext("experimental-webgl");
            return !!(t3 && t3 instanceof WebGLRenderingContext);
          }
          function kr() {
            return Er.apply(this, arguments);
          }
          function Er() {
            return Er = b2(k2().mark(function e3() {
              var t3, r3 = arguments;
              return k2().wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      if (r3.length > 0 && r3[0] !== void 0 && r3[0], !Cr) {
                        e4.next = 3;
                        break;
                      }
                      return e4.abrupt("return", Cr);
                    case 3:
                      if (Ir()) {
                        e4.next = 9;
                        break;
                      }
                      br = true, console.log("CornerstoneRender: GPU not detected, using CPU rendering"), e4.next = 14;
                      break;
                    case 9:
                      return e4.next = 11, yr();
                    case 11:
                      t3 = e4.sent, console.log("CornerstoneRender: Using detect-gpu to get the GPU benchmark:", t3), t3.tier < 1 ? (console.log("CornerstoneRender: GPU is not powerful enough, using CPU rendering"), br = true) : console.log("CornerstoneRender: using GPU rendering");
                    case 14:
                      return Cr = true, e4.abrupt("return", Cr);
                    case 16:
                    case "end":
                      return e4.stop();
                  }
              }, e3);
            })), Er.apply(this, arguments);
          }
          function Rr(e3) {
            br = e3, Cr = true;
          }
          function Ar() {
            br = !Ir();
          }
          function xr() {
            return br;
          }
          function _r() {
            return Cr;
          }
          var Or = function(e3) {
            Wt(s3, e3);
            var t3, r3, n3, i3, a3, o3 = (i3 = s3, a3 = function() {
              if (typeof Reflect == "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), true;
              } catch (e4) {
                return false;
              }
            }(), function() {
              var e4, t4 = Ut(i3);
              if (a3) {
                var r4 = Ut(this).constructor;
                e4 = Reflect.construct(t4, arguments, r4);
              } else
                e4 = t4.apply(this, arguments);
              return Bt(this, e4);
            });
            function s3(e4) {
              var t4;
              if (M2(this, s3), V2(Lt(t4 = o3.call(this, e4)), "useCPURendering", false), V2(Lt(t4), "_FrameOfReferenceUID", void 0), V2(Lt(t4), "getFrameOfReferenceUID", function() {
                return t4._FrameOfReferenceUID;
              }), V2(Lt(t4), "getProperties", function() {
                return { flipHorizontal: t4.flipHorizontal, flipVertical: t4.flipVertical };
              }), V2(Lt(t4), "canvasToWorld", function(e5) {
                var r5 = t4.getVtkActiveCamera(), n5 = r5.getSlabThicknessActive();
                r5.setSlabThicknessActive(false);
                var i5 = t4.getRenderer(), a5 = t4.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), o4 = a5.getSize(), s4 = [e5[0] + t4.sx, e5[1] + t4.sy];
                s4[1] = o4[1] - s4[1];
                var c4 = a5.displayToWorld(s4[0], s4[1], 0, i5);
                return r5.setSlabThicknessActive(n5), t4.applyFlipTx(c4);
              }), V2(Lt(t4), "worldToCanvas", function(e5) {
                var r5 = t4.getVtkActiveCamera(), n5 = r5.getSlabThicknessActive();
                r5.setSlabThicknessActive(false);
                var i5 = t4.getRenderer(), a5 = t4.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), o4 = a5.getSize(), s4 = a5.worldToDisplay.apply(a5, Ae(t4.applyFlipTx(e5)).concat([i5]));
                s4[1] = o4[1] - s4[1];
                var c4 = [s4[0] - t4.sx, s4[1] - t4.sy];
                return r5.setSlabThicknessActive(n5), c4;
              }), V2(Lt(t4), "getCurrentImageIdIndex", function() {
                return t4._getImageIdIndex();
              }), V2(Lt(t4), "getCurrentImageId", function() {
                var e5 = t4._getImageIdIndex();
                if (e5) {
                  var r5 = t4.getDefaultActor().uid, n5 = zt.getVolume(r5);
                  if (n5)
                    return n5.imageIds[e5];
                }
              }), V2(Lt(t4), "_getImageIdIndex", function() {
                var e5 = t4.getCamera(), r5 = e5.viewPlaneNormal, n5 = e5.focalPoint, i5 = t4.getImageData(), a5 = i5.direction, o4 = i5.origin, s4 = i5.spacing, c4 = a5.slice(a5.length - 3);
                if (!(Math.abs(c4[0] * r5[0] + c4[1] * r5[1] + c4[2] * r5[2]) - 1 > 1e-3)) {
                  var u3 = s4[2], l3 = lt.vec3.create();
                  lt.vec3.sub(l3, n5, o4);
                  var d3 = lt.vec3.dot(l3, r5);
                  return Math.round(Math.abs(d3) / u3);
                }
              }), t4.useCPURendering = xr(), t4.useCPURendering)
                throw new Error("VolumeViewports cannot be used whilst CPU Fallback Rendering is enabled.");
              var r4 = t4.getRenderer(), n4 = cr.newInstance();
              switch (r4.setActiveCamera(n4), t4.type) {
                case h2.ORTHOGRAPHIC:
                  n4.setParallelProjection(true);
                  break;
                case h2.PERSPECTIVE:
                  n4.setParallelProjection(false);
                  break;
                default:
                  throw new Error("Unrecognized viewport type: ".concat(t4.type));
              }
              var i4 = t4.defaultOptions.orientation, a4 = i4.sliceNormal, c3 = i4.viewUp;
              return n4.setDirectionOfProjection(-a4[0], -a4[1], -a4[2]), n4.setViewUpFrom(c3), n4.setFreezeFocalPoint(true), t4.resetCamera(), t4;
            }
            return T2(s3, [{ key: "setVolumes", value: (n3 = b2(k2().mark(function e4(t4) {
              var r4, n4, i4, a4, o4, s4, c3, u3, l3, d3, h3, f3, v3 = arguments;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      if (r4 = v3.length > 1 && v3[1] !== void 0 && v3[1], n4 = zt.getVolume(t4[0].volumeId)) {
                        e5.next = 4;
                        break;
                      }
                      throw new Error("imageVolume with id: ".concat(n4.volumeId, " does not exist"));
                    case 4:
                      return i4 = n4.metadata.FrameOfReferenceUID, e5.next = 7, this._isValidVolumeInputArray(t4, i4);
                    case 7:
                      this._FrameOfReferenceUID = i4, a4 = [], o4 = [], s4 = 0;
                    case 11:
                      if (!(s4 < t4.length)) {
                        e5.next = 22;
                        break;
                      }
                      return c3 = t4[s4], u3 = c3.volumeId, l3 = c3.slabThickness, d3 = c3.actorUID, e5.next = 15, Ce(t4[s4]);
                    case 15:
                      h3 = e5.sent, f3 = d3 || u3, o4.push({ uid: f3, volumeActor: h3, slabThickness: l3 }), l3 === void 0 || a4.includes(l3) || a4.push(l3);
                    case 19:
                      s4++, e5.next = 11;
                      break;
                    case 22:
                      a4.length > 1 && console.warn("Currently slab thickness for intensity projections is tied to the camera, not per volume, using the largest of the two volumes for this viewport."), this._setVolumeActors(o4), r4 && this.render();
                    case 25:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4) {
              return n3.apply(this, arguments);
            }) }, { key: "addVolumes", value: (r3 = b2(k2().mark(function e4(t4) {
              var r4, n4, i4, a4, o4, s4, c3, u3, l3, d3 = arguments;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      return r4 = d3.length > 1 && d3[1] !== void 0 && d3[1], n4 = [], e5.next = 4, this._isValidVolumeInputArray(t4, this._FrameOfReferenceUID);
                    case 4:
                      i4 = 0;
                    case 5:
                      if (!(i4 < t4.length)) {
                        e5.next = 16;
                        break;
                      }
                      return a4 = t4[i4], o4 = a4.volumeId, s4 = a4.visibility, c3 = a4.actorUID, e5.next = 9, Ce(t4[i4]);
                    case 9:
                      u3 = e5.sent, s4 === false && u3.setVisibility(false), l3 = c3 || o4, n4.push({ uid: l3, volumeActor: u3 });
                    case 13:
                      i4++, e5.next = 5;
                      break;
                    case 16:
                      this.addActors(n4), r4 && this.render();
                    case 18:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4) {
              return r3.apply(this, arguments);
            }) }, { key: "removeVolumeActors", value: function(e4) {
              var t4 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
              this.removeActors(e4), t4 && this.render();
            } }, { key: "_isValidVolumeInputArray", value: (t3 = b2(k2().mark(function e4(t4, r4) {
              var n4, i4, a4, o4;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      n4 = t4.length, i4 = 1;
                    case 2:
                      if (!(i4 < n4)) {
                        e5.next = 14;
                        break;
                      }
                      return a4 = t4[i4], e5.next = 6, ae(a4.volumeId);
                    case 6:
                      if (o4 = e5.sent) {
                        e5.next = 9;
                        break;
                      }
                      throw new Error("imageVolume with id: ".concat(o4.volumeId, " does not exist"));
                    case 9:
                      if (r4 === o4.metadata.FrameOfReferenceUID) {
                        e5.next = 11;
                        break;
                      }
                      throw new Error("Volumes being added to viewport ".concat(this.id, " do not share the same FrameOfReferenceUID. This is not yet supported"));
                    case 11:
                      i4++, e5.next = 2;
                      break;
                    case 14:
                      return e5.abrupt("return", true);
                    case 15:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4, r4) {
              return t3.apply(this, arguments);
            }) }, { key: "getIntensityFromWorld", value: function(e4) {
              return this.getDefaultActor().volumeActor.getMapper().getInputData().getScalarValueFromWorld(e4);
            } }, { key: "getBounds", value: function() {
              return this.getRenderer().computeVisiblePropBounds();
            } }, { key: "flip", value: function(e4) {
              Nt(Ut(s3.prototype), "flip", this).call(this, e4);
            } }, { key: "resetCamera", value: function() {
              var e4 = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
              return Nt(Ut(s3.prototype), "resetCamera", this).call(this, e4);
            } }, { key: "setSlabThickness", value: function(e4) {
              this.setCamera({ slabThickness: e4 });
            } }, { key: "getSlabThickness", value: function() {
              return this.getCamera().slabThickness;
            } }, { key: "getImageData", value: function() {
              var e4 = this.getDefaultActor();
              if (e4) {
                var t4 = e4.volumeActor, r4 = t4.getMapper().getInputData();
                return { dimensions: r4.getDimensions(), spacing: r4.getSpacing(), origin: r4.getOrigin(), direction: r4.getDirection(), scalarData: r4.getPointData().getScalars().getData(), imageData: t4.getMapper().getInputData(), metadata: void 0, scaling: void 0 };
              }
            } }, { key: "_setVolumeActors", value: function(e4) {
              var t4 = this.getRenderer();
              this.setActors(e4);
              var r4 = null;
              if (this.type === h2.ORTHOGRAPHIC) {
                e4.forEach(function(e5) {
                  e5.slabThickness && e5.slabThickness > r4 && (r4 = e5.slabThickness);
                }), this.resetCamera();
                var n4 = t4.getActiveCamera();
                n4.setSlabThickness(r4), n4.setFreezeFocalPoint(true);
              } else
                t4.resetCamera(), t4.getActiveCamera().setFreezeFocalPoint(true);
            } }], [{ key: "useCustomRenderingPipeline", get: function() {
              return false;
            } }]), s3;
          }(rr), Pr = Or, Sr = [];
          function Dr(e3) {
            var t3, r3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            for (t3 = 0; t3 < Sr.length && !(Sr[t3].priority <= r3); t3++)
              ;
            Sr.splice(t3, 0, { priority: r3, provider: e3 });
          }
          function Tr(e3) {
            for (var t3 = 0; t3 < Sr.length; t3++)
              if (Sr[t3].provider === e3) {
                Sr.splice(t3, 1);
                break;
              }
          }
          function Mr() {
            for (; Sr.length > 0; )
              Sr.pop();
          }
          function Vr(e3, t3) {
            for (var r3 = 0; r3 < Sr.length; r3++) {
              var n3 = Sr[r3].provider(e3, t3);
              if (n3 !== void 0)
                return n3;
            }
          }
          function jr(e3) {
            for (var t3 = e3.getSize(), r3 = 0; r3 < t3; r3++) {
              var n3 = [];
              e3.getNodeValue(r3, n3), n3[1] = 1 - n3[1], n3[2] = 1 - n3[2], n3[3] = 1 - n3[3], e3.setNodeValue(r3, n3);
            }
          }
          function Lr(e3, t3) {
            var r3 = Math.abs(e3 - t3);
            return { windowWidth: r3, windowCenter: e3 + r3 / 2 };
          }
          function Ur(e3, t3) {
            return { lower: t3 - e3 / 2, upper: t3 + e3 / 2 };
          }
          function Fr(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-5;
            if (e3.length !== t3.length)
              return false;
            for (var n3 = 0; n3 < e3.length; n3++)
              if (Math.abs(e3[n3] - t3[n3]) > r3)
                return false;
            return true;
          }
          function Nr() {
            return window.performance ? performance.now() : Date.now();
          }
          function Gr(e3, t3, r3) {
            return r3 ? function(e4) {
              var t4 = Math.max.apply(Math, Ae(e4.lut)).toString(2).length - 8, r4 = e4.lut[0] >> t4, n3 = e4.lut[e4.lut.length - 1] >> t4, i3 = e4.firstValueMapped + e4.lut.length - 1;
              return function(a3) {
                return a3 < e4.firstValueMapped ? r4 : a3 >= i3 ? n3 : e4.lut[a3 - e4.firstValueMapped] >> t4;
              };
            }(r3) : function(e4, t4) {
              return function(r4) {
                return 255 * ((r4 - t4) / e4 + 0.5);
              };
            }(e3, t3);
          }
          var Wr = function() {
            function e3() {
              M2(this, e3), V2(this, "m", void 0), this.reset();
            }
            return T2(e3, [{ key: "getMatrix", value: function() {
              return this.m;
            } }, { key: "reset", value: function() {
              this.m = [1, 0, 0, 1, 0, 0];
            } }, { key: "clone", value: function() {
              var t3 = new e3();
              return t3.m[0] = this.m[0], t3.m[1] = this.m[1], t3.m[2] = this.m[2], t3.m[3] = this.m[3], t3.m[4] = this.m[4], t3.m[5] = this.m[5], t3;
            } }, { key: "multiply", value: function(e4) {
              var t3 = this.m[0] * e4[0] + this.m[2] * e4[1], r3 = this.m[1] * e4[0] + this.m[3] * e4[1], n3 = this.m[0] * e4[2] + this.m[2] * e4[3], i3 = this.m[1] * e4[2] + this.m[3] * e4[3], a3 = this.m[0] * e4[4] + this.m[2] * e4[5] + this.m[4], o3 = this.m[1] * e4[4] + this.m[3] * e4[5] + this.m[5];
              this.m[0] = t3, this.m[1] = r3, this.m[2] = n3, this.m[3] = i3, this.m[4] = a3, this.m[5] = o3;
            } }, { key: "invert", value: function() {
              var e4 = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), t3 = this.m[3] * e4, r3 = -this.m[1] * e4, n3 = -this.m[2] * e4, i3 = this.m[0] * e4, a3 = e4 * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), o3 = e4 * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
              this.m[0] = t3, this.m[1] = r3, this.m[2] = n3, this.m[3] = i3, this.m[4] = a3, this.m[5] = o3;
            } }, { key: "rotate", value: function(e4) {
              var t3 = Math.cos(e4), r3 = Math.sin(e4), n3 = this.m[0] * t3 + this.m[2] * r3, i3 = this.m[1] * t3 + this.m[3] * r3, a3 = this.m[0] * -r3 + this.m[2] * t3, o3 = this.m[1] * -r3 + this.m[3] * t3;
              this.m[0] = n3, this.m[1] = i3, this.m[2] = a3, this.m[3] = o3;
            } }, { key: "translate", value: function(e4, t3) {
              this.m[4] += this.m[0] * e4 + this.m[2] * t3, this.m[5] += this.m[1] * e4 + this.m[3] * t3;
            } }, { key: "scale", value: function(e4, t3) {
              this.m[0] *= e4, this.m[1] *= e4, this.m[2] *= t3, this.m[3] *= t3;
            } }, { key: "transformPoint", value: function(e4) {
              var t3 = e4[0], r3 = e4[1];
              return [t3 * this.m[0] + r3 * this.m[2] + this.m[4], t3 * this.m[1] + r3 * this.m[3] + this.m[5]];
            } }]), e3;
          }();
          function qr(e3, t3) {
            var r3 = new Wr();
            if (!e3.viewport.displayedArea)
              return r3;
            r3.translate(e3.canvas.width / 2, e3.canvas.height / 2);
            var n3 = e3.viewport.rotation;
            n3 !== 0 && r3.rotate(n3 * Math.PI / 180);
            var i3 = e3.viewport.scale, a3 = e3.viewport.scale, o3 = e3.viewport.displayedArea.brhc.x - (e3.viewport.displayedArea.tlhc.x - 1), s3 = e3.viewport.displayedArea.brhc.y - (e3.viewport.displayedArea.tlhc.y - 1);
            if (e3.viewport.displayedArea.presentationSizeMode === "NONE")
              e3.image.rowPixelSpacing < e3.image.columnPixelSpacing ? i3 *= e3.image.columnPixelSpacing / e3.image.rowPixelSpacing : e3.image.columnPixelSpacing < e3.image.rowPixelSpacing && (a3 *= e3.image.rowPixelSpacing / e3.image.columnPixelSpacing);
            else if (i3 = e3.viewport.displayedArea.columnPixelSpacing, a3 = e3.viewport.displayedArea.rowPixelSpacing, e3.viewport.displayedArea.presentationSizeMode === "SCALE TO FIT") {
              var c3 = e3.canvas.height / (s3 * a3), u3 = e3.canvas.width / (o3 * i3);
              i3 = a3 = Math.min(u3, c3), e3.viewport.displayedArea.rowPixelSpacing < e3.viewport.displayedArea.columnPixelSpacing ? i3 *= e3.viewport.displayedArea.columnPixelSpacing / e3.viewport.displayedArea.rowPixelSpacing : e3.viewport.displayedArea.columnPixelSpacing < e3.viewport.displayedArea.rowPixelSpacing && (a3 *= e3.viewport.displayedArea.rowPixelSpacing / e3.viewport.displayedArea.columnPixelSpacing);
            }
            return r3.scale(i3, a3), n3 !== 0 && r3.rotate(-n3 * Math.PI / 180), r3.translate(e3.viewport.translation.x, e3.viewport.translation.y), n3 !== 0 && r3.rotate(n3 * Math.PI / 180), t3 !== void 0 && r3.scale(t3, t3), e3.viewport.hflip && r3.scale(-1, 1), e3.viewport.vflip && r3.scale(1, -1), r3.translate(-o3 / 2, -s3 / 2), r3;
          }
          function Br(e3, t3, r3) {
            if (e3 === void 0)
              throw new Error("setToPixelCoordinateSystem: parameter enabledElement must not be undefined");
            if (t3 === void 0)
              throw new Error("setToPixelCoordinateSystem: parameter context must not be undefined");
            var n3 = qr(e3, r3).getMatrix();
            t3.setTransform(n3[0], n3[1], n3[2], n3[3], n3[4], n3[5]);
          }
          function zr(e3, t3) {
            var r3 = e3.renderingTools.lastRenderedImageId, n3 = e3.renderingTools.lastRenderedViewport;
            return t3.imageId !== r3 || !n3 || n3.windowCenter !== e3.viewport.voi.windowCenter || n3.windowWidth !== e3.viewport.voi.windowWidth || n3.invert !== e3.viewport.invert || n3.rotation !== e3.viewport.rotation || n3.hflip !== e3.viewport.hflip || n3.vflip !== e3.viewport.vflip || n3.modalityLUT !== e3.viewport.modalityLUT || n3.voiLUT !== e3.viewport.voiLUT || n3.colormap !== e3.viewport.colormap;
          }
          function Hr(e3, t3) {
            var r3 = e3.renderingTools.renderCanvas;
            r3.width = t3.width, r3.height = t3.height;
            var n3 = r3.getContext("2d");
            n3.fillStyle = "white", n3.fillRect(0, 0, r3.width, r3.height);
            var i3 = n3.getImageData(0, 0, t3.width, t3.height);
            e3.renderingTools.renderCanvasContext = n3, e3.renderingTools.renderCanvasData = i3;
          }
          function Kr(e3) {
            var t3 = e3.image.imageId, r3 = e3.viewport, n3 = e3.image.color;
            return e3.renderingTools.lastRenderedImageId = t3, e3.renderingTools.lastRenderedIsColor = n3, e3.renderingTools.lastRenderedViewport = { windowCenter: r3.voi.windowCenter, windowWidth: r3.voi.windowWidth, invert: r3.invert, rotation: r3.rotation, hflip: r3.hflip, vflip: r3.vflip, modalityLUT: r3.modalityLUT, voiLUT: r3.voiLUT, colormap: r3.colormap }, e3.renderingTools;
          }
          function $r(e3, t3, r3) {
            var n3 = e3.renderingTools.lastRenderedIsColor === true;
            e3.renderingTools.renderCanvas && n3 || (e3.renderingTools.renderCanvas = document.createElement("canvas"));
            var i3 = e3.renderingTools.renderCanvas;
            if (e3.viewport.voi.windowWidth === 255 && e3.viewport.voi.windowCenter === 128 && e3.viewport.invert === false && t3.getCanvas && t3.getCanvas())
              return t3.getCanvas();
            if (zr(e3, t3) === false && r3 !== true)
              return i3;
            i3.width === t3.width && i3.height === t3.height || Hr(e3, t3);
            var a3 = Nr(), o3 = function(e4, t4) {
              return e4.cachedLut !== void 0 && e4.cachedLut.windowCenter === t4.voi.windowCenter && e4.cachedLut.windowWidth === t4.voi.windowWidth && e4.cachedLut.invert === t4.invert || (function(e5, t5, r4, n4, i4) {
                var a4 = e5.maxPixelValue, o4 = e5.minPixelValue, s4 = Math.min(o4, 0);
                if (e5.cachedLut === void 0) {
                  var c4 = a4 - s4 + 1;
                  e5.cachedLut = {}, e5.cachedLut.lutArray = new Uint8ClampedArray(c4);
                }
                var u3 = e5.cachedLut.lutArray, l3 = Gr(Array.isArray(t5) ? t5[0] : t5, Array.isArray(r4) ? r4[0] : r4, void 0);
                if (n4 === true)
                  for (var d3 = o4; d3 <= a4; d3++)
                    u3[d3 + -s4] = 255 - l3(d3);
                else
                  for (var h3 = o4; h3 <= a4; h3++)
                    u3[h3 + -s4] = l3(h3);
              }(e4, t4.voi.windowWidth, t4.voi.windowCenter, t4.invert), e4.cachedLut.windowWidth = t4.voi.windowWidth, e4.cachedLut.windowCenter = t4.voi.windowCenter, e4.cachedLut.invert = t4.invert), e4.cachedLut.lutArray;
            }(t3, e3.viewport);
            t3.stats = t3.stats || {}, t3.stats.lastLutGenerateTime = Nr() - a3;
            var s3 = e3.renderingTools.renderCanvasData, c3 = e3.renderingTools.renderCanvasContext;
            return t3.rgba ? function(e4, t4, r4) {
              var n4 = Nr(), i4 = e4.getPixelData();
              e4.stats.lastGetPixelDataTime = Nr() - n4;
              var a4 = e4.minPixelValue, o4 = 0, s4 = 0, c4 = i4.length;
              if (n4 = Nr(), a4 < 0)
                for (; s4 < c4; )
                  r4[o4++] = t4[i4[s4++] + -a4], r4[o4++] = t4[i4[s4++] + -a4], r4[o4++] = t4[i4[s4++] + -a4], r4[o4++] = i4[s4++];
              else
                for (; s4 < c4; )
                  r4[o4++] = t4[i4[s4++]], r4[o4++] = t4[i4[s4++]], r4[o4++] = t4[i4[s4++]], r4[o4++] = i4[s4++];
              e4.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - n4;
            }(t3, o3, s3.data) : function(e4, t4, r4) {
              var n4 = Nr(), i4 = e4.getPixelData();
              e4.stats.lastGetPixelDataTime = Nr() - n4;
              var a4 = e4.minPixelValue, o4 = 0, s4 = 0, c4 = i4.length;
              if (n4 = Nr(), a4 < 0)
                for (; s4 < c4; )
                  r4[o4++] = t4[i4[s4++] + -a4], r4[o4++] = t4[i4[s4++] + -a4], r4[o4] = t4[i4[s4] + -a4], s4 += 2, o4 += 2;
              else
                for (; s4 < c4; )
                  r4[o4++] = t4[i4[s4++]], r4[o4++] = t4[i4[s4++]], r4[o4] = t4[i4[s4]], s4 += 2, o4 += 2;
              e4.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - n4;
            }(t3, o3, s3.data), a3 = Nr(), c3.putImageData(s3, 0, 0), t3.stats.lastPutImageDataTime = Nr() - a3, i3;
          }
          function Xr(e3, t3) {
            if (e3 === void 0)
              throw new Error("renderColorImage: enabledElement parameter must not be undefined");
            var r3 = e3.image;
            if (r3 === void 0)
              throw new Error("renderColorImage: image must be loaded before it can be drawn");
            var n3 = e3.canvas.getContext("2d");
            n3.setTransform(1, 0, 0, 1, 0, 0), n3.fillStyle = "black", n3.fillRect(0, 0, e3.canvas.width, e3.canvas.height), n3.imageSmoothingEnabled = !e3.viewport.pixelReplication, Br(e3, n3);
            var i3 = $r(e3, r3, t3), a3 = e3.viewport.displayedArea.tlhc.x - 1, o3 = e3.viewport.displayedArea.tlhc.y - 1, s3 = e3.viewport.displayedArea.brhc.x - a3, c3 = e3.viewport.displayedArea.brhc.y - o3;
            n3.drawImage(i3, a3, o3, s3, c3, 0, 0, s3, c3), e3.renderingTools = Kr(e3);
          }
          function Yr(e3, t3, r3) {
            var n3 = Nr(), i3 = e3.getPixelData();
            e3.stats.lastGetPixelDataTime = Nr() - n3;
            var a3 = i3.length, o3 = e3.minPixelValue, s3 = 3, c3 = 0;
            if (n3 = Nr(), i3 instanceof Int16Array)
              if (o3 < 0)
                for (; c3 < a3; )
                  r3[s3] = t3[i3[c3++] + -o3], s3 += 4;
              else
                for (; c3 < a3; )
                  r3[s3] = t3[i3[c3++]], s3 += 4;
            else if (i3 instanceof Uint16Array)
              for (; c3 < a3; )
                r3[s3] = t3[i3[c3++]], s3 += 4;
            else if (o3 < 0)
              for (; c3 < a3; )
                r3[s3] = t3[i3[c3++] + -o3], s3 += 4;
            else
              for (; c3 < a3; )
                r3[s3] = t3[i3[c3++]], s3 += 4;
            e3.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - n3;
          }
          function Zr(e3, t3, r3) {
            var n3 = Nr(), i3 = e3.getPixelData();
            e3.stats.lastGetPixelDataTime = Nr() - n3;
            var a3 = i3.length, o3 = 3, s3 = 0;
            for (n3 = Nr(); s3 < a3; )
              r3[o3] = t3(i3[s3++]), o3 += 4;
            e3.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - n3;
          }
          function Jr(e3, t3, r3) {
            var n3 = Nr(), i3 = e3.getPixelData();
            e3.stats.lastGetPixelDataTime = Nr() - n3;
            var a3, o3 = i3.length, s3 = e3.minPixelValue, c3 = 0, u3 = 0;
            if (n3 = Nr(), i3 instanceof Int16Array)
              if (s3 < 0)
                for (; u3 < o3; )
                  a3 = t3[i3[u3++] + -s3], r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = 255;
              else
                for (; u3 < o3; )
                  a3 = t3[i3[u3++]], r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = 255;
            else if (i3 instanceof Uint16Array)
              for (; u3 < o3; )
                a3 = t3[i3[u3++]], r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = 255;
            else if (s3 < 0)
              for (; u3 < o3; )
                a3 = t3[i3[u3++] + -s3], r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = 255;
            else
              for (; u3 < o3; )
                a3 = t3[i3[u3++]], r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = a3, r3[c3++] = 255;
            e3.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - n3;
          }
          function Qr(e3, t3) {
            return !e3 && !t3 || !(!e3 || !t3) && e3.id === t3.id;
          }
          function en(e3, t3, r3) {
            return e3.cachedLut !== void 0 && e3.cachedLut.windowCenter === t3.voi.windowCenter && e3.cachedLut.windowWidth === t3.voi.windowWidth && Qr(e3.cachedLut.modalityLUT, t3.modalityLUT) && Qr(e3.cachedLut.voiLUT, t3.voiLUT) && e3.cachedLut.invert === t3.invert && r3 !== true || (function(e4, t4) {
              if (!function(e5) {
                return e5.voiLUT && e5.voiLUT.lut && e5.voiLUT.lut.length > 0 || e5.voi.windowWidth !== void 0 && e5.voi.windowCenter !== void 0;
              }(e4)) {
                var r4 = t4.maxPixelValue * t4.slope + t4.intercept, n3 = t4.minPixelValue * t4.slope + t4.intercept, i3 = r4 - n3, a3 = (r4 + n3) / 2;
                e4.voi === void 0 ? e4.voi = { windowWidth: i3, windowCenter: a3 } : (e4.voi.windowWidth = i3, e4.voi.windowCenter = a3);
              }
            }(t3, e3), function(e4, t4, r4, n3, i3, a3) {
              var o3 = e4.maxPixelValue, s3 = e4.minPixelValue, c3 = Math.min(s3, 0);
              if (e4.cachedLut === void 0) {
                var u3 = o3 - c3 + 1;
                e4.cachedLut = {}, e4.cachedLut.lutArray = new Uint8ClampedArray(u3);
              }
              var l3 = e4.cachedLut.lutArray, d3 = function(e5, t5, r5) {
                return r5 ? function(e6) {
                  var t6 = e6.lut[0], r6 = e6.lut[e6.lut.length - 1], n4 = e6.firstValueMapped + e6.lut.length;
                  return function(i4) {
                    return i4 < e6.firstValueMapped ? t6 : i4 >= n4 ? r6 : e6.lut[i4];
                  };
                }(r5) : function(e6, t6) {
                  return function(r6) {
                    return r6 * e6 + t6;
                  };
                }(e5, t5);
              }(e4.slope, e4.intercept, i3), h3 = Gr(t4, r4, a3);
              if (n3 === true)
                for (var f3 = s3; f3 <= o3; f3++)
                  l3[f3 + -c3] = 255 - h3(d3(f3));
              else
                for (var v3 = s3; v3 <= o3; v3++)
                  l3[v3 + -c3] = h3(d3(v3));
            }(e3, t3.voi.windowWidth, t3.voi.windowCenter, t3.invert, t3.modalityLUT, t3.voiLUT), e3.cachedLut.windowWidth = t3.voi.windowWidth, e3.cachedLut.windowCenter = t3.voi.windowCenter, e3.cachedLut.invert = t3.invert, e3.cachedLut.voiLUT = t3.voiLUT, e3.cachedLut.modalityLUT = t3.modalityLUT), e3.cachedLut.lutArray;
          }
          function tn(e3, t3) {
            if (e3 === void 0)
              throw new Error("drawImage: enabledElement parameter must not be undefined");
            var r3 = e3.image;
            if (r3 === void 0)
              throw new Error("drawImage: image must be loaded before it can be drawn");
            var n3 = e3.canvas.getContext("2d");
            n3.setTransform(1, 0, 0, 1, 0, 0), n3.fillStyle = "black", n3.fillRect(0, 0, e3.canvas.width, e3.canvas.height), n3.imageSmoothingEnabled = !e3.viewport.pixelReplication, Br(e3, n3);
            var i3 = function(e4, t4, r4) {
              var n4 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3], i4 = e4.renderingTools.lastRenderedIsColor === true;
              e4.renderingTools.renderCanvas && !i4 || (e4.renderingTools.renderCanvas = document.createElement("canvas"), Hr(e4, t4));
              var a4 = e4.renderingTools.renderCanvas;
              if (zr(e4, t4) === false && r4 !== true)
                return a4;
              a4.width === t4.width && a4.height === t4.height || Hr(e4, t4), t4.stats = t4.stats || {};
              var o4 = e4.renderingTools.renderCanvasData, s4 = e4.renderingTools.renderCanvasContext, c4 = Nr();
              t4.stats.lastLutGenerateTime = Nr() - c4;
              var u3 = e4.viewport;
              if (u3.modality === "PT") {
                var l3 = u3.voi, d3 = l3.windowWidth, h3 = l3.windowCenter, f3 = h3 - d3 / 2, v3 = 255 / (h3 + d3 / 2 - f3);
                Zr(t4, u3.invert ? function(e5) {
                  return 255 - (e5 - f3) * v3;
                } : function(e5) {
                  return (e5 - f3) * v3;
                }, o4.data);
              } else {
                var p3 = en(t4, u3, r4);
                n4 ? Yr(t4, p3, o4.data) : Jr(t4, p3, o4.data);
              }
              return c4 = Nr(), s4.putImageData(o4, 0, 0), t4.stats.lastPutImageDataTime = Nr() - c4, a4;
            }(e3, r3, t3), a3 = e3.viewport.displayedArea.tlhc.x - 1, o3 = e3.viewport.displayedArea.tlhc.y - 1, s3 = e3.viewport.displayedArea.brhc.x - a3, c3 = e3.viewport.displayedArea.brhc.y - o3;
            n3.drawImage(i3, a3, o3, s3, c3, 0, 0, s3, c3), e3.renderingTools = Kr(e3);
          }
          function rn(e3, t3, r3) {
            if (e3 > 1)
              throw new Error("HSVToRGB expects hue < 1");
            var n3 = [];
            if (t3 === 0)
              return n3[0] = r3, n3[1] = r3, n3[2] = r3, n3;
            var i3 = Math.floor(6 * e3), a3 = 6 * e3 - i3, o3 = r3 * (1 - t3), s3 = r3 * (1 - t3 * a3), c3 = r3 * (1 - t3 * (1 - a3));
            switch (i3) {
              case 0:
              case 6:
                n3[0] = r3, n3[1] = c3, n3[2] = o3;
                break;
              case 1:
                n3[0] = s3, n3[1] = r3, n3[2] = o3;
                break;
              case 2:
                n3[0] = o3, n3[1] = r3, n3[2] = c3;
                break;
              case 3:
                n3[0] = o3, n3[1] = s3, n3[2] = r3;
                break;
              case 4:
                n3[0] = c3, n3[1] = o3, n3[2] = r3;
                break;
              case 5:
                n3[0] = r3, n3[1] = o3, n3[2] = s3;
            }
            return n3;
          }
          var nn = function() {
            function e3() {
              M2(this, e3), V2(this, "NumberOfColors", void 0), V2(this, "Ramp", void 0), V2(this, "TableRange", void 0), V2(this, "HueRange", void 0), V2(this, "SaturationRange", void 0), V2(this, "ValueRange", void 0), V2(this, "AlphaRange", void 0), V2(this, "NaNColor", void 0), V2(this, "BelowRangeColor", void 0), V2(this, "UseBelowRangeColor", void 0), V2(this, "AboveRangeColor", void 0), V2(this, "UseAboveRangeColor", void 0), V2(this, "InputRange", void 0), V2(this, "Table", void 0), this.NumberOfColors = 256, this.Ramp = "linear", this.TableRange = [0, 255], this.HueRange = [0, 0.66667], this.SaturationRange = [1, 1], this.ValueRange = [1, 1], this.AlphaRange = [1, 1], this.NaNColor = [128, 0, 0, 255], this.BelowRangeColor = [0, 0, 0, 255], this.UseBelowRangeColor = true, this.AboveRangeColor = [255, 255, 255, 255], this.UseAboveRangeColor = true, this.InputRange = [0, 255], this.Table = [];
            }
            return T2(e3, [{ key: "setNumberOfTableValues", value: function(e4) {
              this.NumberOfColors = e4;
            } }, { key: "setRamp", value: function(e4) {
              this.Ramp = e4;
            } }, { key: "setTableRange", value: function(e4, t3) {
              this.TableRange[0] = e4, this.TableRange[1] = t3;
            } }, { key: "setHueRange", value: function(e4, t3) {
              this.HueRange[0] = e4, this.HueRange[1] = t3;
            } }, { key: "setSaturationRange", value: function(e4, t3) {
              this.SaturationRange[0] = e4, this.SaturationRange[1] = t3;
            } }, { key: "setValueRange", value: function(e4, t3) {
              this.ValueRange[0] = e4, this.ValueRange[1] = t3;
            } }, { key: "setRange", value: function(e4, t3) {
              this.InputRange[0] = e4, this.InputRange[1] = t3;
            } }, { key: "setAlphaRange", value: function(e4, t3) {
              this.AlphaRange[0] = e4, this.AlphaRange[1] = t3;
            } }, { key: "getColor", value: function(e4) {
              return this.mapValue(e4);
            } }, { key: "build", value: function(e4) {
              if (!(this.Table.length > 1) || e4) {
                this.Table = [];
                var t3, r3, n3, i3, a3 = this.NumberOfColors - 1;
                a3 ? (t3 = (this.HueRange[1] - this.HueRange[0]) / a3, r3 = (this.SaturationRange[1] - this.SaturationRange[0]) / a3, n3 = (this.ValueRange[1] - this.ValueRange[0]) / a3, i3 = (this.AlphaRange[1] - this.AlphaRange[0]) / a3) : t3 = r3 = n3 = i3 = 0;
                for (var o3 = 0; o3 <= a3; o3++) {
                  var s3 = this.HueRange[0] + o3 * t3, c3 = this.SaturationRange[0] + o3 * r3, u3 = this.ValueRange[0] + o3 * n3, l3 = this.AlphaRange[0] + o3 * i3, d3 = rn(s3, c3, u3), h3 = [0, 0, 0, 0];
                  switch (this.Ramp) {
                    case "scurve":
                      h3[0] = Math.floor(127.5 * (1 + Math.cos((1 - d3[0]) * Math.PI))), h3[1] = Math.floor(127.5 * (1 + Math.cos((1 - d3[1]) * Math.PI))), h3[2] = Math.floor(127.5 * (1 + Math.cos((1 - d3[2]) * Math.PI))), h3[3] = Math.floor(255 * l3);
                      break;
                    case "linear":
                      h3[0] = Math.floor(255 * d3[0] + 0.5), h3[1] = Math.floor(255 * d3[1] + 0.5), h3[2] = Math.floor(255 * d3[2] + 0.5), h3[3] = Math.floor(255 * l3 + 0.5);
                      break;
                    case "sqrt":
                      h3[0] = Math.floor(255 * Math.sqrt(d3[0]) + 0.5), h3[1] = Math.floor(255 * Math.sqrt(d3[1]) + 0.5), h3[2] = Math.floor(255 * Math.sqrt(d3[2]) + 0.5), h3[3] = Math.floor(255 * Math.sqrt(l3) + 0.5);
                      break;
                    default:
                      throw new Error("Invalid Ramp value (".concat(this.Ramp, ")"));
                  }
                  this.Table.push(h3);
                }
                this.buildSpecialColors();
              }
            } }, { key: "buildSpecialColors", value: function() {
              var e4 = this.NumberOfColors, t3 = e4 + 0, r3 = e4 + 1, n3 = e4 + 2;
              this.UseBelowRangeColor || e4 === 0 ? this.Table[t3] = this.BelowRangeColor : this.Table[t3] = this.Table[0], this.UseAboveRangeColor || e4 === 0 ? this.Table[r3] = this.AboveRangeColor : this.Table[r3] = this.Table[e4 - 1], this.Table[n3] = this.NaNColor;
            } }, { key: "mapValue", value: function(e4) {
              var t3 = this.getIndex(e4);
              if (t3 < 0)
                return this.NaNColor;
              if (t3 === 0) {
                if (this.UseBelowRangeColor && e4 < this.TableRange[0])
                  return this.BelowRangeColor;
              } else if (t3 === this.NumberOfColors - 1 && this.UseAboveRangeColor && e4 > this.TableRange[1])
                return this.AboveRangeColor;
              return this.Table[t3];
            } }, { key: "getIndex", value: function(e4) {
              var t3 = { Range: [], MaxIndex: this.NumberOfColors - 1, Shift: -this.TableRange[0], Scale: 1 };
              if (this.TableRange[1] <= this.TableRange[0] ? t3.Scale = Number.MAX_VALUE : t3.Scale = t3.MaxIndex / (this.TableRange[1] - this.TableRange[0]), t3.Range[0] = this.TableRange[0], t3.Range[1] = this.TableRange[1], isNaN(e4))
                return -1;
              var r3 = function(e5, t4) {
                var r4;
                return r4 = e5 < t4.Range[0] ? t4.MaxIndex + 0 + 1.5 : e5 > t4.Range[1] ? t4.MaxIndex + 1 + 1.5 : (e5 + t4.Shift) * t4.Scale, Math.floor(r4);
              }(e4, t3);
              return r3 === this.NumberOfColors + 0 ? r3 = 0 : r3 === this.NumberOfColors + 1 && (r3 = this.NumberOfColors - 1), r3;
            } }, { key: "setTableValue", value: function(e4, t3) {
              if (arguments.length === 5 && (t3 = Array.prototype.slice.call(arguments, 1)), e4 < 0)
                throw new Error("Can't set the table value for negative index (".concat(e4, ")"));
              e4 >= this.NumberOfColors && new Error("Index ".concat(e4, " is greater than the number of colors ").concat(this.NumberOfColors)), this.Table[e4] = t3, e4 !== 0 && e4 !== this.NumberOfColors - 1 || this.buildSpecialColors();
            } }]), e3;
          }(), an = nn, on = { hotIron: { name: "Hot Iron", numOfColors: 256, colors: [[0, 0, 0, 255], [2, 0, 0, 255], [4, 0, 0, 255], [6, 0, 0, 255], [8, 0, 0, 255], [10, 0, 0, 255], [12, 0, 0, 255], [14, 0, 0, 255], [16, 0, 0, 255], [18, 0, 0, 255], [20, 0, 0, 255], [22, 0, 0, 255], [24, 0, 0, 255], [26, 0, 0, 255], [28, 0, 0, 255], [30, 0, 0, 255], [32, 0, 0, 255], [34, 0, 0, 255], [36, 0, 0, 255], [38, 0, 0, 255], [40, 0, 0, 255], [42, 0, 0, 255], [44, 0, 0, 255], [46, 0, 0, 255], [48, 0, 0, 255], [50, 0, 0, 255], [52, 0, 0, 255], [54, 0, 0, 255], [56, 0, 0, 255], [58, 0, 0, 255], [60, 0, 0, 255], [62, 0, 0, 255], [64, 0, 0, 255], [66, 0, 0, 255], [68, 0, 0, 255], [70, 0, 0, 255], [72, 0, 0, 255], [74, 0, 0, 255], [76, 0, 0, 255], [78, 0, 0, 255], [80, 0, 0, 255], [82, 0, 0, 255], [84, 0, 0, 255], [86, 0, 0, 255], [88, 0, 0, 255], [90, 0, 0, 255], [92, 0, 0, 255], [94, 0, 0, 255], [96, 0, 0, 255], [98, 0, 0, 255], [100, 0, 0, 255], [102, 0, 0, 255], [104, 0, 0, 255], [106, 0, 0, 255], [108, 0, 0, 255], [110, 0, 0, 255], [112, 0, 0, 255], [114, 0, 0, 255], [116, 0, 0, 255], [118, 0, 0, 255], [120, 0, 0, 255], [122, 0, 0, 255], [124, 0, 0, 255], [126, 0, 0, 255], [128, 0, 0, 255], [130, 0, 0, 255], [132, 0, 0, 255], [134, 0, 0, 255], [136, 0, 0, 255], [138, 0, 0, 255], [140, 0, 0, 255], [142, 0, 0, 255], [144, 0, 0, 255], [146, 0, 0, 255], [148, 0, 0, 255], [150, 0, 0, 255], [152, 0, 0, 255], [154, 0, 0, 255], [156, 0, 0, 255], [158, 0, 0, 255], [160, 0, 0, 255], [162, 0, 0, 255], [164, 0, 0, 255], [166, 0, 0, 255], [168, 0, 0, 255], [170, 0, 0, 255], [172, 0, 0, 255], [174, 0, 0, 255], [176, 0, 0, 255], [178, 0, 0, 255], [180, 0, 0, 255], [182, 0, 0, 255], [184, 0, 0, 255], [186, 0, 0, 255], [188, 0, 0, 255], [190, 0, 0, 255], [192, 0, 0, 255], [194, 0, 0, 255], [196, 0, 0, 255], [198, 0, 0, 255], [200, 0, 0, 255], [202, 0, 0, 255], [204, 0, 0, 255], [206, 0, 0, 255], [208, 0, 0, 255], [210, 0, 0, 255], [212, 0, 0, 255], [214, 0, 0, 255], [216, 0, 0, 255], [218, 0, 0, 255], [220, 0, 0, 255], [222, 0, 0, 255], [224, 0, 0, 255], [226, 0, 0, 255], [228, 0, 0, 255], [230, 0, 0, 255], [232, 0, 0, 255], [234, 0, 0, 255], [236, 0, 0, 255], [238, 0, 0, 255], [240, 0, 0, 255], [242, 0, 0, 255], [244, 0, 0, 255], [246, 0, 0, 255], [248, 0, 0, 255], [250, 0, 0, 255], [252, 0, 0, 255], [254, 0, 0, 255], [255, 0, 0, 255], [255, 2, 0, 255], [255, 4, 0, 255], [255, 6, 0, 255], [255, 8, 0, 255], [255, 10, 0, 255], [255, 12, 0, 255], [255, 14, 0, 255], [255, 16, 0, 255], [255, 18, 0, 255], [255, 20, 0, 255], [255, 22, 0, 255], [255, 24, 0, 255], [255, 26, 0, 255], [255, 28, 0, 255], [255, 30, 0, 255], [255, 32, 0, 255], [255, 34, 0, 255], [255, 36, 0, 255], [255, 38, 0, 255], [255, 40, 0, 255], [255, 42, 0, 255], [255, 44, 0, 255], [255, 46, 0, 255], [255, 48, 0, 255], [255, 50, 0, 255], [255, 52, 0, 255], [255, 54, 0, 255], [255, 56, 0, 255], [255, 58, 0, 255], [255, 60, 0, 255], [255, 62, 0, 255], [255, 64, 0, 255], [255, 66, 0, 255], [255, 68, 0, 255], [255, 70, 0, 255], [255, 72, 0, 255], [255, 74, 0, 255], [255, 76, 0, 255], [255, 78, 0, 255], [255, 80, 0, 255], [255, 82, 0, 255], [255, 84, 0, 255], [255, 86, 0, 255], [255, 88, 0, 255], [255, 90, 0, 255], [255, 92, 0, 255], [255, 94, 0, 255], [255, 96, 0, 255], [255, 98, 0, 255], [255, 100, 0, 255], [255, 102, 0, 255], [255, 104, 0, 255], [255, 106, 0, 255], [255, 108, 0, 255], [255, 110, 0, 255], [255, 112, 0, 255], [255, 114, 0, 255], [255, 116, 0, 255], [255, 118, 0, 255], [255, 120, 0, 255], [255, 122, 0, 255], [255, 124, 0, 255], [255, 126, 0, 255], [255, 128, 4, 255], [255, 130, 8, 255], [255, 132, 12, 255], [255, 134, 16, 255], [255, 136, 20, 255], [255, 138, 24, 255], [255, 140, 28, 255], [255, 142, 32, 255], [255, 144, 36, 255], [255, 146, 40, 255], [255, 148, 44, 255], [255, 150, 48, 255], [255, 152, 52, 255], [255, 154, 56, 255], [255, 156, 60, 255], [255, 158, 64, 255], [255, 160, 68, 255], [255, 162, 72, 255], [255, 164, 76, 255], [255, 166, 80, 255], [255, 168, 84, 255], [255, 170, 88, 255], [255, 172, 92, 255], [255, 174, 96, 255], [255, 176, 100, 255], [255, 178, 104, 255], [255, 180, 108, 255], [255, 182, 112, 255], [255, 184, 116, 255], [255, 186, 120, 255], [255, 188, 124, 255], [255, 190, 128, 255], [255, 192, 132, 255], [255, 194, 136, 255], [255, 196, 140, 255], [255, 198, 144, 255], [255, 200, 148, 255], [255, 202, 152, 255], [255, 204, 156, 255], [255, 206, 160, 255], [255, 208, 164, 255], [255, 210, 168, 255], [255, 212, 172, 255], [255, 214, 176, 255], [255, 216, 180, 255], [255, 218, 184, 255], [255, 220, 188, 255], [255, 222, 192, 255], [255, 224, 196, 255], [255, 226, 200, 255], [255, 228, 204, 255], [255, 230, 208, 255], [255, 232, 212, 255], [255, 234, 216, 255], [255, 236, 220, 255], [255, 238, 224, 255], [255, 240, 228, 255], [255, 242, 232, 255], [255, 244, 236, 255], [255, 246, 240, 255], [255, 248, 244, 255], [255, 250, 248, 255], [255, 252, 252, 255], [255, 255, 255, 255]] }, pet: { name: "PET", numColors: 256, colors: [[0, 0, 0, 255], [0, 2, 1, 255], [0, 4, 3, 255], [0, 6, 5, 255], [0, 8, 7, 255], [0, 10, 9, 255], [0, 12, 11, 255], [0, 14, 13, 255], [0, 16, 15, 255], [0, 18, 17, 255], [0, 20, 19, 255], [0, 22, 21, 255], [0, 24, 23, 255], [0, 26, 25, 255], [0, 28, 27, 255], [0, 30, 29, 255], [0, 32, 31, 255], [0, 34, 33, 255], [0, 36, 35, 255], [0, 38, 37, 255], [0, 40, 39, 255], [0, 42, 41, 255], [0, 44, 43, 255], [0, 46, 45, 255], [0, 48, 47, 255], [0, 50, 49, 255], [0, 52, 51, 255], [0, 54, 53, 255], [0, 56, 55, 255], [0, 58, 57, 255], [0, 60, 59, 255], [0, 62, 61, 255], [0, 65, 63, 255], [0, 67, 65, 255], [0, 69, 67, 255], [0, 71, 69, 255], [0, 73, 71, 255], [0, 75, 73, 255], [0, 77, 75, 255], [0, 79, 77, 255], [0, 81, 79, 255], [0, 83, 81, 255], [0, 85, 83, 255], [0, 87, 85, 255], [0, 89, 87, 255], [0, 91, 89, 255], [0, 93, 91, 255], [0, 95, 93, 255], [0, 97, 95, 255], [0, 99, 97, 255], [0, 101, 99, 255], [0, 103, 101, 255], [0, 105, 103, 255], [0, 107, 105, 255], [0, 109, 107, 255], [0, 111, 109, 255], [0, 113, 111, 255], [0, 115, 113, 255], [0, 117, 115, 255], [0, 119, 117, 255], [0, 121, 119, 255], [0, 123, 121, 255], [0, 125, 123, 255], [0, 128, 125, 255], [1, 126, 127, 255], [3, 124, 129, 255], [5, 122, 131, 255], [7, 120, 133, 255], [9, 118, 135, 255], [11, 116, 137, 255], [13, 114, 139, 255], [15, 112, 141, 255], [17, 110, 143, 255], [19, 108, 145, 255], [21, 106, 147, 255], [23, 104, 149, 255], [25, 102, 151, 255], [27, 100, 153, 255], [29, 98, 155, 255], [31, 96, 157, 255], [33, 94, 159, 255], [35, 92, 161, 255], [37, 90, 163, 255], [39, 88, 165, 255], [41, 86, 167, 255], [43, 84, 169, 255], [45, 82, 171, 255], [47, 80, 173, 255], [49, 78, 175, 255], [51, 76, 177, 255], [53, 74, 179, 255], [55, 72, 181, 255], [57, 70, 183, 255], [59, 68, 185, 255], [61, 66, 187, 255], [63, 64, 189, 255], [65, 63, 191, 255], [67, 61, 193, 255], [69, 59, 195, 255], [71, 57, 197, 255], [73, 55, 199, 255], [75, 53, 201, 255], [77, 51, 203, 255], [79, 49, 205, 255], [81, 47, 207, 255], [83, 45, 209, 255], [85, 43, 211, 255], [86, 41, 213, 255], [88, 39, 215, 255], [90, 37, 217, 255], [92, 35, 219, 255], [94, 33, 221, 255], [96, 31, 223, 255], [98, 29, 225, 255], [100, 27, 227, 255], [102, 25, 229, 255], [104, 23, 231, 255], [106, 21, 233, 255], [108, 19, 235, 255], [110, 17, 237, 255], [112, 15, 239, 255], [114, 13, 241, 255], [116, 11, 243, 255], [118, 9, 245, 255], [120, 7, 247, 255], [122, 5, 249, 255], [124, 3, 251, 255], [126, 1, 253, 255], [128, 0, 255, 255], [130, 2, 252, 255], [132, 4, 248, 255], [134, 6, 244, 255], [136, 8, 240, 255], [138, 10, 236, 255], [140, 12, 232, 255], [142, 14, 228, 255], [144, 16, 224, 255], [146, 18, 220, 255], [148, 20, 216, 255], [150, 22, 212, 255], [152, 24, 208, 255], [154, 26, 204, 255], [156, 28, 200, 255], [158, 30, 196, 255], [160, 32, 192, 255], [162, 34, 188, 255], [164, 36, 184, 255], [166, 38, 180, 255], [168, 40, 176, 255], [170, 42, 172, 255], [171, 44, 168, 255], [173, 46, 164, 255], [175, 48, 160, 255], [177, 50, 156, 255], [179, 52, 152, 255], [181, 54, 148, 255], [183, 56, 144, 255], [185, 58, 140, 255], [187, 60, 136, 255], [189, 62, 132, 255], [191, 64, 128, 255], [193, 66, 124, 255], [195, 68, 120, 255], [197, 70, 116, 255], [199, 72, 112, 255], [201, 74, 108, 255], [203, 76, 104, 255], [205, 78, 100, 255], [207, 80, 96, 255], [209, 82, 92, 255], [211, 84, 88, 255], [213, 86, 84, 255], [215, 88, 80, 255], [217, 90, 76, 255], [219, 92, 72, 255], [221, 94, 68, 255], [223, 96, 64, 255], [225, 98, 60, 255], [227, 100, 56, 255], [229, 102, 52, 255], [231, 104, 48, 255], [233, 106, 44, 255], [235, 108, 40, 255], [237, 110, 36, 255], [239, 112, 32, 255], [241, 114, 28, 255], [243, 116, 24, 255], [245, 118, 20, 255], [247, 120, 16, 255], [249, 122, 12, 255], [251, 124, 8, 255], [253, 126, 4, 255], [255, 128, 0, 255], [255, 130, 4, 255], [255, 132, 8, 255], [255, 134, 12, 255], [255, 136, 16, 255], [255, 138, 20, 255], [255, 140, 24, 255], [255, 142, 28, 255], [255, 144, 32, 255], [255, 146, 36, 255], [255, 148, 40, 255], [255, 150, 44, 255], [255, 152, 48, 255], [255, 154, 52, 255], [255, 156, 56, 255], [255, 158, 60, 255], [255, 160, 64, 255], [255, 162, 68, 255], [255, 164, 72, 255], [255, 166, 76, 255], [255, 168, 80, 255], [255, 170, 85, 255], [255, 172, 89, 255], [255, 174, 93, 255], [255, 176, 97, 255], [255, 178, 101, 255], [255, 180, 105, 255], [255, 182, 109, 255], [255, 184, 113, 255], [255, 186, 117, 255], [255, 188, 121, 255], [255, 190, 125, 255], [255, 192, 129, 255], [255, 194, 133, 255], [255, 196, 137, 255], [255, 198, 141, 255], [255, 200, 145, 255], [255, 202, 149, 255], [255, 204, 153, 255], [255, 206, 157, 255], [255, 208, 161, 255], [255, 210, 165, 255], [255, 212, 170, 255], [255, 214, 174, 255], [255, 216, 178, 255], [255, 218, 182, 255], [255, 220, 186, 255], [255, 222, 190, 255], [255, 224, 194, 255], [255, 226, 198, 255], [255, 228, 202, 255], [255, 230, 206, 255], [255, 232, 210, 255], [255, 234, 214, 255], [255, 236, 218, 255], [255, 238, 222, 255], [255, 240, 226, 255], [255, 242, 230, 255], [255, 244, 234, 255], [255, 246, 238, 255], [255, 248, 242, 255], [255, 250, 246, 255], [255, 252, 250, 255], [255, 255, 255, 255]] }, hotMetalBlue: { name: "Hot Metal Blue", numColors: 256, colors: [[0, 0, 0, 255], [0, 0, 2, 255], [0, 0, 4, 255], [0, 0, 6, 255], [0, 0, 8, 255], [0, 0, 10, 255], [0, 0, 12, 255], [0, 0, 14, 255], [0, 0, 16, 255], [0, 0, 17, 255], [0, 0, 19, 255], [0, 0, 21, 255], [0, 0, 23, 255], [0, 0, 25, 255], [0, 0, 27, 255], [0, 0, 29, 255], [0, 0, 31, 255], [0, 0, 33, 255], [0, 0, 35, 255], [0, 0, 37, 255], [0, 0, 39, 255], [0, 0, 41, 255], [0, 0, 43, 255], [0, 0, 45, 255], [0, 0, 47, 255], [0, 0, 49, 255], [0, 0, 51, 255], [0, 0, 53, 255], [0, 0, 55, 255], [0, 0, 57, 255], [0, 0, 59, 255], [0, 0, 61, 255], [0, 0, 63, 255], [0, 0, 65, 255], [0, 0, 67, 255], [0, 0, 69, 255], [0, 0, 71, 255], [0, 0, 73, 255], [0, 0, 75, 255], [0, 0, 77, 255], [0, 0, 79, 255], [0, 0, 81, 255], [0, 0, 83, 255], [0, 0, 84, 255], [0, 0, 86, 255], [0, 0, 88, 255], [0, 0, 90, 255], [0, 0, 92, 255], [0, 0, 94, 255], [0, 0, 96, 255], [0, 0, 98, 255], [0, 0, 100, 255], [0, 0, 102, 255], [0, 0, 104, 255], [0, 0, 106, 255], [0, 0, 108, 255], [0, 0, 110, 255], [0, 0, 112, 255], [0, 0, 114, 255], [0, 0, 116, 255], [0, 0, 117, 255], [0, 0, 119, 255], [0, 0, 121, 255], [0, 0, 123, 255], [0, 0, 125, 255], [0, 0, 127, 255], [0, 0, 129, 255], [0, 0, 131, 255], [0, 0, 133, 255], [0, 0, 135, 255], [0, 0, 137, 255], [0, 0, 139, 255], [0, 0, 141, 255], [0, 0, 143, 255], [0, 0, 145, 255], [0, 0, 147, 255], [0, 0, 149, 255], [0, 0, 151, 255], [0, 0, 153, 255], [0, 0, 155, 255], [0, 0, 157, 255], [0, 0, 159, 255], [0, 0, 161, 255], [0, 0, 163, 255], [0, 0, 165, 255], [0, 0, 167, 255], [3, 0, 169, 255], [6, 0, 171, 255], [9, 0, 173, 255], [12, 0, 175, 255], [15, 0, 177, 255], [18, 0, 179, 255], [21, 0, 181, 255], [24, 0, 183, 255], [26, 0, 184, 255], [29, 0, 186, 255], [32, 0, 188, 255], [35, 0, 190, 255], [38, 0, 192, 255], [41, 0, 194, 255], [44, 0, 196, 255], [47, 0, 198, 255], [50, 0, 200, 255], [52, 0, 197, 255], [55, 0, 194, 255], [57, 0, 191, 255], [59, 0, 188, 255], [62, 0, 185, 255], [64, 0, 182, 255], [66, 0, 179, 255], [69, 0, 176, 255], [71, 0, 174, 255], [74, 0, 171, 255], [76, 0, 168, 255], [78, 0, 165, 255], [81, 0, 162, 255], [83, 0, 159, 255], [85, 0, 156, 255], [88, 0, 153, 255], [90, 0, 150, 255], [93, 2, 144, 255], [96, 4, 138, 255], [99, 6, 132, 255], [102, 8, 126, 255], [105, 9, 121, 255], [108, 11, 115, 255], [111, 13, 109, 255], [114, 15, 103, 255], [116, 17, 97, 255], [119, 19, 91, 255], [122, 21, 85, 255], [125, 23, 79, 255], [128, 24, 74, 255], [131, 26, 68, 255], [134, 28, 62, 255], [137, 30, 56, 255], [140, 32, 50, 255], [143, 34, 47, 255], [146, 36, 44, 255], [149, 38, 41, 255], [152, 40, 38, 255], [155, 41, 35, 255], [158, 43, 32, 255], [161, 45, 29, 255], [164, 47, 26, 255], [166, 49, 24, 255], [169, 51, 21, 255], [172, 53, 18, 255], [175, 55, 15, 255], [178, 56, 12, 255], [181, 58, 9, 255], [184, 60, 6, 255], [187, 62, 3, 255], [190, 64, 0, 255], [194, 66, 0, 255], [198, 68, 0, 255], [201, 70, 0, 255], [205, 72, 0, 255], [209, 73, 0, 255], [213, 75, 0, 255], [217, 77, 0, 255], [221, 79, 0, 255], [224, 81, 0, 255], [228, 83, 0, 255], [232, 85, 0, 255], [236, 87, 0, 255], [240, 88, 0, 255], [244, 90, 0, 255], [247, 92, 0, 255], [251, 94, 0, 255], [255, 96, 0, 255], [255, 98, 3, 255], [255, 100, 6, 255], [255, 102, 9, 255], [255, 104, 12, 255], [255, 105, 15, 255], [255, 107, 18, 255], [255, 109, 21, 255], [255, 111, 24, 255], [255, 113, 26, 255], [255, 115, 29, 255], [255, 117, 32, 255], [255, 119, 35, 255], [255, 120, 38, 255], [255, 122, 41, 255], [255, 124, 44, 255], [255, 126, 47, 255], [255, 128, 50, 255], [255, 130, 53, 255], [255, 132, 56, 255], [255, 134, 59, 255], [255, 136, 62, 255], [255, 137, 65, 255], [255, 139, 68, 255], [255, 141, 71, 255], [255, 143, 74, 255], [255, 145, 76, 255], [255, 147, 79, 255], [255, 149, 82, 255], [255, 151, 85, 255], [255, 152, 88, 255], [255, 154, 91, 255], [255, 156, 94, 255], [255, 158, 97, 255], [255, 160, 100, 255], [255, 162, 103, 255], [255, 164, 106, 255], [255, 166, 109, 255], [255, 168, 112, 255], [255, 169, 115, 255], [255, 171, 118, 255], [255, 173, 121, 255], [255, 175, 124, 255], [255, 177, 126, 255], [255, 179, 129, 255], [255, 181, 132, 255], [255, 183, 135, 255], [255, 184, 138, 255], [255, 186, 141, 255], [255, 188, 144, 255], [255, 190, 147, 255], [255, 192, 150, 255], [255, 194, 153, 255], [255, 196, 156, 255], [255, 198, 159, 255], [255, 200, 162, 255], [255, 201, 165, 255], [255, 203, 168, 255], [255, 205, 171, 255], [255, 207, 174, 255], [255, 209, 176, 255], [255, 211, 179, 255], [255, 213, 182, 255], [255, 215, 185, 255], [255, 216, 188, 255], [255, 218, 191, 255], [255, 220, 194, 255], [255, 222, 197, 255], [255, 224, 200, 255], [255, 226, 203, 255], [255, 228, 206, 255], [255, 229, 210, 255], [255, 231, 213, 255], [255, 233, 216, 255], [255, 235, 219, 255], [255, 237, 223, 255], [255, 239, 226, 255], [255, 240, 229, 255], [255, 242, 232, 255], [255, 244, 236, 255], [255, 246, 239, 255], [255, 248, 242, 255], [255, 250, 245, 255], [255, 251, 249, 255], [255, 253, 252, 255], [255, 255, 255, 255]] }, pet20Step: { name: "PET 20 Step", numColors: 256, colors: [[0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [0, 0, 0, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [96, 0, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 80, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [48, 48, 112, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [80, 80, 128, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [96, 96, 176, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [112, 112, 192, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [128, 128, 224, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 96, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [48, 144, 48, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [80, 192, 80, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [64, 224, 64, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [224, 224, 80, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 208, 96, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 176, 64, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [208, 144, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [192, 96, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [176, 48, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 0, 0, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255], [255, 255, 255, 255]] }, gray: { name: "Gray", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [1, 1, 1]], green: [[0, 0, 0], [1, 1, 1]], blue: [[0, 0, 0], [1, 1, 1]] } }, jet: { name: "Jet", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [0.35, 0, 0], [0.66, 1, 1], [0.89, 1, 1], [1, 0.5, 0.5]], green: [[0, 0, 0], [0.125, 0, 0], [0.375, 1, 1], [0.64, 1, 1], [0.91, 0, 0], [1, 0, 0]], blue: [[0, 0.5, 0.5], [0.11, 1, 1], [0.34, 1, 1], [0.65, 0, 0], [1, 0, 0]] } }, hsv: { name: "HSV", numColors: 256, gamma: 1, segmentedData: { red: [[0, 1, 1], [0.15873, 1, 1], [0.174603, 0.96875, 0.96875], [0.333333, 0.03125, 0.03125], [0.349206, 0, 0], [0.666667, 0, 0], [0.68254, 0.03125, 0.03125], [0.84127, 0.96875, 0.96875], [0.857143, 1, 1], [1, 1, 1]], green: [[0, 0, 0], [0.15873, 0.9375, 0.9375], [0.174603, 1, 1], [0.507937, 1, 1], [0.666667, 0.0625, 0.0625], [0.68254, 0, 0], [1, 0, 0]], blue: [[0, 0, 0], [0.333333, 0, 0], [0.349206, 0.0625, 0.0625], [0.507937, 1, 1], [0.84127, 1, 1], [0.857143, 0.9375, 0.9375], [1, 0.09375, 0.09375]] } }, hot: { name: "Hot", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0.0416, 0.0416], [0.365079, 1, 1], [1, 1, 1]], green: [[0, 0, 0], [0.365079, 0, 0], [0.746032, 1, 1], [1, 1, 1]], blue: [[0, 0, 0], [0.746032, 0, 0], [1, 1, 1]] } }, cool: { name: "Cool", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [1, 1, 1]], green: [[0, 1, 1], [1, 0, 0]], blue: [[0, 1, 1], [1, 1, 1]] } }, spring: { name: "Spring", numColors: 256, gamma: 1, segmentedData: { red: [[0, 1, 1], [1, 1, 1]], green: [[0, 0, 0], [1, 1, 1]], blue: [[0, 1, 1], [1, 0, 0]] } }, summer: { name: "Summer", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [1, 1, 1]], green: [[0, 0.5, 0.5], [1, 1, 1]], blue: [[0, 0.4, 0.4], [1, 0.4, 0.4]] } }, autumn: { name: "Autumn", numColors: 256, gamma: 1, segmentedData: { red: [[0, 1, 1], [1, 1, 1]], green: [[0, 0, 0], [1, 1, 1]], blue: [[0, 0, 0], [1, 0, 0]] } }, winter: { name: "Winter", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [1, 0, 0]], green: [[0, 0, 0], [1, 1, 1]], blue: [[0, 1, 1], [1, 0.5, 0.5]] } }, bone: { name: "Bone", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [0.746032, 0.652778, 0.652778], [1, 1, 1]], green: [[0, 0, 0], [0.365079, 0.319444, 0.319444], [0.746032, 0.777778, 0.777778], [1, 1, 1]], blue: [[0, 0, 0], [0.365079, 0.444444, 0.444444], [1, 1, 1]] } }, copper: { name: "Copper", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [0.809524, 1, 1], [1, 1, 1]], green: [[0, 0, 0], [1, 0.7812, 0.7812]], blue: [[0, 0, 0], [1, 0.4975, 0.4975]] } }, spectral: { name: "Spectral", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0, 0], [0.05, 0.4667, 0.4667], [0.1, 0.5333, 0.5333], [0.15, 0, 0], [0.2, 0, 0], [0.25, 0, 0], [0.3, 0, 0], [0.35, 0, 0], [0.4, 0, 0], [0.45, 0, 0], [0.5, 0, 0], [0.55, 0, 0], [0.6, 0, 0], [0.65, 0.7333, 0.7333], [0.7, 0.9333, 0.9333], [0.75, 1, 1], [0.8, 1, 1], [0.85, 1, 1], [0.9, 0.8667, 0.8667], [0.95, 0.8, 0.8], [1, 0.8, 0.8]], green: [[0, 0, 0], [0.05, 0, 0], [0.1, 0, 0], [0.15, 0, 0], [0.2, 0, 0], [0.25, 0.4667, 0.4667], [0.3, 0.6, 0.6], [0.35, 0.6667, 0.6667], [0.4, 0.6667, 0.6667], [0.45, 0.6, 0.6], [0.5, 0.7333, 0.7333], [0.55, 0.8667, 0.8667], [0.6, 1, 1], [0.65, 1, 1], [0.7, 0.9333, 0.9333], [0.75, 0.8, 0.8], [0.8, 0.6, 0.6], [0.85, 0, 0], [0.9, 0, 0], [0.95, 0, 0], [1, 0.8, 0.8]], blue: [[0, 0, 0], [0.05, 0.5333, 0.5333], [0.1, 0.6, 0.6], [0.15, 0.6667, 0.6667], [0.2, 0.8667, 0.8667], [0.25, 0.8667, 0.8667], [0.3, 0.8667, 0.8667], [0.35, 0.6667, 0.6667], [0.4, 0.5333, 0.5333], [0.45, 0, 0], [0.5, 0, 0], [0.55, 0, 0], [0.6, 0, 0], [0.65, 0, 0], [0.7, 0, 0], [0.75, 0, 0], [0.8, 0, 0], [0.85, 0, 0], [0.9, 0, 0], [0.95, 0, 0], [1, 0.8, 0.8]] } }, coolwarm: { name: "CoolWarm", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0.2298057, 0.2298057], [0.03125, 0.26623388, 0.26623388], [0.0625, 0.30386891, 0.30386891], [0.09375, 0.342804478, 0.342804478], [0.125, 0.38301334, 0.38301334], [0.15625, 0.424369608, 0.424369608], [0.1875, 0.46666708, 0.46666708], [0.21875, 0.509635204, 0.509635204], [0.25, 0.552953156, 0.552953156], [0.28125, 0.596262162, 0.596262162], [0.3125, 0.639176211, 0.639176211], [0.34375, 0.681291281, 0.681291281], [0.375, 0.722193294, 0.722193294], [0.40625, 0.761464949, 0.761464949], [0.4375, 0.798691636, 0.798691636], [0.46875, 0.833466556, 0.833466556], [0.5, 0.865395197, 0.865395197], [0.53125, 0.897787179, 0.897787179], [0.5625, 0.924127593, 0.924127593], [0.59375, 0.944468518, 0.944468518], [0.625, 0.958852946, 0.958852946], [0.65625, 0.96732803, 0.96732803], [0.6875, 0.969954137, 0.969954137], [0.71875, 0.966811177, 0.966811177], [0.75, 0.958003065, 0.958003065], [0.78125, 0.943660866, 0.943660866], [0.8125, 0.923944917, 0.923944917], [0.84375, 0.89904617, 0.89904617], [0.875, 0.869186849, 0.869186849], [0.90625, 0.834620542, 0.834620542], [0.9375, 0.795631745, 0.795631745], [0.96875, 0.752534934, 0.752534934], [1, 0.705673158, 0.705673158]], green: [[0, 0.298717966, 0.298717966], [0.03125, 0.353094838, 0.353094838], [0.0625, 0.406535296, 0.406535296], [0.09375, 0.458757618, 0.458757618], [0.125, 0.50941904, 0.50941904], [0.15625, 0.558148092, 0.558148092], [0.1875, 0.604562568, 0.604562568], [0.21875, 0.648280772, 0.648280772], [0.25, 0.688929332, 0.688929332], [0.28125, 0.726149107, 0.726149107], [0.3125, 0.759599947, 0.759599947], [0.34375, 0.788964712, 0.788964712], [0.375, 0.813952739, 0.813952739], [0.40625, 0.834302879, 0.834302879], [0.4375, 0.849786142, 0.849786142], [0.46875, 0.860207984, 0.860207984], [0.5, 0.86541021, 0.86541021], [0.53125, 0.848937047, 0.848937047], [0.5625, 0.827384882, 0.827384882], [0.59375, 0.800927443, 0.800927443], [0.625, 0.769767752, 0.769767752], [0.65625, 0.734132809, 0.734132809], [0.6875, 0.694266682, 0.694266682], [0.71875, 0.650421156, 0.650421156], [0.75, 0.602842431, 0.602842431], [0.78125, 0.551750968, 0.551750968], [0.8125, 0.49730856, 0.49730856], [0.84375, 0.439559467, 0.439559467], [0.875, 0.378313092, 0.378313092], [0.90625, 0.312874446, 0.312874446], [0.9375, 0.24128379, 0.24128379], [0.96875, 0.157246067, 0.157246067], [1, 0.01555616, 0.01555616]], blue: [[0, 0.753683153, 0.753683153], [0.03125, 0.801466763, 0.801466763], [0.0625, 0.84495867, 0.84495867], [0.09375, 0.883725899, 0.883725899], [0.125, 0.917387822, 0.917387822], [0.15625, 0.945619588, 0.945619588], [0.1875, 0.968154911, 0.968154911], [0.21875, 0.98478814, 0.98478814], [0.25, 0.995375608, 0.995375608], [0.28125, 0.999836203, 0.999836203], [0.3125, 0.998151185, 0.998151185], [0.34375, 0.990363227, 0.990363227], [0.375, 0.976574709, 0.976574709], [0.40625, 0.956945269, 0.956945269], [0.4375, 0.931688648, 0.931688648], [0.46875, 0.901068838, 0.901068838], [0.5, 0.865395561, 0.865395561], [0.53125, 0.820880546, 0.820880546], [0.5625, 0.774508472, 0.774508472], [0.59375, 0.726736146, 0.726736146], [0.625, 0.678007945, 0.678007945], [0.65625, 0.628751763, 0.628751763], [0.6875, 0.579375448, 0.579375448], [0.71875, 0.530263762, 0.530263762], [0.75, 0.481775914, 0.481775914], [0.78125, 0.434243684, 0.434243684], [0.8125, 0.387970225, 0.387970225], [0.84375, 0.343229596, 0.343229596], [0.875, 0.300267182, 0.300267182], [0.90625, 0.259301199, 0.259301199], [0.9375, 0.220525627, 0.220525627], [0.96875, 0.184115123, 0.184115123], [1, 0.150232812, 0.150232812]] } }, blues: { name: "Blues", numColors: 256, gamma: 1, segmentedData: { red: [[0, 0.9686274528503418, 0.9686274528503418], [0.125, 0.8705882430076599, 0.8705882430076599], [0.25, 0.7764706015586853, 0.7764706015586853], [0.375, 0.6196078658103943, 0.6196078658103943], [0.5, 0.41960784792900085, 0.41960784792900085], [0.625, 0.25882354378700256, 0.25882354378700256], [0.75, 0.12941177189350128, 0.12941177189350128], [0.875, 0.0313725508749485, 0.0313725508749485], [1, 0.0313725508749485, 0.0313725508749485]], green: [[0, 0.9843137264251709, 0.9843137264251709], [0.125, 0.9215686321258545, 0.9215686321258545], [0.25, 0.8588235378265381, 0.8588235378265381], [0.375, 0.7921568751335144, 0.7921568751335144], [0.5, 0.6823529601097107, 0.6823529601097107], [0.625, 0.572549045085907, 0.572549045085907], [0.75, 0.4431372582912445, 0.4431372582912445], [0.875, 0.3176470696926117, 0.3176470696926117], [1, 0.1882352977991104, 0.1882352977991104]], blue: [[0, 1, 1], [0.125, 0.9686274528503418, 0.9686274528503418], [0.25, 0.9372549057006836, 0.9372549057006836], [0.375, 0.8823529481887817, 0.8823529481887817], [0.5, 0.8392156958580017, 0.8392156958580017], [0.625, 0.7764706015586853, 0.7764706015586853], [0.75, 0.7098039388656616, 0.7098039388656616], [0.875, 0.6117647290229797, 0.6117647290229797], [1, 0.41960784792900085, 0.41960784792900085]] } } }, sn = [0, 0, 0, 0];
          function cn(e3, t3) {
            for (var r3 = 0, n3 = e3.length - 1; r3 <= n3; ) {
              var i3 = r3 + Math.floor((n3 - r3) / 2), a3 = e3[i3];
              if (a3 === t3)
                return i3;
              t3 < a3 ? n3 = i3 - 1 : r3 = i3 + 1;
            }
            return r3;
          }
          function un(e3, t3, r3) {
            var n3, i3 = [], a3 = [], o3 = [], s3 = [];
            for (r3 = r3 === null ? 1 : r3, n3 = 0; n3 < t3.length; n3++) {
              var c3 = t3[n3];
              i3.push((e3 - 1) * c3[0]), a3.push(c3[1]), o3.push(c3[1]);
            }
            var u3 = function(e4, t4, r4) {
              for (var n4 = (1 - e4) / ((r4 = r4 === null ? 100 : r4) - 1), i4 = []; r4-- > 0; )
                i4.push(e4), e4 += n4;
              return i4[i4.length - 1] = 1, i4;
            }(0, 0, e3);
            for (n3 = 0; n3 < e3; n3++)
              u3[n3] = (e3 - 1) * Math.pow(u3[n3], r3);
            var l3 = function(e4, t4) {
              var r4, n4 = [], i4 = t4.length;
              for (e4.sort(function(e5, t5) {
                return e5 - t5;
              }), r4 = 0; r4 < i4; r4++)
                n4[r4] = cn(e4, t4[r4]);
              return n4;
            }(i3, u3);
            for (n3 = 1; n3 < e3 - 1; n3++) {
              var d3 = l3[n3], h3 = (u3[n3] - i3[d3 - 1]) / (i3[d3] - i3[d3 - 1]), f3 = a3[d3] - o3[d3 - 1];
              s3[n3] = h3 * f3 + o3[d3 - 1];
            }
            return s3[0] = o3[0], s3[e3 - 1] = a3[t3.length - 1], s3;
          }
          function ln(e3, t3) {
            var r3 = on[e3];
            r3 || (r3 = on[e3] = t3 || { name: "", colors: [] }), !r3.colors && r3.segmentedData && (r3.colors = function(e4, t4, r4) {
              var n4, i3 = [];
              r4 = r4 === null ? 1 : r4;
              var a3 = un(t4 = t4 === null ? 256 : t4, e4.red, r4), o3 = un(t4, e4.green, r4), s3 = un(t4, e4.blue, r4);
              for (n4 = 0; n4 < t4; n4++) {
                var c3 = [Math.round(255 * a3[n4]), Math.round(255 * o3[n4]), Math.round(255 * s3[n4]), 255];
                i3.push(c3);
              }
              return i3;
            }(r3.segmentedData, r3.numColors, r3.gamma));
            var n3 = { getId: function() {
              return e3;
            }, getColorSchemeName: function() {
              return r3.name;
            }, setColorSchemeName: function(e4) {
              r3.name = e4;
            }, getNumberOfColors: function() {
              return r3.colors.length;
            }, setNumberOfColors: function(e4) {
              for (; r3.colors.length < e4; )
                r3.colors.push(sn);
              r3.colors.length = e4;
            }, getColor: function(e4) {
              return this.isValidIndex(e4) ? r3.colors[e4] : sn;
            }, getColorRepeating: function(e4) {
              var t4 = r3.colors.length;
              return e4 = t4 ? e4 % t4 : 0, this.getColor(e4);
            }, setColor: function(e4, t4) {
              this.isValidIndex(e4) && (r3.colors[e4] = t4);
            }, addColor: function(e4) {
              r3.colors.push(e4);
            }, insertColor: function(e4, t4) {
              this.isValidIndex(e4) && r3.colors.splice(e4, 1, t4);
            }, removeColor: function(e4) {
              this.isValidIndex(e4) && r3.colors.splice(e4, 1);
            }, clearColors: function() {
              r3.colors = [];
            }, buildLookupTable: function(e4) {
              if (e4) {
                var t4 = r3.colors.length;
                e4.setNumberOfTableValues(t4);
                for (var n4 = 0; n4 < t4; n4++)
                  e4.setTableValue(n4, r3.colors[n4]);
              }
            }, createLookupTable: function() {
              var e4 = new an();
              return this.buildLookupTable(e4), e4;
            }, isValidIndex: function(e4) {
              return e4 >= 0 && e4 < r3.colors.length;
            } };
            return n3;
          }
          function dn(e3, t3, r3) {
            return Math.max(t3, Math.min(r3, e3));
          }
          function hn(e3, t3) {
            if (e3 === void 0)
              throw new Error("drawImage: enabledElement parameter must not be undefined");
            var r3 = e3.image;
            if (r3 === void 0)
              throw new Error("drawImage: image must be loaded before it can be drawn");
            var n3 = e3.canvas.getContext("2d");
            n3.setTransform(1, 0, 0, 1, 0, 0), n3.fillStyle = "black", n3.fillRect(0, 0, e3.canvas.width, e3.canvas.height), n3.imageSmoothingEnabled = !e3.viewport.pixelReplication, Br(e3, n3);
            var i3 = function(e4, t4, r4) {
              e4.renderingTools.renderCanvas || (e4.renderingTools.renderCanvas = document.createElement("canvas"));
              var n4 = e4.renderingTools.renderCanvas, i4 = e4.viewport.colormap || e4.options.colormap;
              if (e4.options && e4.options.colormap && console.warn("enabledElement.options.colormap is deprecated. Use enabledElement.viewport.colormap instead"), i4 && typeof i4 == "string" && (i4 = ln(i4)), !i4)
                throw new Error("renderPseudoColorImage: colormap not found.");
              var a4 = i4.getId();
              if (zr(e4, t4) === false && r4 !== true && e4.renderingTools.colormapId === a4)
                return n4;
              n4.width === t4.width && n4.height === t4.height || Hr(e4, t4);
              var o4 = Nr();
              e4.renderingTools.colorLut && !r4 && e4.renderingTools.colormapId === a4 || (i4.setNumberOfColors(256), e4.renderingTools.colorLut = i4.createLookupTable(), e4.renderingTools.colormapId = a4);
              var s4 = e4.renderingTools.renderCanvasData, c4 = e4.renderingTools.renderCanvasContext, u3 = e4.viewport, l3 = e4.renderingTools.colorLut;
              if (u3.modality === "PT") {
                var d3 = u3.voi, h3 = d3.windowWidth, f3 = d3.windowCenter, v3 = f3 - h3 / 2, p3 = 255 / (f3 + h3 / 2 - v3);
                (function(e5, t5, r5, n5) {
                  var i5 = Nr(), a5 = e5.getPixelData();
                  e5.stats.lastGetPixelDataTime = Nr() - i5;
                  var o5, s5, c5 = a5.length, u4 = e5.minPixelValue, l4 = 0, d4 = 0;
                  if (i5 = Nr(), s5 = r5 instanceof an ? r5.Table : r5, u4 < 0)
                    for (; d4 < c5; )
                      o5 = s5[t5(a5[d4++] + -u4)], n5[l4++] = o5[0], n5[l4++] = o5[1], n5[l4++] = o5[2], n5[l4++] = o5[3];
                  else
                    for (; d4 < c5; )
                      o5 = s5[t5(a5[d4++])], n5[l4++] = o5[0], n5[l4++] = o5[1], n5[l4++] = o5[2], n5[l4++] = o5[3];
                  e5.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - i5;
                })(t4, u3.invert ? function(e5) {
                  return dn(Math.floor(255 - (e5 - v3) * p3), 0, 255);
                } : function(e5) {
                  return dn(Math.floor((e5 - v3) * p3), 0, 255);
                }, l3, s4.data);
              } else {
                var g3 = en(t4, e4.viewport, r4);
                t4.stats = t4.stats || {}, t4.stats.lastLutGenerateTime = Nr() - o4, function(e5, t5, r5, n5) {
                  var i5 = Nr(), a5 = e5.getPixelData();
                  e5.stats.lastGetPixelDataTime = Nr() - i5;
                  var o5, s5, c5 = a5.length, u4 = e5.minPixelValue, l4 = 0, d4 = 0;
                  if (i5 = Nr(), s5 = r5 instanceof an ? r5.Table : r5, u4 < 0)
                    for (; d4 < c5; )
                      o5 = s5[t5[a5[d4++] + -u4]], n5[l4++] = o5[0], n5[l4++] = o5[1], n5[l4++] = o5[2], n5[l4++] = o5[3];
                  else
                    for (; d4 < c5; )
                      o5 = s5[t5[a5[d4++]]], n5[l4++] = o5[0], n5[l4++] = o5[1], n5[l4++] = o5[2], n5[l4++] = o5[3];
                  e5.stats.lastStoredPixelDataToCanvasImageDataTime = Nr() - i5;
                }(t4, g3, l3, s4.data);
              }
              return o4 = Nr(), c4.putImageData(s4, 0, 0), t4.stats.lastPutImageDataTime = Nr() - o4, n4;
            }(e3, r3, t3), a3 = e3.viewport.displayedArea.tlhc.x - 1, o3 = e3.viewport.displayedArea.tlhc.y - 1, s3 = e3.viewport.displayedArea.brhc.x - a3, c3 = e3.viewport.displayedArea.brhc.y - o3;
            n3.drawImage(i3, a3, o3, s3, c3, 0, 0, s3, c3), e3.renderingTools = Kr(e3);
          }
          function fn(e3, t3) {
            var r3 = typeof Symbol != "undefined" && e3[Symbol.iterator] || e3["@@iterator"];
            if (!r3) {
              if (Array.isArray(e3) || (r3 = function(e4, t4) {
                if (e4) {
                  if (typeof e4 == "string")
                    return vn(e4, t4);
                  var r4 = Object.prototype.toString.call(e4).slice(8, -1);
                  return r4 === "Object" && e4.constructor && (r4 = e4.constructor.name), r4 === "Map" || r4 === "Set" ? Array.from(e4) : r4 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r4) ? vn(e4, t4) : void 0;
                }
              }(e3)) || t3 && e3 && typeof e3.length == "number") {
                r3 && (e3 = r3);
                var n3 = 0, i3 = function() {
                };
                return { s: i3, n: function() {
                  return n3 >= e3.length ? { done: true } : { done: false, value: e3[n3++] };
                }, e: function(e4) {
                  throw e4;
                }, f: i3 };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var a3, o3 = true, s3 = false;
            return { s: function() {
              r3 = r3.call(e3);
            }, n: function() {
              var e4 = r3.next();
              return o3 = e4.done, e4;
            }, e: function(e4) {
              s3 = true, a3 = e4;
            }, f: function() {
              try {
                o3 || r3.return == null || r3.return();
              } finally {
                if (s3)
                  throw a3;
              }
            } };
          }
          function vn(e3, t3) {
            (t3 == null || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++)
              n3[r3] = e3[r3];
            return n3;
          }
          var pn = function() {
            function e3() {
              M2(this, e3), V2(this, "requestPool", void 0), V2(this, "awake", void 0), V2(this, "numRequests", { interaction: 0, thumbnail: 0, prefetch: 0 }), V2(this, "maxNumRequests", void 0), V2(this, "grabDelay", void 0), V2(this, "timeoutHandle", void 0), this.requestPool = { interaction: { 0: [] }, thumbnail: { 0: [] }, prefetch: { 0: [] } }, this.awake = false, this.grabDelay = 5, this.numRequests = { interaction: 0, thumbnail: 0, prefetch: 0 }, this.maxNumRequests = { interaction: 6, thumbnail: 6, prefetch: 5 };
            }
            return T2(e3, [{ key: "destroy", value: function() {
              this.timeoutHandle && window.clearTimeout(this.timeoutHandle);
            } }, { key: "addRequest", value: function(e4, t3, r3) {
              var n3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i3 = { requestFn: e4, type: t3, additionalDetails: r3 };
              this.requestPool[t3][n3] === void 0 && (this.requestPool[t3][n3] = []), this.requestPool[t3][n3].push(i3), this.awake || (this.awake = true, this.startGrabbing());
            } }, { key: "filterRequests", value: function(e4) {
              var t3 = this;
              Object.keys(this.requestPool).forEach(function(r3) {
                var n3 = t3.requestPool[r3];
                Object.keys(n3).forEach(function(t4) {
                  n3[t4] = n3[t4].filter(function(t5) {
                    return e4(t5);
                  });
                });
              });
            } }, { key: "clearRequestStack", value: function(e4) {
              if (!this.requestPool[e4])
                throw new Error("No category for the type ".concat(e4, " found"));
              this.requestPool[e4] = { 0: [] };
            } }, { key: "sendRequest", value: function(e4) {
              var t3 = this, r3 = e4.requestFn, n3 = e4.type;
              this.numRequests[n3]++, this.awake = true, r3().finally(function() {
                t3.numRequests[n3]--, t3.startAgain();
              });
            } }, { key: "startGrabbing", value: function() {
              for (var e4 = this.maxNumRequests.interaction + this.maxNumRequests.thumbnail + this.maxNumRequests.prefetch - (this.numRequests.interaction + this.numRequests.thumbnail + this.numRequests.prefetch), t3 = 0; t3 < e4; t3++) {
                var r3 = this.getNextRequest();
                if (r3 === false)
                  break;
                r3 && this.sendRequest(r3);
              }
            } }, { key: "startAgain", value: function() {
              var e4 = this;
              this.awake && (this.grabDelay !== void 0 ? this.timeoutHandle = window.setTimeout(function() {
                e4.startGrabbing();
              }, this.grabDelay) : this.startGrabbing());
            } }, { key: "getSortedPriorityGroups", value: function(e4) {
              var t3 = this;
              return Object.keys(this.requestPool[e4]).map(Number).filter(function(r3) {
                return t3.requestPool[e4][r3].length;
              }).sort();
            } }, { key: "getNextRequest", value: function() {
              var e4, t3 = this.getSortedPriorityGroups("interaction"), r3 = fn(t3);
              try {
                for (r3.s(); !(e4 = r3.n()).done; ) {
                  var n3 = e4.value;
                  if (this.requestPool.interaction[n3].length && this.numRequests.interaction < this.maxNumRequests.interaction)
                    return this.requestPool.interaction[n3].shift();
                }
              } catch (e5) {
                r3.e(e5);
              } finally {
                r3.f();
              }
              var i3, a3 = this.getSortedPriorityGroups("thumbnail"), o3 = fn(a3);
              try {
                for (o3.s(); !(i3 = o3.n()).done; ) {
                  var s3 = i3.value;
                  if (this.requestPool.thumbnail[s3].length && this.numRequests.thumbnail < this.maxNumRequests.thumbnail)
                    return this.requestPool.thumbnail[s3].shift();
                }
              } catch (e5) {
                o3.e(e5);
              } finally {
                o3.f();
              }
              var c3, u3 = this.getSortedPriorityGroups("prefetch"), l3 = fn(u3);
              try {
                for (l3.s(); !(c3 = l3.n()).done; ) {
                  var d3 = c3.value;
                  if (this.requestPool.prefetch[d3].length && this.numRequests.prefetch < this.maxNumRequests.prefetch)
                    return this.requestPool.prefetch[d3].shift();
                }
              } catch (e5) {
                l3.e(e5);
              } finally {
                l3.f();
              }
              return t3.length || a3.length || u3.length || (this.awake = false), false;
            } }, { key: "getRequestPool", value: function() {
              return this.requestPool;
            } }]), e3;
          }(), gn = (new pn(), new pn());
          gn.maxNumRequests = { interaction: 1e3, thumbnail: 1e3, prefetch: 1e3 }, gn.grabDelay = 0;
          var mn, wn = gn, yn = {};
          function Cn(e3, t3) {
            var r3 = Q.getImageLoadObject(e3);
            if (r3 !== void 0)
              return r3;
            var n3 = Q.getVolumeContainingImageId(e3);
            if (n3 && n3.volume.loadStatus.loaded) {
              var i3 = n3.volume, a3 = n3.imageIdIndex;
              return i3.convertToCornerstoneImage(e3, a3);
            }
            var o3 = Q.getCachedImageBasedOnImageURI(e3);
            return o3 ? r3 = o3.imageLoadObject : (r3 = function(e4, t4) {
              var r4 = e4.indexOf(":"), n4 = e4.substring(0, r4), i4 = yn[n4];
              if (i4 == null) {
                if (mn !== void 0)
                  return mn(e4);
                throw new Error("loadImageFromImageLoader: no image loader for imageId");
              }
              var a4 = i4(e4, t4);
              return a4.promise.then(function(e5) {
                X($, c2.IMAGE_LOADED, { image: e5 });
              }, function(t5) {
                var r5 = { imageId: e4, error: t5 };
                X($, c2.IMAGE_LOAD_FAILED, r5);
              }), a4;
            }(e3, t3), r3);
          }
          function bn(e3) {
            var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { priority: 0, requestType: "prefetch" };
            if (e3 === void 0)
              throw new Error("loadImage: parameter imageId must not be undefined");
            return Cn(e3, t3).promise;
          }
          function In(e3) {
            var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { priority: 0, requestType: "prefetch" };
            if (e3 === void 0)
              throw new Error("loadAndCacheImage: parameter imageId must not be undefined");
            var r3 = Cn(e3, t3);
            return Q.getImageLoadObject(e3) || Q.putImageLoadObject(e3, r3).catch(function(e4) {
              console.warn(e4);
            }), r3.promise;
          }
          function kn(e3) {
            var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { priority: 0, requestType: "prefetch" };
            if (!e3 || e3.length === 0)
              throw new Error("loadAndCacheImages: parameter imageIds must be list of image Ids");
            var r3 = e3.map(function(e4) {
              return In(e4, t3);
            });
            return r3;
          }
          function En(e3) {
            wn.filterRequests(function(t4) {
              var r3 = t4.additionalDetails;
              return !r3.imageId || r3.imageId !== e3;
            });
            var t3 = Q.getImageLoadObject(e3);
            t3 && t3.cancel();
          }
          function Rn(e3) {
            e3.forEach(function(e4) {
              return En(e4);
            });
          }
          function An() {
            var e3 = wn.getRequestPool();
            Object.keys(e3).forEach(function(t3) {
              var r3 = e3[t3];
              Object.keys(r3).forEach(function(e4) {
                var t4, n3 = r3[e4].pop().additionalDetails, i3 = n3.imageId, a3 = n3.volumeId;
                i3 ? t4 = Q.getImageLoadObject(i3) : a3 && (t4 = Q.getVolumeLoadObject(a3)), t4 && t4.cancel();
              }), wn.clearRequestStack(t3);
            });
          }
          function xn(e3, t3) {
            yn[e3] = t3;
          }
          function _n(e3) {
            var t3 = mn;
            return mn = e3, t3;
          }
          function On() {
            Object.keys(yn).forEach(function(e3) {
              return delete yn[e3];
            }), mn = void 0;
          }
          function Pn(e3) {
            return qr(e3);
          }
          function Sn(e3, t3) {
            var r3 = Pn(e3);
            return r3.invert(), r3.transformPoint(t3);
          }
          function Dn(e3, t3) {
            return Pn(e3).transformPoint(t3);
          }
          var Tn = {};
          function Mn(e3, t3) {
            if (e3 == null)
              throw new Error(t3);
          }
          function Vn(e3) {
            return !(e3 == null || e3 === 0 || e3 === 180);
          }
          function jn(e3) {
            var t3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return Mn(e3, "getImageSize: parameter image must not be undefined"), Mn(e3.width, "getImageSize: parameter image must have width"), Mn(e3.height, "getImageSize: parameter image must have height"), Vn(t3) ? { height: e3.width, width: e3.height } : { width: e3.width, height: e3.height };
          }
          function Ln(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            Mn(e3, "getImageScale: parameter canvas must not be undefined"), Mn(t3, "getImageScale: parameter image must not be undefined");
            var n3 = jn(t3, r3), i3 = t3.rowPixelSpacing || 1, a3 = t3.columnPixelSpacing || 1, o3 = 1, s3 = 1;
            i3 < a3 ? s3 = a3 / i3 : o3 = i3 / a3;
            var c3 = e3.height / n3.height / o3, u3 = e3.width / n3.width / s3;
            return { verticalScale: c3, horizontalScale: u3, scaleFactor: Math.min(u3, c3) };
          }
          function Un(e3) {
            var t3 = e3.image;
            e3.viewport.scale = Ln(e3.canvas, t3, e3.viewport.rotation).scaleFactor, e3.viewport.translation.x = 0, e3.viewport.translation.y = 0;
          }
          function Fn(e3) {
            var t3 = e3.canvas, r3 = t3.clientWidth, n3 = t3.clientHeight;
            t3.width === r3 && t3.height === n3 || (t3.width = r3, t3.height = n3);
          }
          function Nn(e3, t3, r3) {
            var n3 = e3.viewport.scale, i3 = jn(e3.image, e3.viewport.rotation), a3 = Math.round(i3.width * n3), o3 = Math.round(i3.height * n3), s3 = e3.viewport.translation.x, c3 = e3.viewport.translation.y;
            return a3 === t3 && o3 <= r3 || a3 <= t3 && o3 === r3 && s3 === 0 && c3 === 0;
          }
          function Gn(e3, t3, r3) {
            var n3 = e3.viewport.scale, i3 = e3.canvas.width / t3, a3 = e3.canvas.height / r3, o3 = Math.sqrt(i3 * a3);
            e3.viewport.scale = o3 * n3;
          }
          function Wn(e3, t3) {
            var r3 = Object.keys(e3);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(e3);
              t3 && (n3 = n3.filter(function(t4) {
                return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
              })), r3.push.apply(r3, n3);
            }
            return r3;
          }
          function qn(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var r3 = arguments[t3] != null ? arguments[t3] : {};
              t3 % 2 ? Wn(Object(r3), true).forEach(function(t4) {
                V2(e3, t4, r3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Wn(Object(r3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
              });
            }
            return e3;
          }
          var Bn, zn = function(e3) {
            Wt(u3, e3);
            var t3, r3, n3, i3, a3, o3, s3 = (a3 = u3, o3 = function() {
              if (typeof Reflect == "undefined" || !Reflect.construct)
                return false;
              if (Reflect.construct.sham)
                return false;
              if (typeof Proxy == "function")
                return true;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), true;
              } catch (e4) {
                return false;
              }
            }(), function() {
              var e4, t4 = Ut(a3);
              if (o3) {
                var r4 = Ut(this).constructor;
                e4 = Reflect.construct(t4, arguments, r4);
              } else
                e4 = t4.apply(this, arguments);
              return Bt(this, e4);
            });
            function u3(e4) {
              var t4;
              if (M2(this, u3), V2(Lt(t4 = s3.call(this, e4)), "imageIds", void 0), V2(Lt(t4), "currentImageIdIndex", void 0), V2(Lt(t4), "voiRange", void 0), V2(Lt(t4), "invert", false), V2(Lt(t4), "interpolationType", void 0), V2(Lt(t4), "rotation", 0), V2(Lt(t4), "_imageData", void 0), V2(Lt(t4), "cameraPosOnRender", void 0), V2(Lt(t4), "stackInvalidated", false), V2(Lt(t4), "panCache", void 0), V2(Lt(t4), "shouldFlip", false), V2(Lt(t4), "voiApplied", false), V2(Lt(t4), "rotationCache", 0), V2(Lt(t4), "_publishCalibratedEvent", false), V2(Lt(t4), "_calibrationEvent", void 0), V2(Lt(t4), "_cpuFallbackEnabledElement", void 0), V2(Lt(t4), "useCPURendering", void 0), V2(Lt(t4), "cpuImagePixelData", void 0), V2(Lt(t4), "cpuRenderingInvalidated", void 0), V2(Lt(t4), "modality", void 0), V2(Lt(t4), "scaling", void 0), V2(Lt(t4), "resize", function() {
                t4.useCPURendering && t4._resizeCPU();
              }), V2(Lt(t4), "_resizeCPU", function() {
                t4._cpuFallbackEnabledElement.viewport && function(e5) {
                  var t5 = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], r5 = e5.canvas.width, n5 = e5.canvas.height;
                  Fn(e5), e5.image !== void 0 && (t5 || Nn(e5, r5, n5) ? Un(e5) : Gn(e5, r5, n5));
                }(t4._cpuFallbackEnabledElement);
              }), V2(Lt(t4), "getFrameOfReferenceUID", function() {
                var e5 = t4.getCurrentImageId();
                if (e5) {
                  var r5 = Vr("imagePlaneModule", e5);
                  if (r5)
                    return r5.frameOfReferenceUID;
                }
              }), V2(Lt(t4), "createActorMapper", function(e5) {
                var t5 = fe().newInstance();
                t5.setInputData(e5);
                var r5 = R2().newInstance();
                r5.setMapper(t5);
                var n5 = Ht(e5.getDimensions(), 3), i5 = n5[0], a4 = n5[1], o4 = n5[2], s4 = Ht(e5.getSpacing(), 3), c3 = s4[0], u4 = s4[1], l3 = s4[2], d3 = lt.vec3.length([i5 * c3, a4 * u4, o4 * l3]);
                return t5.setSampleDistance(d3 / t5.getMaximumSamplesPerRay()), e5.getPointData().getNumberOfComponents() > 1 && r5.getProperty().setIndependentComponents(false), r5;
              }), V2(Lt(t4), "getProperties", function() {
                return { voiRange: t4.voiRange, rotation: t4.rotationCache, interpolationType: t4.interpolationType, invert: t4.invert, flipHorizontal: t4.flipHorizontal, flipVertical: t4.flipVertical };
              }), V2(Lt(t4), "canvasToWorld", function(e5) {
                return t4.useCPURendering ? t4.canvasToWorldCPU(e5) : t4.canvasToWorldGPU(e5);
              }), V2(Lt(t4), "worldToCanvas", function(e5) {
                return t4.useCPURendering ? t4.worldToCanvasCPU(e5) : t4.worldToCanvasGPU(e5);
              }), V2(Lt(t4), "canvasToWorldCPU", function(e5) {
                if (t4._cpuFallbackEnabledElement.image) {
                  var r5 = Ht(Sn(t4._cpuFallbackEnabledElement, e5), 2), n5 = r5[0], i5 = r5[1], a4 = t4.getImageData(), o4 = a4.origin, s4 = a4.spacing, c3 = a4.direction, u4 = lt.vec3.fromValues(0, 0, 0), l3 = c3.slice(0, 3), d3 = c3.slice(3, 6);
                  return lt.vec3.scaleAndAdd(u4, o4, l3, n5 * s4[0]), lt.vec3.scaleAndAdd(u4, u4, d3, i5 * s4[1]), u4;
                }
              }), V2(Lt(t4), "worldToCanvasCPU", function(e5) {
                var r5 = t4.getImageData(), n5 = r5.spacing, i5 = r5.direction, a4 = r5.origin, o4 = i5.slice(0, 3), s4 = i5.slice(3, 6), c3 = lt.vec3.subtract(lt.vec3.create(), e5, a4), u4 = [lt.vec3.dot(c3, o4) / n5[0], lt.vec3.dot(c3, s4) / n5[1]];
                return Dn(t4._cpuFallbackEnabledElement, u4);
              }), V2(Lt(t4), "canvasToWorldGPU", function(e5) {
                var r5 = t4.getRenderer(), n5 = t4.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), i5 = n5.getSize(), a4 = [e5[0] + t4.sx, e5[1] + t4.sy];
                a4[1] = i5[1] - a4[1];
                var o4 = n5.displayToWorld(a4[0], a4[1], 0, r5);
                return t4.applyFlipTx(o4);
              }), V2(Lt(t4), "worldToCanvasGPU", function(e5) {
                var r5 = t4.getRenderer(), n5 = t4.getRenderingEngine().offscreenMultiRenderWindow.getOpenGLRenderWindow(), i5 = n5.getSize(), a4 = n5.worldToDisplay.apply(n5, Ae(t4.applyFlipTx(e5)).concat([r5]));
                return a4[1] = i5[1] - a4[1], [a4[0] - t4.sx, a4[1] - t4.sy];
              }), V2(Lt(t4), "getCurrentImageIdIndex", function() {
                return t4.currentImageIdIndex;
              }), V2(Lt(t4), "getImageIds", function() {
                return t4.imageIds;
              }), V2(Lt(t4), "getCurrentImageId", function() {
                return t4.imageIds[t4.currentImageIdIndex];
              }), V2(Lt(t4), "customRenderViewportToCanvas", function() {
                if (!t4.useCPURendering)
                  throw new Error("Custom cpu rendering pipeline should only be hit in CPU rendering mode");
                return t4._cpuFallbackEnabledElement.image ? (function(e5, t5) {
                  var r5 = e5.image;
                  if (e5.canvas, e5.canvas && e5.image) {
                    var n5 = Nr();
                    if (r5.stats = { lastGetPixelDataTime: -1, lastStoredPixelDataToCanvasImageDataTime: -1, lastPutImageDataTime: -1, lastRenderTime: -1, lastLutGenerateTime: -1 }, r5) {
                      var i5 = r5.render;
                      i5 || (i5 = e5.viewport.colormap ? hn : r5.color ? Xr : tn), i5(e5, t5);
                    }
                    var a4 = Nr() - n5;
                    r5.stats.lastRenderTime = a4, e5.invalid = false, e5.needsRedraw = false;
                  }
                }(t4._cpuFallbackEnabledElement, t4.cpuRenderingInvalidated), t4.cpuRenderingInvalidated = false) : t4.fillWithBackgroundColor(), { canvas: t4.canvas, element: t4.element, viewportId: t4.id, renderingEngineId: t4.renderingEngineId };
              }), t4.scaling = {}, t4.modality = null, t4.useCPURendering = xr(), t4.useCPURendering)
                t4._cpuFallbackEnabledElement = { canvas: t4.canvas, renderingTools: {}, transform: new Wr(), viewport: {} };
              else {
                var r4 = t4.getRenderer(), n4 = ir().newInstance();
                r4.setActiveCamera(n4);
                var i4 = [0, 0, -1];
                n4.setDirectionOfProjection(-i4[0], -i4[1], -i4[2]), n4.setViewUp.apply(n4, [0, -1, 0]), n4.setParallelProjection(true), n4.setFreezeFocalPoint(true);
              }
              return t4.imageIds = [], t4.currentImageIdIndex = 0, t4.panCache = [0, 0, 0], t4.cameraPosOnRender = [0, 0, 0], t4.resetCamera(), t4;
            }
            return T2(u3, [{ key: "getImageData", value: function() {
              return this.useCPURendering ? this.getImageDataCPU() : this.getImageDataGPU();
            } }, { key: "getImageDataGPU", value: function() {
              var e4 = this.getDefaultActor();
              if (e4) {
                var t4 = e4.volumeActor, r4 = t4.getMapper().getInputData();
                return { dimensions: r4.getDimensions(), spacing: r4.getSpacing(), origin: r4.getOrigin(), direction: r4.getDirection(), scalarData: r4.getPointData().getScalars().getData(), imageData: t4.getMapper().getInputData(), metadata: { Modality: this.modality }, scaling: this.scaling };
              }
            } }, { key: "getImageDataCPU", value: function() {
              var e4 = this, t4 = this._cpuFallbackEnabledElement.metadata, r4 = t4.spacing;
              return { dimensions: t4.dimensions, spacing: r4, origin: t4.origin, direction: t4.direction, metadata: { Modality: this.modality }, scaling: this.scaling, imageData: { getDirection: function() {
                return t4.direction;
              }, getDimensions: function() {
                return t4.dimensions;
              }, getScalarData: function() {
                return e4.cpuImagePixelData;
              }, getSpacing: function() {
                return r4;
              }, worldToIndex: function(t5) {
                var r5 = e4.worldToCanvasCPU(t5), n4 = Sn(e4._cpuFallbackEnabledElement, r5);
                return [n4[0], n4[1], 0];
              }, indexToWorld: function(t5) {
                var r5 = Dn(e4._cpuFallbackEnabledElement, [t5[0], t5[1]]);
                return e4.canvasToWorldCPU(r5);
              } }, scalarData: this.cpuImagePixelData };
            } }, { key: "buildMetadata", value: function(e4) {
              var t4, r4, n4 = Vr("imagePixelModule", e4), i4 = n4.pixelRepresentation, a4 = n4.bitsAllocated, o4 = n4.bitsStored, s4 = n4.highBit, c3 = n4.photometricInterpretation, u4 = n4.samplesPerPixel, l3 = Vr("voiLutModule", e4);
              l3 && (t4 = l3.windowWidth, r4 = l3.windowCenter, Array.isArray(t4) && (t4 = t4[0]), Array.isArray(r4) && (r4 = r4[0]));
              var d3 = Vr("generalSeriesModule", e4).modality, h3 = Vr("scalingModule", e4);
              d3 === "PT" && h3 && this._addScalingToViewport(h3), this.modality = d3;
              var f3 = Vr("imagePlaneModule", e4);
              return this.useCPURendering || (f3 = this.calibrateIfNecessary(e4, f3)), { imagePlaneModule: f3, imagePixelModule: { bitsAllocated: a4, bitsStored: o4, samplesPerPixel: u4, highBit: s4, photometricInterpretation: c3, pixelRepresentation: i4, windowWidth: t4, windowCenter: r4, modality: d3 } };
            } }, { key: "calibrateIfNecessary", value: function(e4, t4) {
              var r4 = Vr("calibratedPixelSpacing", e4);
              if (!r4)
                return t4;
              var n4 = Ht(r4, 2), i4 = n4[0], a4 = n4[1];
              if (t4.rowPixelSpacing === i4 && t4.columnPixelSpacing === a4)
                return t4;
              var o4 = this.getImageData();
              if (!o4 && t4.rowPixelSpacing === i4 && t4.columnPixelSpacing === a4)
                return t4;
              if (!o4 && (t4.rowPixelSpacing !== i4 || t4.columnPixelSpacing !== a4))
                return this._publishCalibratedEvent = true, this._calibrationEvent = { rowScale: i4 / t4.rowPixelSpacing, columnScale: a4 / t4.columnPixelSpacing }, t4.rowPixelSpacing = i4, t4.columnPixelSpacing = a4, t4;
              var s4 = Ht(o4.imageData.getSpacing(), 2), c3 = s4[0], u4 = s4[1];
              return t4.rowPixelSpacing = i4, t4.columnPixelSpacing = a4, u4 === i4 && c3 === r4 || (this._publishCalibratedEvent = true, this._calibrationEvent = { rowScale: i4 / u4, columnScale: a4 / c3 }), t4;
            } }, { key: "setProperties", value: function() {
              var e4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t4 = e4.voiRange, r4 = e4.invert, n4 = e4.interpolationType, i4 = e4.rotation, a4 = e4.flipHorizontal, o4 = e4.flipVertical;
              t4 === void 0 && this.voiApplied || this.setVOI(t4), r4 !== void 0 && this.setInvertColor(r4), n4 !== void 0 && this.setInterpolationType(n4), i4 !== void 0 && this.rotationCache !== i4 && this.setRotation(this.rotationCache, i4), a4 === void 0 && o4 === void 0 || this.setFlipDirection({ flipHorizontal: a4, flipVertical: o4 });
            } }, { key: "resetProperties", value: function() {
              this.cpuRenderingInvalidated = true, this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}), this._resetProperties(), this.render();
            } }, { key: "getCamera", value: function() {
              return this.useCPURendering ? this.getCameraCPU() : Nt(Ut(u3.prototype), "getCamera", this).call(this);
            } }, { key: "setCamera", value: function(e4) {
              this.useCPURendering ? this.setCameraCPU(e4) : Nt(Ut(u3.prototype), "setCamera", this).call(this, e4);
            } }, { key: "_resetProperties", value: function() {
              this.voiApplied = false, this.setProperties({ voiRange: void 0, rotation: 0, interpolationType: v2.LINEAR, invert: false, flipHorizontal: false, flipVertical: false });
            } }, { key: "_setPropertiesFromCache", value: function() {
              this.setProperties({ voiRange: this.voiRange, rotation: this.rotation, interpolationType: this.interpolationType, invert: this.invert, flipHorizontal: this.flipHorizontal, flipVertical: this.flipVertical });
            } }, { key: "getCameraCPU", value: function() {
              var e4 = this._cpuFallbackEnabledElement, t4 = e4.metadata, r4 = e4.viewport, n4 = t4.direction, i4 = n4.slice(6, 9).map(function(e5) {
                return -e5;
              }), a4 = n4.slice(3, 6).map(function(e5) {
                return -e5;
              });
              return { parallelProjection: true, focalPoint: [0, 0, 0], position: [0, 0, 0], parallelScale: r4.scale, viewPlaneNormal: [i4[0], i4[1], i4[2]], viewUp: [a4[0], a4[1], a4[2]] };
            } }, { key: "setCameraCPU", value: function(e4) {
              var t4 = this._cpuFallbackEnabledElement.viewport, r4 = this.getCameraCPU(), n4 = e4.focalPoint, i4 = e4.viewUp, a4 = e4.parallelScale;
              if (n4) {
                var o4 = this.worldToCanvasCPU(e4.focalPoint), s4 = this.worldToCanvasCPU(r4.focalPoint), u4 = lt.vec2.create();
                lt.vec2.subtract(u4, lt.vec2.fromValues(s4[0], s4[1]), lt.vec2.fromValues(o4[0], o4[1])), t4.translation.x += u4[0] / r4.parallelScale, t4.translation.y += u4[1] / r4.parallelScale;
              }
              if (a4 && r4.parallelScale !== a4) {
                var l3 = r4.parallelScale - a4;
                t4.scale += l3;
              }
              var d3 = { previousCamera: r4, camera: qn(qn({}, r4), {}, { focalPoint: n4, viewUp: i4, parallelScale: a4 }), element: this.element, viewportId: this.id, renderingEngineId: this.renderingEngineId };
              X(this.element, c2.CAMERA_MODIFIED, d3);
            } }, { key: "setFlipDirection", value: function(e4) {
              this.useCPURendering ? this.setFlipCPU(e4) : Nt(Ut(u3.prototype), "flip", this).call(this, e4), this.shouldFlip = false;
            } }, { key: "setFlipCPU", value: function(e4) {
              var t4 = e4.flipHorizontal, r4 = e4.flipVertical, n4 = this._cpuFallbackEnabledElement.viewport;
              n4.hflip = t4, this.flipHorizontal = n4.hflip, n4.vflip = r4, this.flipVertical = n4.vflip;
            } }, { key: "setVOI", value: function(e4) {
              this.useCPURendering ? this.setVOICPU(e4) : this.setVOIGPU(e4);
            } }, { key: "setRotation", value: function(e4, t4) {
              this.useCPURendering ? this.setRotationCPU(e4, t4) : this.setRotationGPU(e4, t4);
            } }, { key: "setInterpolationType", value: function(e4) {
              this.useCPURendering ? this.setInterpolationTypeCPU(e4) : this.setInterpolationTypeGPU(e4);
            } }, { key: "setInvertColor", value: function(e4) {
              this.useCPURendering ? this.setInvertColorCPU(e4) : this.setInvertColorGPU(e4);
            } }, { key: "setRotationCPU", value: function(e4, t4) {
              this._cpuFallbackEnabledElement.viewport.rotation = t4, this.rotationCache = t4, this.rotation = t4;
            } }, { key: "setRotationGPU", value: function(e4, t4) {
              this.getVtkActiveCamera().roll(e4), this.getVtkActiveCamera().roll(-t4), this.rotationCache = t4, this.rotation = t4;
            } }, { key: "setInterpolationTypeGPU", value: function(e4) {
              var t4 = this.getDefaultActor();
              t4 && (t4.volumeActor.getProperty().setInterpolationType(e4), this.interpolationType = e4);
            } }, { key: "setInterpolationTypeCPU", value: function(e4) {
              var t4 = this._cpuFallbackEnabledElement.viewport;
              e4 === v2.LINEAR ? t4.pixelReplication = false : t4.pixelReplication = true, this.interpolationType = e4;
            } }, { key: "setInvertColorCPU", value: function(e4) {
              var t4 = this._cpuFallbackEnabledElement.viewport;
              t4 && (t4.invert = e4, this.invert = e4);
            } }, { key: "setInvertColorGPU", value: function(e4) {
              var t4 = this.getDefaultActor();
              if (t4) {
                var r4 = t4.volumeActor.getProperty().getRGBTransferFunction(0);
                (!this.invert && e4 || this.invert && !e4) && jr(r4), this.invert = e4;
              }
            } }, { key: "setVOICPU", value: function(e4) {
              var t4 = this._cpuFallbackEnabledElement, r4 = t4.viewport, n4 = t4.image;
              if (r4 && n4) {
                if (e4 === void 0) {
                  var i4 = n4.windowWidth, a4 = n4.windowCenter, o4 = Array.isArray(i4) ? i4[0] : i4, s4 = Array.isArray(a4) ? a4[0] : a4;
                  r4.voi = { windowWidth: o4, windowCenter: s4 };
                  var c3 = Ur(o4, s4), u4 = c3.lower, l3 = c3.upper;
                  this.voiRange = { lower: u4, upper: l3 };
                } else {
                  var d3 = Lr(e4.lower, e4.upper), h3 = d3.windowCenter, f3 = d3.windowWidth;
                  r4.voi || (r4.voi = { windowWidth: 0, windowCenter: 0 }), r4.voi.windowWidth = f3, r4.voi.windowCenter = h3, this.voiRange = e4;
                }
                this.voiApplied = true;
              }
            } }, { key: "setVOIGPU", value: function(e4) {
              var t4 = this.getDefaultActor();
              if (t4) {
                var r4 = t4.volumeActor, n4 = r4.getProperty().getRGBTransferFunction(0);
                if (e4 === void 0) {
                  var i4 = r4.getMapper().getInputData().getPointData().getScalars().getRange();
                  n4.setRange(i4[0], i4[1]), this.voiRange = { lower: i4[0], upper: i4[1] };
                } else {
                  var a4 = e4.lower, o4 = e4.upper;
                  n4.setRange(a4, o4), this.voiRange = e4;
                }
                this.voiApplied = true;
              }
            } }, { key: "_addScalingToViewport", value: function(e4) {
              if (!this.scaling.PET) {
                var t4 = e4.suvbw, r4 = e4.suvlbm, n4 = e4.suvbsa, i4 = {};
                r4 && (i4.suvbwToSuvlbm = r4 / t4), n4 && (i4.suvbwToSuvbsa = n4 / t4), this.scaling.PET = i4;
              }
            } }, { key: "_getNumCompsFromPhotometricInterpretation", value: function(e4) {
              var t4 = 1;
              return e4 === "RGB" && (t4 = 3), t4;
            } }, { key: "_getImageDataMetadata", value: function(e4) {
              var t4, r4, n4 = this.buildMetadata(e4.imageId), i4 = n4.imagePlaneModule, a4 = n4.imagePixelModule;
              t4 = i4.rowCosines, r4 = i4.columnCosines, t4 != null && r4 != null || (t4 = [1, 0, 0], r4 = [0, 1, 0]);
              var o4 = lt.vec3.fromValues(t4[0], t4[1], t4[2]), s4 = lt.vec3.fromValues(r4[0], r4[1], r4[2]), c3 = lt.vec3.create();
              lt.vec3.cross(c3, o4, s4);
              var u4 = i4.imagePositionPatient;
              u4 == null && (u4 = [0, 0, 0]);
              var l3 = i4.columnPixelSpacing || e4.columnPixelSpacing, d3 = i4.rowPixelSpacing || e4.rowPixelSpacing, h3 = e4.columns, f3 = e4.rows, v3 = e4.sliceThickness || 1, p3 = e4.numComps || this._getNumCompsFromPhotometricInterpretation(a4.photometricInterpretation);
              return { bitsAllocated: a4.bitsAllocated, numComps: p3, origin: u4, direction: new Float32Array([].concat(Ae(o4), Ae(s4), Ae(c3))), dimensions: [h3, f3, 1], spacing: [l3, d3, v3], numVoxels: h3 * f3 * 1, imagePlaneModule: i4, imagePixelModule: a4 };
            } }, { key: "_getCameraOrientation", value: function(e4) {
              var t4 = e4.slice(6, 9).map(function(e5) {
                return -e5;
              }), r4 = e4.slice(3, 6).map(function(e5) {
                return -e5;
              });
              return { viewPlaneNormal: [t4[0], t4[1], t4[2]], viewUp: [r4[0], r4[1], r4[2]] };
            } }, { key: "_createVTKImageData", value: function(e4) {
              var t4, r4 = this._getImageDataMetadata(e4), n4 = r4.origin, i4 = r4.direction, a4 = r4.dimensions, o4 = r4.spacing, s4 = r4.bitsAllocated, c3 = r4.numComps, u4 = r4.numVoxels;
              switch (s4) {
                case 8:
                  t4 = new Uint8Array(u4);
                  break;
                case 16:
                  t4 = new Float32Array(u4);
                  break;
                case 24:
                  t4 = new Uint8Array(3 * u4);
                  break;
                default:
                  console.debug("bit allocation not implemented");
              }
              var l3 = O2().newInstance({ name: "Pixels", numberOfComponents: c3, values: t4 });
              this._imageData = x2().newInstance(), this._imageData.setDimensions(a4), this._imageData.setSpacing(o4), this._imageData.setDirection(i4), this._imageData.setOrigin(n4), this._imageData.getPointData().setScalars(l3);
            } }, { key: "setStack", value: (i3 = b2(k2().mark(function e4(t4) {
              var r4, n4, i4 = arguments;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      return r4 = i4.length > 1 && i4[1] !== void 0 ? i4[1] : 0, this.imageIds = t4, this.currentImageIdIndex = r4, this.stackInvalidated = true, this.rotationCache = 0, this.flipVertical = false, this.flipHorizontal = false, this._resetProperties(), this.fillWithBackgroundColor(), this.useCPURendering && (this._cpuFallbackEnabledElement.renderingTools = {}, delete this._cpuFallbackEnabledElement.viewport.colormap), e5.next = 12, this._setImageIdIndex(r4);
                    case 12:
                      return n4 = e5.sent, e5.abrupt("return", n4);
                    case 14:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4) {
              return i3.apply(this, arguments);
            }) }, { key: "_checkVTKImageDataMatchesCornerstoneImage", value: function(e4, t4) {
              if (!t4)
                return false;
              var r4 = Ht(t4.getSpacing(), 3), n4 = r4[0], i4 = r4[1], a4 = (r4[2], Ht(t4.getDimensions(), 3)), o4 = a4[0], s4 = a4[1], c3 = (a4[2], Vr("imagePlaneModule", e4.imageId)), u4 = t4.getDirection(), l3 = u4.slice(0, 3), d3 = u4.slice(3, 6);
              return !(n4 !== e4.rowPixelSpacing || i4 !== e4.columnPixelSpacing || o4 !== e4.columns || s4 !== e4.rows || !Fr(c3.rowCosines, l3) || !Fr(c3.columnCosines, d3));
            } }, { key: "_updateVTKImageDataFromCornerstoneImage", value: function(e4) {
              var t4 = Vr("imagePlaneModule", e4.imageId).imagePositionPatient;
              t4 == null && (t4 = [0, 0, 0]), this._imageData.setOrigin(t4);
              var r4 = e4.getPixelData(), n4 = this._imageData.getPointData().getScalars().getData();
              if (e4.color)
                for (var i4 = 0, a4 = 0; a4 < r4.length; a4 += 4)
                  n4[i4] = r4[a4], n4[i4 + 1] = r4[a4 + 1], n4[i4 + 2] = r4[a4 + 2], i4 += 3;
              else
                n4.set(r4);
              this._imageData.modified();
            } }, { key: "_loadImage", value: (n3 = b2(k2().mark(function e4(t4, r4) {
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      if (!this.useCPURendering) {
                        e5.next = 5;
                        break;
                      }
                      return e5.next = 3, this._loadImageCPU(t4, r4);
                    case 3:
                      e5.next = 7;
                      break;
                    case 5:
                      return e5.next = 7, this._loadImageGPU(t4, r4);
                    case 7:
                      return e5.abrupt("return", t4);
                    case 8:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4, t4) {
              return n3.apply(this, arguments);
            }) }, { key: "_loadImageCPU", value: function(e4, t4) {
              var r4 = this;
              return new Promise(function(n4, i4) {
                function a4(e5, t5, r5) {
                  var i5 = { image: e5, imageId: r5, viewportId: this.id, renderingEngineId: this.renderingEngineId };
                  X(this.element, c2.STACK_NEW_IMAGE, i5);
                  var a5 = this._getImageDataMetadata(e5), o5 = function(e6, t6, r6, n5) {
                    if (e6 === void 0)
                      throw new Error("getDefaultViewport: parameter canvas must not be undefined");
                    if (t6 === void 0)
                      return i6 = { scale: 1, translation: { x: 0, y: 0 }, voi: { windowWidth: void 0, windowCenter: void 0 }, invert: false, pixelReplication: false, rotation: 0, hflip: false, vflip: false, modalityLUT: void 0, voiLUT: void 0, colormap: void 0, labelmap: false, displayedArea: { tlhc: { x: 1, y: 1 }, brhc: { x: 1, y: 1 }, rowPixelSpacing: 1, columnPixelSpacing: 1, presentationSizeMode: "NONE" } }, Object.assign({}, i6, Tn);
                    var i6, a6, o6 = Ln(e6, t6, 0).scaleFactor;
                    return t6.windowWidth && t6.windowCenter ? a6 = { windowWidth: Array.isArray(t6.windowWidth) ? t6.windowWidth[0] : t6.windowWidth, windowCenter: Array.isArray(t6.windowCenter) ? t6.windowCenter[0] : t6.windowCenter } : r6 === "PT" && (a6 = { windowWidth: 5, windowCenter: 2.5 }), { scale: o6, translation: { x: 0, y: 0 }, voi: a6, invert: t6.invert, pixelReplication: false, rotation: 0, hflip: false, vflip: false, modalityLUT: t6.modalityLUT, modality: r6, voiLUT: t6.voiLUT, colormap: n5 !== void 0 ? n5 : t6.colormap, displayedArea: { tlhc: { x: 1, y: 1 }, brhc: { x: t6.columns, y: t6.rows }, rowPixelSpacing: t6.rowPixelSpacing === void 0 ? 1 : t6.rowPixelSpacing, columnPixelSpacing: t6.columnPixelSpacing === void 0 ? 1 : t6.columnPixelSpacing, presentationSizeMode: "NONE" } };
                  }(this.canvas, e5, this.modality, this._cpuFallbackEnabledElement.viewport.colormap);
                  this._cpuFallbackEnabledElement.image = e5, this._cpuFallbackEnabledElement.metadata = qn({}, a5), this.cpuImagePixelData = e5.getPixelData();
                  var s5 = Object.assign({}, o5, this._cpuFallbackEnabledElement.viewport);
                  this._cpuFallbackEnabledElement.viewport = this.stackInvalidated ? o5 : s5, this.stackInvalidated = false, this.cpuRenderingInvalidated = true, this._cpuFallbackEnabledElement.transform = qr(this._cpuFallbackEnabledElement), this.currentImageIdIndex === t5 && (this.render(), this.currentImageIdIndex = t5, n4(r5));
                }
                function o4(e5, t5, r5) {
                  var n5 = { error: e5, imageIdIndex: t5, imageId: r5 };
                  this.suppressEvents || X($, c2.IMAGE_LOAD_ERROR, n5), i4(e5);
                }
                var s4 = Vr("modalityLutModule", e4) || {}, u4 = Vr("scalingModule", e4) || {}, d3 = Vr("generalSeriesModule", e4) || {}, h3 = { rescaleSlope: s4.rescaleSlope, rescaleIntercept: s4.rescaleIntercept, modality: d3.modality, suvbw: u4.suvbw }, f3 = l2.Interaction, v3 = { imageId: e4 }, p3 = { targetBuffer: { type: "Float32Array", offset: null, length: null }, preScale: { scalingParameters: h3 } };
                wn.addRequest(function(e5, t5, r5) {
                  var n5 = this;
                  return In(e5, r5).then(function(r6) {
                    a4.call(n5, r6, t5, e5);
                  }, function(r6) {
                    o4.call(n5, r6, t5, e5);
                  });
                }.bind(r4, e4, t4, p3), f3, v3, -5);
              });
            } }, { key: "_loadImageGPU", value: function(e4, t4) {
              var r4 = this;
              return new Promise(function(n4, i4) {
                function a4(e5, t5, r5) {
                  var i5 = { image: e5, imageId: r5, viewportId: this.id, renderingEngineId: this.renderingEngineId };
                  X(this.element, c2.STACK_NEW_IMAGE, i5), this._updateActorToDisplayImageId(e5), this.currentImageIdIndex === t5 && (this.render(), this.currentImageIdIndex = t5, n4(r5));
                }
                function o4(e5, t5, r5) {
                  var n5 = { error: e5, imageIdIndex: t5, imageId: r5 };
                  X($, c2.IMAGE_LOAD_ERROR, n5), i4(e5);
                }
                var s4 = Vr("modalityLutModule", e4) || {}, u4 = Vr("scalingModule", e4) || {}, d3 = Vr("generalSeriesModule", e4) || {}, h3 = { rescaleSlope: s4.rescaleSlope, rescaleIntercept: s4.rescaleIntercept, modality: d3.modality, suvbw: u4.suvbw }, f3 = l2.Interaction, v3 = { imageId: e4 }, p3 = { targetBuffer: { type: "Float32Array", offset: null, length: null }, preScale: { scalingParameters: h3 } };
                wn.addRequest(function(e5, t5, r5) {
                  var n5 = this;
                  return In(e5, r5).then(function(r6) {
                    a4.call(n5, r6, t5, e5);
                  }, function(r6) {
                    o4.call(n5, r6, t5, e5);
                  });
                }.bind(r4, e4, t4, p3), f3, v3, -5);
              });
            } }, { key: "_updateActorToDisplayImageId", value: function(e4) {
              var t4 = this._checkVTKImageDataMatchesCornerstoneImage(e4, this._imageData), r4 = this.getRenderer().getActiveCamera(), n4 = S2()(this.getCamera());
              if (t4 && !this.stackInvalidated) {
                this._updateVTKImageDataFromCornerstoneImage(e4);
                var i4 = this._imageData.getDirection(), a4 = this._getCameraOrientation(i4), o4 = a4.viewPlaneNormal, s4 = a4.viewUp;
                this.setCameraNoEvent({ viewUp: s4, viewPlaneNormal: o4 });
                var c3 = this.getCamera();
                this.panCache[0] = this.cameraPosOnRender[0] - c3.position[0], this.panCache[1] = this.cameraPosOnRender[1] - c3.position[1], this.panCache[2] = this.cameraPosOnRender[2] - c3.position[2], this.resetCameraNoEvent();
                var u4 = this.getCamera().position;
                return this.cameraPosOnRender = u4, r4.setFreezeFocalPoint(true), this._restoreCameraProps(c3, n4), this.rotationCache = 0, void this._setPropertiesFromCache();
              }
              this._createVTKImageData(e4), this._updateVTKImageDataFromCornerstoneImage(e4);
              var l3 = this.createActorMapper(this._imageData);
              this.setActors([{ uid: this.id, volumeActor: l3 }]);
              var d3 = this._imageData.getDirection(), h3 = this._getCameraOrientation(d3), f3 = h3.viewPlaneNormal, v3 = h3.viewUp;
              this.setCameraNoEvent({ viewUp: v3, viewPlaneNormal: f3 }), this.resetCameraNoEvent(), this.triggerCameraEvent(this.getCamera(), n4), r4.setFreezeFocalPoint(true), this.setProperties();
              var p3 = this.getCamera().position;
              this.cameraPosOnRender = p3, this.stackInvalidated = false, this._publishCalibratedEvent && this.triggerCalibrationEvent();
            } }, { key: "_setImageIdIndex", value: (r3 = b2(k2().mark(function e4(t4) {
              var r4;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      if (!(t4 >= this.imageIds.length)) {
                        e5.next = 2;
                        break;
                      }
                      throw new Error("ImageIdIndex provided ".concat(t4, " is invalid, the stack only has ").concat(this.imageIds.length, " elements"));
                    case 2:
                      return this.currentImageIdIndex = t4, e5.next = 5, this._loadImage(this.imageIds[t4], t4);
                    case 5:
                      return r4 = e5.sent, e5.abrupt("return", r4);
                    case 7:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4) {
              return r3.apply(this, arguments);
            }) }, { key: "resetCamera", value: function() {
              var e4 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0];
              return this.useCPURendering ? this.resetCameraCPU(e4) : this.resetCameraGPU(), true;
            } }, { key: "resetCameraCPU", value: function(e4) {
              this._cpuFallbackEnabledElement.image && function(e5, t4) {
                var r4 = e5.canvas, n4 = e5.image, i4 = e5.viewport, a4 = Ln(r4, n4, 0).scaleFactor;
                i4.vflip = false, i4.hflip = false, t4 && (i4.translation.x = 0, i4.translation.y = 0, i4.displayedArea.tlhc.x = 1, i4.displayedArea.tlhc.y = 1, i4.displayedArea.brhc.x = n4.columns, i4.displayedArea.brhc.y = n4.rows, i4.scale = a4);
              }(this._cpuFallbackEnabledElement, e4);
            } }, { key: "resetCameraGPU", value: function() {
              Nt(Ut(u3.prototype), "resetCamera", this).call(this, false);
            } }, { key: "setImageIdIndex", value: (t3 = b2(k2().mark(function e4(t4) {
              var r4;
              return k2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      if (this.currentImageIdIndex !== t4) {
                        e5.next = 2;
                        break;
                      }
                      return e5.abrupt("return");
                    case 2:
                      return r4 = this._setImageIdIndex(t4), e5.abrupt("return", r4);
                    case 4:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            })), function(e4) {
              return t3.apply(this, arguments);
            }) }, { key: "calibrateSpacing", value: function(e4) {
              var t4 = this.getImageIds().indexOf(e4);
              this.stackInvalidated = true, this._loadImage(e4, t4);
            } }, { key: "_restoreCameraProps", value: function(e4, t4) {
              var r4 = e4.parallelScale, n4 = this.getRenderer(), i4 = this.getCamera(), a4 = i4.position, o4 = i4.focalPoint, s4 = [a4[0] - this.panCache[0], a4[1] - this.panCache[1], a4[2] - this.panCache[2]], c3 = [o4[0] - this.panCache[0], o4[1] - this.panCache[1], o4[2] - this.panCache[2]];
              this.setCameraNoEvent({ parallelScale: r4, position: s4, focalPoint: c3 });
              var u4 = this.getCamera();
              this.triggerCameraEvent(u4, t4);
              var l3 = { type: "ResetCameraEvent", renderer: n4 };
              n4.invokeEvent(l3);
            } }, { key: "triggerCameraEvent", value: function(e4, t4) {
              var r4 = { previousCamera: t4, camera: e4, element: this.element, viewportId: this.id, renderingEngineId: this.renderingEngineId };
              this.suppressEvents || X(this.element, c2.CAMERA_MODIFIED, r4);
            } }, { key: "triggerCalibrationEvent", value: function() {
              var e4 = this.getImageData().imageData, t4 = qn({ element: this.element, viewportId: this.id, renderingEngineId: this.renderingEngineId, imageId: this.getCurrentImageId(), imageData: e4, worldToIndex: e4.getWorldToIndex() }, this._calibrationEvent);
              this.suppressEvents || X(this.element, c2.IMAGE_SPACING_CALIBRATED, t4), this._publishCalibratedEvent = false;
            } }, { key: "getRenderer", value: function() {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("getRenderer");
              return Nt(Ut(u3.prototype), "getRenderer", this).call(this);
            } }, { key: "getDefaultActor", value: function() {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("getDefaultActor");
              return Nt(Ut(u3.prototype), "getDefaultActor", this).call(this);
            } }, { key: "getActors", value: function() {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("getActors");
              return Nt(Ut(u3.prototype), "getActors", this).call(this);
            } }, { key: "getActor", value: function(e4) {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("getActor");
              return Nt(Ut(u3.prototype), "getActor", this).call(this, e4);
            } }, { key: "setActors", value: function(e4) {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("setActors");
              return Nt(Ut(u3.prototype), "setActors", this).call(this, e4);
            } }, { key: "addActors", value: function(e4) {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("addActors");
              return Nt(Ut(u3.prototype), "addActors", this).call(this, e4);
            } }, { key: "addActor", value: function(e4) {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("addActor");
              return Nt(Ut(u3.prototype), "addActor", this).call(this, e4);
            } }, { key: "removeAllActors", value: function() {
              if (this.useCPURendering)
                throw this.getCPUFallbackError("removeAllActors");
              return Nt(Ut(u3.prototype), "removeAllActors", this).call(this);
            } }, { key: "getCPUFallbackError", value: function(e4) {
              return new Error("method ".concat(e4, " cannot be used during CPU Fallback mode"));
            } }, { key: "fillWithBackgroundColor", value: function() {
              var e4 = this.getRenderingEngine();
              e4 && e4.fillCanvasWithBackgroundColor(this.canvas, this.options.background);
            } }, { key: "setColormap", value: function(e4) {
              this.useCPURendering ? this.setColormapCPU(e4) : this.setColormapGPU(e4);
            } }, { key: "unsetColormap", value: function() {
              this.useCPURendering ? this.unsetColormapCPU() : this.unsetColormapGPU();
            } }, { key: "unsetColormapCPU", value: function() {
              delete this._cpuFallbackEnabledElement.viewport.colormap, this._cpuFallbackEnabledElement.renderingTools = {}, this.cpuRenderingInvalidated = true, this.fillWithBackgroundColor(), this.render();
            } }, { key: "setColormapCPU", value: function(e4) {
              var t4 = ln(e4.name, e4);
              this._cpuFallbackEnabledElement.viewport.colormap = t4, this._cpuFallbackEnabledElement.renderingTools = {}, this.fillWithBackgroundColor(), this.cpuRenderingInvalidated = true, this.render();
            } }, { key: "setColormapGPU", value: function(e4) {
              throw new Error("setColorMapGPU not implemented.");
            } }, { key: "unsetColormapGPU", value: function() {
              throw new Error("unsetColormapGPU not implemented.");
            } }], [{ key: "useCustomRenderingPipeline", get: function() {
              return xr();
            } }]), u3;
          }(rr), Hn = zn, Kn = (V2(Bn = {}, h2.ORTHOGRAPHIC, Pr), V2(Bn, h2.PERSPECTIVE, Pr), V2(Bn, h2.STACK, Hn), Bn);
          function $n(e3) {
            return Kn[e3].useCustomRenderingPipeline;
          }
          function Xn(e3, t3) {
            var r3 = Object.keys(e3);
            if (Object.getOwnPropertySymbols) {
              var n3 = Object.getOwnPropertySymbols(e3);
              t3 && (n3 = n3.filter(function(t4) {
                return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
              })), r3.push.apply(r3, n3);
            }
            return r3;
          }
          function Yn(e3) {
            for (var t3 = 1; t3 < arguments.length; t3++) {
              var r3 = arguments[t3] != null ? arguments[t3] : {};
              t3 % 2 ? Xn(Object(r3), true).forEach(function(t4) {
                V2(e3, t4, r3[t4]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(r3)) : Xn(Object(r3)).forEach(function(t4) {
                Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(r3, t4));
              });
            }
            return e3;
          }
          var Zn = function() {
            function e3(t3) {
              var r3 = this;
              if (M2(this, e3), V2(this, "id", void 0), V2(this, "hasBeenDestroyed", void 0), V2(this, "offscreenMultiRenderWindow", void 0), V2(this, "offScreenCanvasContainer", void 0), V2(this, "_viewports", void 0), V2(this, "_needsRender", /* @__PURE__ */ new Set()), V2(this, "_animationFrameSet", false), V2(this, "_animationFrameHandle", null), V2(this, "useCPURendering", void 0), V2(this, "renderFrameOfReference", function(e4) {
                var t4 = r3._getViewportsAsArray().map(function(t5) {
                  if (t5.getFrameOfReferenceUID() === e4)
                    return t5.id;
                });
                return r3.renderViewports(t4);
              }), V2(this, "_renderFlaggedViewports", function() {
                r3._throwIfDestroyed(), r3.useCPURendering || r3.performVtkDrawCall();
                for (var e4 = r3._getViewportsAsArray(), t4 = [], n3 = 0; n3 < e4.length; n3++) {
                  var i3 = e4[n3];
                  if (r3._needsRender.has(i3.id)) {
                    var a3 = r3.renderViewportUsingCustomOrVtkPipeline(i3);
                    if (t4.push(a3), r3._needsRender.delete(i3.id), r3._needsRender.size === 0)
                      break;
                  }
                }
                r3._animationFrameSet = false, r3._animationFrameHandle = null, t4.forEach(function(e5) {
                  X(e5.element, c2.IMAGE_RENDERED, e5);
                });
              }), this.id = t3 || ee(), this.useCPURendering = xr(), Oe(this), !_r())
                throw new Error("@cornerstonejs/core is not initialized, run init() first");
              this.useCPURendering || (this.offscreenMultiRenderWindow = jt.newInstance(), this.offScreenCanvasContainer = document.createElement("div"), this.offscreenMultiRenderWindow.setContainer(this.offScreenCanvasContainer)), this._viewports = /* @__PURE__ */ new Map(), this.hasBeenDestroyed = false;
            }
            return T2(e3, [{ key: "enableElement", value: function(e4) {
              var t3 = this._normalizeViewportInputEntry(e4);
              this._throwIfDestroyed();
              var r3 = t3.element, n3 = t3.viewportId;
              if (!r3)
                throw new Error("No element provided");
              this.getViewport(n3) && this.disableElement(n3);
              var i3 = $n(t3.type);
              this.useCPURendering || i3 ? this.addCustomViewport(t3) : this.enableVTKjsDrivenViewport(t3);
              var a3 = ke(r3), o3 = t3.defaultOptions.background;
              this.fillCanvasWithBackgroundColor(a3, o3);
            } }, { key: "disableElement", value: function(e4) {
              this._throwIfDestroyed();
              var t3 = this.getViewport(e4);
              t3 ? (this._resetViewport(t3), $n(t3.type) || this.useCPURendering || this.offscreenMultiRenderWindow.removeRenderer(e4), this._removeViewport(e4), this._needsRender.delete(e4), this.getViewports().length || this._clearAnimationFrame(), this.resize()) : console.warn("viewport ".concat(e4, " does not exist"));
            } }, { key: "setViewports", value: function(e4) {
              var t3 = this, r3 = this._normalizeViewportInputEntries(e4);
              this._throwIfDestroyed(), this._reset();
              var n3 = [], i3 = [];
              r3.forEach(function(e5) {
                t3.useCPURendering || $n(e5.type) ? i3.push(e5) : n3.push(e5);
              }), this.setVtkjsDrivenViewports(n3), this.setCustomViewports(i3);
            } }, { key: "resize", value: function() {
              var e4 = !(arguments.length > 0 && arguments[0] !== void 0) || arguments[0], t3 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
              this._throwIfDestroyed();
              var r3 = this._getViewportsAsArray(), n3 = [], i3 = [];
              r3.forEach(function(e5) {
                $n(e5.type) ? i3.push(e5) : n3.push(e5);
              }), this._resizeVTKViewports(n3, e4, t3), this._resizeUsingCustomResizeHandler(i3, e4, t3);
            } }, { key: "getViewport", value: function(e4) {
              return this._viewports.get(e4);
            } }, { key: "getViewports", value: function() {
              return this._throwIfDestroyed(), this._getViewportsAsArray();
            } }, { key: "getStackViewports", value: function() {
              return this._throwIfDestroyed(), this.getViewports().filter(function(e4) {
                return e4 instanceof Hn;
              });
            } }, { key: "getVolumeViewports", value: function() {
              return this._throwIfDestroyed(), this.getViewports().filter(function(e4) {
                return e4 instanceof Pr;
              });
            } }, { key: "render", value: function() {
              var e4 = this.getViewports().map(function(e5) {
                return e5.id;
              });
              this._setViewportsToBeRenderedNextFrame(e4);
            } }, { key: "renderViewports", value: function(e4) {
              this._setViewportsToBeRenderedNextFrame(e4);
            } }, { key: "renderViewport", value: function(e4) {
              this._setViewportsToBeRenderedNextFrame([e4]);
            } }, { key: "destroy", value: function() {
              this.hasBeenDestroyed || (this._reset(), Pe(this.id), this.useCPURendering || (this.offscreenMultiRenderWindow.delete(), delete this.offscreenMultiRenderWindow), this.hasBeenDestroyed = true);
            } }, { key: "fillCanvasWithBackgroundColor", value: function(e4, t3) {
              var r3, n3 = e4.getContext("2d");
              if (t3) {
                var i3 = t3.map(function(e5) {
                  return Math.floor(255 * e5);
                });
                r3 = "rgb(".concat(i3[0], ", ").concat(i3[1], ", ").concat(i3[2], ")");
              } else
                r3 = "black";
              n3.fillStyle = r3, n3.fillRect(0, 0, e4.width, e4.height);
            } }, { key: "_normalizeViewportInputEntry", value: function(e4) {
              var t3 = e4.type, r3 = e4.defaultOptions;
              return r3 && Object.keys(r3).length !== 0 || (r3 = { background: [0, 0, 0], orientation: null }, t3 === h2.ORTHOGRAPHIC && (r3 = Yn(Yn({}, r3), {}, { orientation: y2.AXIAL }))), Yn(Yn({}, e4), {}, { defaultOptions: r3 });
            } }, { key: "_normalizeViewportInputEntries", value: function(e4) {
              var t3 = this, r3 = [];
              return e4.forEach(function(e5) {
                r3.push(t3._normalizeViewportInputEntry(e5));
              }), r3;
            } }, { key: "_resizeUsingCustomResizeHandler", value: function(e4) {
              var t3 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], r3 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
              e4.forEach(function(e5) {
                typeof e5.resize == "function" && e5.resize();
              }), e4.forEach(function(e5) {
                e5.resetCamera(r3);
              }), t3 === true && this.render();
            } }, { key: "_resizeVTKViewports", value: function(e4) {
              var t3 = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1], r3 = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2], n3 = e4.map(function(e5) {
                return e5.canvas;
              });
              if (n3.length) {
                var i3 = this._resizeOffScreenCanvas(n3), a3 = i3.offScreenCanvasWidth, o3 = i3.offScreenCanvasHeight;
                this._resize(e4, a3, o3);
              }
              e4.forEach(function(e5) {
                e5.resetCamera(t3);
              }), r3 === true && this.render();
            } }, { key: "enableVTKjsDrivenViewport", value: function(e4) {
              var t3 = this._getViewportsAsArray().filter(function(e5) {
                return $n(e5.type) === false;
              }), r3 = t3.map(function(e5) {
                return e5.canvas;
              }), n3 = ke(e4.element);
              r3.push(n3);
              var i3 = this._resizeOffScreenCanvas(r3), a3 = i3.offScreenCanvasWidth, o3 = i3.offScreenCanvasHeight, s3 = this._resize(t3, a3, o3), c3 = Yn(Yn({}, e4), {}, { canvas: n3 });
              this.addVtkjsDrivenViewport(c3, { offScreenCanvasWidth: a3, offScreenCanvasHeight: o3, xOffset: s3 });
            } }, { key: "_removeViewport", value: function(e4) {
              this.getViewport(e4) ? this._viewports.delete(e4) : console.warn("viewport ".concat(e4, " does not exist"));
            } }, { key: "addVtkjsDrivenViewport", value: function(e4, t3) {
              var r3 = e4.element, n3 = e4.canvas, i3 = e4.viewportId, a3 = e4.type, o3 = e4.defaultOptions;
              r3.tabIndex = -1;
              var s3 = t3.offScreenCanvasWidth, u3 = t3.offScreenCanvasHeight, l3 = t3.xOffset, d3 = this._getViewportCoordsOnOffScreenCanvas(e4, s3, u3, l3), f3 = d3.sxStartDisplayCoords, v3 = d3.syStartDisplayCoords, p3 = d3.sxEndDisplayCoords, g3 = d3.syEndDisplayCoords, m3 = d3.sx, w3 = d3.sy, y3 = d3.sWidth, C3 = d3.sHeight;
              this.offscreenMultiRenderWindow.addRenderer({ viewport: [f3, v3, p3, g3], id: i3, background: o3.background ? o3.background : [0, 0, 0] });
              var b3, I3 = { id: i3, element: r3, renderingEngineId: this.id, type: a3, canvas: n3, sx: m3, sy: w3, sWidth: y3, sHeight: C3, defaultOptions: o3 || {} };
              if (a3 === h2.STACK)
                b3 = new Hn(I3);
              else {
                if (a3 !== h2.ORTHOGRAPHIC)
                  throw new Error("Viewport Type ".concat(a3, " is not supported"));
                b3 = new Pr(I3);
              }
              this._viewports.set(i3, b3);
              var k3 = { element: r3, viewportId: i3, renderingEngineId: this.id };
              b3.suppressEvents || X($, c2.ELEMENT_ENABLED, k3);
            } }, { key: "addCustomViewport", value: function(e4) {
              var t3 = e4.element, r3 = e4.viewportId, n3 = e4.type, i3 = e4.defaultOptions;
              t3.tabIndex = -1;
              var a3 = ke(t3), o3 = a3.clientWidth, s3 = a3.clientHeight;
              a3.width === o3 && a3.height === s3 || (a3.width = o3, a3.height = s3);
              var u3 = { id: r3, renderingEngineId: this.id, element: t3, type: n3, canvas: a3, sx: 0, sy: 0, sWidth: o3, sHeight: s3, defaultOptions: i3 || {} };
              if (n3 !== h2.STACK)
                throw new Error("Support for fully custom viewports not yet implemented");
              var l3 = new Hn(u3);
              this._viewports.set(r3, l3);
              var d3 = { element: t3, viewportId: r3, renderingEngineId: this.id };
              X($, c2.ELEMENT_ENABLED, d3);
            } }, { key: "setCustomViewports", value: function(e4) {
              var t3 = this;
              e4.forEach(function(e5) {
                return t3.addCustomViewport(e5);
              });
            } }, { key: "setVtkjsDrivenViewports", value: function(e4) {
              if (e4.length)
                for (var t3 = e4.map(function(e5) {
                  return ke(e5.element);
                }), r3 = this._resizeOffScreenCanvas(t3), n3 = r3.offScreenCanvasWidth, i3 = r3.offScreenCanvasHeight, a3 = 0, o3 = 0; o3 < e4.length; o3++) {
                  var s3 = e4[o3], c3 = t3[o3], u3 = Yn(Yn({}, s3), {}, { canvas: c3 });
                  this.addVtkjsDrivenViewport(u3, { offScreenCanvasWidth: n3, offScreenCanvasHeight: i3, xOffset: a3 }), a3 += c3.clientWidth;
                }
            } }, { key: "_resizeOffScreenCanvas", value: function(e4) {
              var t3 = this.offScreenCanvasContainer, r3 = this.offscreenMultiRenderWindow, n3 = Math.max.apply(Math, Ae(e4.map(function(e5) {
                return e5.clientHeight;
              }))), i3 = 0;
              return e4.forEach(function(e5) {
                i3 += e5.clientWidth;
              }), t3.width = i3, t3.height = n3, r3.resize(), { offScreenCanvasWidth: i3, offScreenCanvasHeight: n3 };
            } }, { key: "_resize", value: function(e4, t3, r3) {
              for (var n3 = 0, i3 = 0; i3 < e4.length; i3++) {
                var a3 = e4[i3], o3 = this._getViewportCoordsOnOffScreenCanvas(a3, t3, r3, n3), s3 = o3.sxStartDisplayCoords, c3 = o3.syStartDisplayCoords, u3 = o3.sxEndDisplayCoords, l3 = o3.syEndDisplayCoords, d3 = o3.sx, h3 = o3.sy, f3 = o3.sWidth, v3 = o3.sHeight;
                n3 += a3.element.clientWidth, a3.sx = d3, a3.sy = h3, a3.sWidth = f3, a3.sHeight = v3, this.offscreenMultiRenderWindow.getRenderer(a3.id).setViewport([s3, c3, u3, l3]);
              }
              return n3;
            } }, { key: "_getViewportCoordsOnOffScreenCanvas", value: function(e4, t3, r3, n3) {
              var i3 = e4.canvas, a3 = i3.clientWidth, o3 = i3.clientHeight;
              i3.width === a3 && i3.height === o3 || (i3.width = a3, i3.height = o3);
              var s3 = n3 / t3, c3 = 0 + (r3 - o3) / r3;
              return { sxStartDisplayCoords: s3, syStartDisplayCoords: c3, sxEndDisplayCoords: s3 + a3 / t3, syEndDisplayCoords: c3 + o3 / r3, sx: n3, sy: 0, sWidth: a3, sHeight: o3 };
            } }, { key: "_getViewportsAsArray", value: function() {
              return Array.from(this._viewports.values());
            } }, { key: "_setViewportsToBeRenderedNextFrame", value: function(e4) {
              var t3 = this;
              e4.forEach(function(e5) {
                t3._needsRender.add(e5);
              }), this._render();
            } }, { key: "_render", value: function() {
              this._needsRender.size > 0 && this._animationFrameSet === false && (this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports), this._animationFrameSet = true);
            } }, { key: "performVtkDrawCall", value: function() {
              var e4 = this.offscreenMultiRenderWindow, t3 = e4.getRenderWindow(), r3 = e4.getRenderers();
              if (r3.length) {
                for (var n3 = 0; n3 < r3.length; n3++) {
                  var i3 = r3[n3], a3 = i3.renderer, o3 = i3.id;
                  this._needsRender.has(o3) ? a3.setDraw(true) : a3.setDraw(false);
                }
                t3.render();
                for (var s3 = 0; s3 < r3.length; s3++)
                  r3[s3].renderer.setDraw(false);
              }
            } }, { key: "renderViewportUsingCustomOrVtkPipeline", value: function(e4) {
              var t3;
              if ($n(e4.type) === true)
                t3 = e4.customRenderViewportToCanvas();
              else {
                if (this.useCPURendering)
                  throw new Error("GPU not available, and using a viewport with no custom render pipeline.");
                var r3 = this.offscreenMultiRenderWindow.getOpenGLRenderWindow().get3DContext().canvas;
                t3 = this._renderViewportFromVtkCanvasToOnscreenCanvas(e4, r3);
              }
              return t3;
            } }, { key: "_renderViewportFromVtkCanvasToOnscreenCanvas", value: function(e4, t3) {
              var r3 = e4.element, n3 = e4.canvas, i3 = e4.sx, a3 = e4.sy, o3 = e4.sWidth, s3 = e4.sHeight, c3 = e4.id, u3 = e4.renderingEngineId, l3 = e4.suppressEvents, d3 = n3.width, h3 = n3.height;
              return n3.getContext("2d").drawImage(t3, i3, a3, o3, s3, 0, 0, d3, h3), { element: r3, suppressEvents: l3, viewportId: c3, renderingEngineId: u3 };
            } }, { key: "_resetViewport", value: function(e4) {
              var t3 = this.id, r3 = e4.element, n3 = e4.canvas, i3 = { element: r3, viewportId: e4.id, renderingEngineId: t3 };
              X($, c2.ELEMENT_DISABLED, i3), r3.removeAttribute("data-viewport-uid"), r3.removeAttribute("data-rendering-engine-uid"), n3.getContext("2d").clearRect(0, 0, n3.width, n3.height);
            } }, { key: "_clearAnimationFrame", value: function() {
              window.cancelAnimationFrame(this._animationFrameHandle), this._needsRender.clear(), this._animationFrameSet = false, this._animationFrameHandle = null;
            } }, { key: "_reset", value: function() {
              var e4 = this;
              this._getViewportsAsArray().forEach(function(t3) {
                e4._resetViewport(t3);
              }), this._clearAnimationFrame(), this._viewports = /* @__PURE__ */ new Map();
            } }, { key: "_throwIfDestroyed", value: function() {
              if (this.hasBeenDestroyed)
                throw new Error("this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.");
            } }, { key: "_downloadOffScreenCanvas", value: function() {
              var e4, t3;
              e4 = this._debugRender(), (t3 = document.createElement("a")).download = "viewport.png", t3.href = e4, document.body.appendChild(t3), t3.click(), document.body.removeChild(t3);
            } }, { key: "_debugRender", value: function() {
              for (var e4 = this.offscreenMultiRenderWindow, t3 = e4.getRenderWindow(), r3 = e4.getRenderers(), n3 = 0; n3 < r3.length; n3++)
                r3[n3].renderer.setDraw(true);
              t3.render();
              var i3 = e4.getOpenGLRenderWindow().get3DContext().canvas, a3 = i3.toDataURL();
              return this._getViewportsAsArray().forEach(function(e5) {
                var t4 = e5.sx, r4 = e5.sy, n4 = e5.sWidth, a4 = e5.sHeight, o3 = e5.canvas, s3 = o3.width, c3 = o3.height;
                o3.getContext("2d").drawImage(i3, t4, r4, n4, a4, 0, 0, s3, c3);
              }), a3;
            } }]), e3;
          }(), Jn = Zn;
          function Qn(e3) {
            return _e(e3);
          }
          function ei() {
            return Se();
          }
          var ti = Qn;
          function ri(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n3 = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            return new Promise(function(i3, a3) {
              var o3 = Qn(r3);
              if (o3 && !o3.hasBeenDestroyed || (o3 = new Jn()), !(t3 && t3 instanceof HTMLCanvasElement))
                throw new Error("canvas element is required");
              if (!o3)
                throw new Error("No rendering engine with Id of ".concat(r3, " found"));
              var s3 = document.createElement("div");
              s3.style.width = "".concat(t3.width, "px"), s3.style.height = "".concat(t3.height, "px"), s3.style.visibility = "hidden", document.body.appendChild(s3);
              var u3 = e3, l3 = { viewportId: u3, type: h2.STACK, element: s3, defaultOptions: { orientation: y2.AXIAL, suppressEvents: n3 } };
              o3.enableElement(l3);
              var d3 = o3.getViewport(u3);
              s3.addEventListener(c2.IMAGE_RENDERED, function() {
                var r4 = ke(s3);
                t3.getContext("2d").drawImage(r4, 0, 0), o3.disableElement(u3), document.body.removeChild(s3), o3.destroy(), i3(e3);
              }), d3.setStack([e3]);
            });
          }
          var ni = Jn, ii = new pn();
          ii.maxNumRequests = { interaction: 200, thumbnail: 200, prefetch: 200 }, ii.grabDelay = 0;
          var ai = ii;
          function oi(e3) {
          }
          function si(e3) {
            if (e3) {
              var t3 = e3.dataset;
              return ci(t3.viewportUid, t3.renderingEngineUid);
            }
          }
          function ci(e3, t3) {
            if (t3 && e3) {
              var r3 = ti(t3);
              if (r3 && !r3.hasBeenDestroyed) {
                var n3 = r3.getViewport(e3);
                if (n3) {
                  var i3 = n3.getFrameOfReferenceUID();
                  return { viewport: n3, renderingEngine: r3, viewportId: e3, renderingEngineId: t3, FrameOfReferenceUID: i3 };
                }
              }
            }
          }
          var ui = Symbol("DefaultSettings"), li = Symbol("RuntimeSettings"), di = Symbol("ObjectSettingsMap"), hi = Symbol("Dictionary"), fi = function() {
            function e3(t3) {
              M2(this, e3);
              var r3 = Object.create(t3 instanceof e3 && hi in t3 ? t3[hi] : null);
              Object.seal(Object.defineProperty(this, hi, { value: r3 }));
            }
            return T2(e3, [{ key: "set", value: function(e4, t3) {
              return pi(this[hi], e4, t3, null);
            } }, { key: "get", value: function(e4) {
              return function(e5, t3) {
                return e5[t3];
              }(this[hi], e4);
            } }, { key: "unset", value: function(e4) {
              return function(e5, t3) {
                if (t3.endsWith(".")) {
                  var r3 = 0, n3 = t3, i3 = n3.slice(0, -1), a3 = i3.length === 0;
                  for (var o3 in e5)
                    Object.prototype.hasOwnProperty.call(e5, o3) && (a3 || o3.startsWith(n3) || o3 === i3) && (delete e5[o3], ++r3);
                  return r3 > 0;
                }
                return delete e5[t3];
              }(this[hi], e4 + "");
            } }, { key: "forEach", value: function(e4) {
              vi(this[hi], e4);
            } }, { key: "extend", value: function() {
              return new e3(this);
            } }, { key: "import", value: function(e4) {
              var t3 = this;
              gi(e4) && Object.keys(e4).forEach(function(r3) {
                pi(t3[hi], r3, e4[r3], null);
              });
            } }, { key: "dump", value: function() {
              var e4 = {};
              return vi(this[hi], function(t3, r3) {
                r3 !== void 0 && mi(e4, t3, r3);
              }), e4;
            } }], [{ key: "assert", value: function(t3) {
              return t3 instanceof e3 ? t3 : e3.getRuntimeSettings();
            } }, { key: "getDefaultSettings", value: function() {
              var t3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, r3 = e3[ui];
              if (r3 instanceof e3 || (r3 = new e3(), e3[ui] = r3), t3) {
                var n3 = {};
                return r3.forEach(function(e4) {
                  if (e4.startsWith(t3)) {
                    var i3 = e4.split("".concat(t3, "."))[1];
                    n3[i3] = r3.get(e4);
                  }
                }), n3;
              }
              return r3;
            } }, { key: "getRuntimeSettings", value: function() {
              var t3 = e3[li];
              return t3 instanceof e3 || (t3 = new e3(e3.getDefaultSettings()), e3[li] = t3), t3;
            } }, { key: "getObjectSettings", value: function(t3, r3) {
              var n3 = null;
              if (t3 instanceof e3)
                n3 = t3;
              else if (qt(t3) === "object" && t3 !== null) {
                var i3 = e3[di];
                i3 instanceof WeakMap || (i3 = /* @__PURE__ */ new WeakMap(), e3[di] = i3), (n3 = i3.get(t3)) instanceof e3 || (n3 = new e3(e3.assert(e3.getObjectSettings(r3))), i3.set(t3, n3));
              }
              return n3;
            } }, { key: "extendRuntimeSettings", value: function() {
              return e3.getRuntimeSettings().extend();
            } }]), e3;
          }();
          function vi(e3, t3) {
            for (var r3 in e3)
              t3(r3, e3[r3]);
          }
          function pi(e3, t3, r3, n3) {
            return !!function(e4) {
              var t4, r4, n4;
              if (typeof e4 != "string" || (t4 = e4.length - 1) < 0)
                return false;
              for (n4 = -1; (r4 = e4.indexOf(".", n4 + 1)) >= 0; ) {
                if (r4 - n4 < 2 || r4 === t4)
                  return false;
                n4 = r4;
              }
              return true;
            }(t3) && (gi(r3) ? function(e4, t4, r4, n4) {
              var i3;
              if (n4.has(r4))
                return pi(e4, t4, null, n4);
              for (var a3 in n4.add(r4), i3 = 0, r4)
                Object.prototype.hasOwnProperty.call(r4, a3) && (pi(e4, a3.length === 0 ? t4 : "".concat(t4, ".").concat(a3), r4[a3], n4) || ++i3);
              return n4.delete(r4), i3 === 0;
            }(e3, t3, r3, n3 instanceof WeakSet ? n3 : /* @__PURE__ */ new WeakSet()) : (e3[t3] = r3, true));
          }
          function gi(e3) {
            if (qt(e3) === "object" && e3 !== null) {
              var t3 = Object.getPrototypeOf(e3);
              if (t3 === Object.prototype || t3 === null)
                return true;
            }
            return false;
          }
          function mi(e3, t3, r3) {
            var n3 = t3.indexOf(".");
            if (n3 >= 0) {
              var i3 = t3.slice(0, n3), a3 = e3[i3];
              if (qt(a3) !== "object" || a3 === null) {
                var o3 = a3;
                a3 = {}, o3 !== void 0 && (a3[""] = o3), e3[i3] = a3;
              }
              mi(a3, t3.slice(n3 + 1, t3.length), r3);
            } else
              e3[t3] = r3;
          }
          function wi(e3, t3) {
            for (var r3 = e3.getSize(), n3 = 0; n3 < r3; n3++) {
              var i3 = [];
              e3.getNodeValue(n3, i3), i3[1] = i3[1] * t3, i3[2] = i3[2] * t3, i3[3] = i3[3] * t3, e3.setNodeValue(n3, i3);
            }
          }
          function yi(e3) {
            for (var t3, r3 = e3[0], n3 = e3[0], i3 = e3.length, a3 = 1; a3 < i3; a3++)
              t3 = e3[a3], r3 = Math.min(r3, t3), n3 = Math.max(n3, t3);
            return { min: r3, max: n3 };
          }
          var Ci = Symbol("LastRuntimeId"), bi = {};
          function Ii(e3, t3, r3) {
            return function(e4, t4, r4) {
              var n3 = e4[t4];
              n3 instanceof Array || (n3 = [0], Object.defineProperty(e4, t4, { value: n3 }));
              for (var i3 = true, a3 = 0; i3 && a3 < n3.length; ++a3) {
                var o3 = 0 | n3[a3];
                o3 < r4 ? (i3 = false, o3 += 1) : (o3 = 0, a3 + 1 === n3.length && n3.push(0)), n3[a3] = o3;
              }
              return n3;
            }(e3 !== null && qt(e3) === "object" ? e3 : bi, Ci, (typeof r3 == "number" && r3 > 0 ? r3 : 4294967295) >>> 0).join(typeof t3 == "string" ? t3 : "-");
          }
          var ki = {}, Ei = { add: function(e3, t3) {
            var r3 = Y(e3);
            ki[r3] || (ki[r3] = {}), ki[r3] = t3;
          }, get: function(e3, t3) {
            if (e3 === "calibratedPixelSpacing") {
              var r3 = Y(t3);
              return ki[r3];
            }
          } };
          function Ri(e3, t3) {
            var r3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1e-5;
            return Math.abs(e3[0] + t3[0]) < r3 && Math.abs(e3[1] + t3[1]) < r3 && Math.abs(e3[2] + t3[2]) < r3;
          }
          var Ai = function(e3) {
            if (!window.crossOriginIsolated)
              throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
            if (window.SharedArrayBuffer === void 0)
              throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
            var t3 = new SharedArrayBuffer(e3);
            return new Uint8Array(t3);
          }, xi = function(e3) {
            if (!window.crossOriginIsolated)
              throw new Error("Your page is NOT cross-origin isolated, see https://developer.mozilla.org/en-US/docs/Web/API/crossOriginIsolated");
            if (window.SharedArrayBuffer === void 0)
              throw new Error("SharedArrayBuffer is NOT supported in your browser see https://developer.chrome.com/blog/enabling-shared-array-buffer/");
            var t3 = new SharedArrayBuffer(4 * e3);
            return new Float32Array(t3);
          };
          function _i(e3, t3) {
            var r3 = e3.direction, n3 = e3.spacing, i3 = r3.slice(0, 3), a3 = r3.slice(3, 6), o3 = r3.slice(6, 9), s3 = [lt.vec3.dot(i3, t3), lt.vec3.dot(a3, t3), lt.vec3.dot(o3, t3)], c3 = lt.vec3.create();
            return lt.vec3.set(c3, s3[0] * n3[0], s3[1] * n3[1], s3[2] * n3[2]), lt.vec3.length(c3);
          }
          function Oi(e3, t3, r3, n3) {
            if (e3) {
              var i3 = e3.direction, a3 = e3.imageIds;
              if (a3 && a3.length) {
                var o3 = i3.slice(6, 9), s3 = lt.vec3.dot(o3, r3);
                if (!(Math.abs(s3) < 0.99)) {
                  for (var c3, u3 = _i(e3, r3) / 2, l3 = 0; l3 < a3.length; l3++) {
                    var d3 = a3[l3], h3 = Vr("imagePlaneModule", d3).imagePositionPatient, f3 = lt.vec3.create();
                    lt.vec3.sub(f3, t3, h3);
                    var v3 = lt.vec3.dot(f3, r3);
                    Math.abs(v3) < u3 && (c3 = d3);
                  }
                  return c3;
                }
              }
            }
          }
          function Pi3(e3, t3, r3) {
            var n3 = t3.viewPlaneNormal, i3 = e3.getActors();
            if (!i3 && !i3.length)
              return { spacingInNormalDirection: null, imageVolume: null };
            var a3 = i3.length, o3 = i3.map(function(e4) {
              return Q.getVolume(e4.uid);
            });
            if (r3) {
              var s3 = o3.find(function(e4) {
                return e4.volumeId === r3;
              });
              return { imageVolume: s3, spacingInNormalDirection: _i(s3, n3) };
            }
            for (var c3 = { spacingInNormalDirection: 1 / 0, imageVolume: null }, u3 = 0; u3 < a3; u3++) {
              var l3 = o3[u3];
              if (l3) {
                var d3 = _i(l3, n3);
                d3 < c3.spacingInNormalDirection && (c3.spacingInNormalDirection = d3, c3.imageVolume = l3);
              }
            }
            return c3;
          }
          function Si(e3) {
            var t3 = e3.getMapper().getInputData(), r3 = t3.extentToBounds(t3.getExtent());
            return [[r3[0], r3[2], r3[4]], [r3[0], r3[2], r3[5]], [r3[0], r3[3], r3[4]], [r3[0], r3[3], r3[5]], [r3[1], r3[2], r3[4]], [r3[1], r3[2], r3[5]], [r3[1], r3[3], r3[4]], [r3[1], r3[3], r3[5]]];
          }
          function Di(e3, t3) {
            return !(e3[0] < 0 || e3[0] >= t3[0] || e3[1] < 0 || e3[1] >= t3[1] || e3[2] < 0 || e3[2] >= t3[2]);
          }
          function Ti(e3, t3) {
            (t3 == null || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n3 = new Array(t3); r3 < t3; r3++)
              n3[r3] = e3[r3];
            return n3;
          }
          var Mi = function(e3, t3) {
            var r3;
            r3 = t3 ? [Qn(t3)] : ei();
            var n3 = [];
            return r3.forEach(function(t4) {
              var r4, i3 = e3.getActors(), a3 = function(e4, t5) {
                var r5 = typeof Symbol != "undefined" && e4[Symbol.iterator] || e4["@@iterator"];
                if (!r5) {
                  if (Array.isArray(e4) || (r5 = function(e5, t6) {
                    if (e5) {
                      if (typeof e5 == "string")
                        return Ti(e5, t6);
                      var r6 = Object.prototype.toString.call(e5).slice(8, -1);
                      return r6 === "Object" && e5.constructor && (r6 = e5.constructor.name), r6 === "Map" || r6 === "Set" ? Array.from(e5) : r6 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r6) ? Ti(e5, t6) : void 0;
                    }
                  }(e4)) || t5 && e4 && typeof e4.length == "number") {
                    r5 && (e4 = r5);
                    var n4 = 0, i4 = function() {
                    };
                    return { s: i4, n: function() {
                      return n4 >= e4.length ? { done: true } : { done: false, value: e4[n4++] };
                    }, e: function(e5) {
                      throw e5;
                    }, f: i4 };
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                }
                var a4, o4 = true, s3 = false;
                return { s: function() {
                  r5 = r5.call(e4);
                }, n: function() {
                  var e5 = r5.next();
                  return o4 = e5.done, e5;
                }, e: function(e5) {
                  s3 = true, a4 = e5;
                }, f: function() {
                  try {
                    o4 || r5.return == null || r5.return();
                  } finally {
                    if (s3)
                      throw a4;
                  }
                } };
              }(t4.getVolumeViewports());
              try {
                var o3 = function() {
                  var e4 = r4.value, t5 = e4.getActors();
                  if (t5.length !== i3.length)
                    return "continue";
                  i3.every(function(e5) {
                    var r5 = e5.uid;
                    return t5.find(function(e6) {
                      return r5 === e6.uid;
                    });
                  }) && n3.push(e4);
                };
                for (a3.s(); !(r4 = a3.n()).done; )
                  o3();
              } catch (e4) {
                a3.e(e4);
              } finally {
                a3.f();
              }
            }), n3;
          }, Vi = function(e3, t3) {
            var r3;
            r3 = t3 ? [Qn(t3)] : ei();
            var n3 = [];
            return r3.forEach(function(t4) {
              var r4 = t4.getVolumeViewports().filter(function(t5) {
                var r5 = t5.getDefaultActor();
                return r5.volumeActor && r5.uid === e3;
              });
              n3.push.apply(n3, Ae(r4));
            }), n3;
          };
          function ji() {
            return ji = b2(k2().mark(function e3(t3, r3, n3) {
              var i3, a3, o3 = arguments;
              return k2().wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      return i3 = o3.length > 3 && o3[3] !== void 0 && o3[3], n3.forEach(function(e5) {
                        var r4 = t3.getViewport(e5);
                        if (!r4)
                          throw new Error("Viewport with Id ".concat(e5, " does not exist"));
                        if (!(r4 instanceof Pr))
                          throw new Error("setVolumesForViewports only supports VolumeViewport");
                      }), a3 = n3.map(function() {
                        var e5 = b2(k2().mark(function e6(n4) {
                          var a4;
                          return k2().wrap(function(e7) {
                            for (; ; )
                              switch (e7.prev = e7.next) {
                                case 0:
                                  return a4 = t3.getViewport(n4), e7.next = 3, a4.setVolumes(r3, i3);
                                case 3:
                                case "end":
                                  return e7.stop();
                              }
                          }, e6);
                        }));
                        return function(t4) {
                          return e5.apply(this, arguments);
                        };
                      }()), e4.next = 5, Promise.all(a3);
                    case 5:
                      return e4.abrupt("return");
                    case 6:
                    case "end":
                      return e4.stop();
                  }
              }, e3);
            })), ji.apply(this, arguments);
          }
          var Li = function(e3, t3, r3) {
            return ji.apply(this, arguments);
          };
          function Ui() {
            return Ui = b2(k2().mark(function e3(t3, r3, n3) {
              var i3, a3, o3 = arguments;
              return k2().wrap(function(e4) {
                for (; ; )
                  switch (e4.prev = e4.next) {
                    case 0:
                      return i3 = o3.length > 3 && o3[3] !== void 0 && o3[3], n3.forEach(function(e5) {
                        var r4 = t3.getViewport(e5);
                        if (!r4)
                          throw new Error("Viewport with Id ".concat(e5, " does not exist"));
                        if (!(r4 instanceof Pr))
                          throw new Error("addVolumesToViewports only supports VolumeViewport");
                      }), a3 = n3.map(function() {
                        var e5 = b2(k2().mark(function e6(n4) {
                          var a4;
                          return k2().wrap(function(e7) {
                            for (; ; )
                              switch (e7.prev = e7.next) {
                                case 0:
                                  return a4 = t3.getViewport(n4), e7.next = 3, a4.addVolumes(r3, i3);
                                case 3:
                                case "end":
                                  return e7.stop();
                              }
                          }, e6);
                        }));
                        return function(t4) {
                          return e5.apply(this, arguments);
                        };
                      }()), e4.next = 5, Promise.all(a3);
                    case 5:
                      return e4.abrupt("return");
                    case 6:
                    case "end":
                      return e4.stop();
                  }
              }, e3);
            })), Ui.apply(this, arguments);
          }
          var Fi = function(e3, t3, r3) {
            return Ui.apply(this, arguments);
          }, Ni = { Events: c2, ViewportType: h2, InterpolationType: v2, RequestType: l2, BlendModes: m2 }, Gi = { ORIENTATION: y2, CPU_COLORMAPS: on };
        }(), G;
      }();
    });
  }
});

// dep:@cornerstonejs_core_dist_umd_index
var cornerstonejs_core_dist_umd_index_default = require_umd();
export {
  cornerstonejs_core_dist_umd_index_default as default
};
//# sourceMappingURL=@cornerstonejs_core_dist_umd_index.js.map
