import {
  __commonJS
} from "./chunk-QOVRSCHT.js";

// node_modules/promise-file-reader/PromiseFileReader.js
var require_PromiseFileReader = __commonJS({
  "node_modules/promise-file-reader/PromiseFileReader.js"(exports, module) {
    function readAs(file, as) {
      if (!(file instanceof Blob)) {
        throw new TypeError("Must be a File or Blob");
      }
      return new Promise(function(resolve, reject) {
        var reader = new FileReader();
        reader.onload = function(e) {
          resolve(e.target.result);
        };
        reader.onerror = function(e) {
          reject(new Error("Error reading" + file.name + ": " + e.target.result));
        };
        reader["readAs" + as](file);
      });
    }
    function readAsDataURL(file) {
      return readAs(file, "DataURL");
    }
    function readAsText(file) {
      return readAs(file, "Text");
    }
    function readAsArrayBuffer(file) {
      return readAs(file, "ArrayBuffer");
    }
    module.exports = {
      readAsDataURL,
      readAsText,
      readAsArrayBuffer
    };
  }
});

// node_modules/webworker-promise/src/tiny-emitter.js
var require_tiny_emitter = __commonJS({
  "node_modules/webworker-promise/src/tiny-emitter.js"(exports, module) {
    var TinyEmitter = class {
      constructor() {
        Object.defineProperty(this, "__listeners", {
          value: {},
          enumerable: false,
          writable: false
        });
      }
      emit(eventName, ...args) {
        if (!this.__listeners[eventName])
          return this;
        for (const handler of this.__listeners[eventName]) {
          handler(...args);
        }
        return this;
      }
      once(eventName, handler) {
        const once = (...args) => {
          this.off(eventName, once);
          handler(...args);
        };
        return this.on(eventName, once);
      }
      on(eventName, handler) {
        if (!this.__listeners[eventName])
          this.__listeners[eventName] = [];
        this.__listeners[eventName].push(handler);
        return this;
      }
      off(eventName, handler) {
        if (handler)
          this.__listeners[eventName] = this.__listeners[eventName].filter((h) => h !== handler);
        else
          this.__listeners[eventName] = [];
        return this;
      }
    };
    module.exports = TinyEmitter;
  }
});

// node_modules/webworker-promise/src/index.js
var require_src = __commonJS({
  "node_modules/webworker-promise/src/index.js"(exports, module) {
    var TinyEmitter = require_tiny_emitter();
    var MESSAGE_RESULT = 0;
    var MESSAGE_EVENT = 1;
    var RESULT_SUCCESS = 1;
    var Worker = class extends TinyEmitter {
      constructor(worker) {
        super();
        this._messageId = 1;
        this._messages = /* @__PURE__ */ new Map();
        this._worker = worker;
        this._worker.onmessage = this._onMessage.bind(this);
        this._id = Math.ceil(Math.random() * 1e7);
      }
      terminate() {
        this._worker.terminate();
      }
      isFree() {
        return this._messages.size === 0;
      }
      jobsLength() {
        return this._messages.size;
      }
      exec(operationName, data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data, operationName], transferable || []);
        });
      }
      postMessage(data = null, transferable = [], onEvent) {
        return new Promise((res, rej) => {
          const messageId = this._messageId++;
          this._messages.set(messageId, [res, rej, onEvent]);
          this._worker.postMessage([messageId, data], transferable || []);
        });
      }
      emit(eventName, ...args) {
        this._worker.postMessage({ eventName, args });
      }
      _onMessage(e) {
        if (!Array.isArray(e.data) && e.data.eventName) {
          return super.emit(e.data.eventName, ...e.data.args);
        }
        const [type, ...args] = e.data;
        if (type === MESSAGE_EVENT)
          this._onEvent(...args);
        else if (type === MESSAGE_RESULT)
          this._onResult(...args);
        else
          throw new Error(`Wrong message type '${type}'`);
      }
      _onResult(messageId, success, payload) {
        const [res, rej] = this._messages.get(messageId);
        this._messages.delete(messageId);
        return success === RESULT_SUCCESS ? res(payload) : rej(payload);
      }
      _onEvent(messageId, eventName, data) {
        const [, , onEvent] = this._messages.get(messageId);
        if (onEvent) {
          onEvent(eventName, data);
        }
      }
    };
    module.exports = Worker;
  }
});

export {
  require_src,
  require_PromiseFileReader
};
//# sourceMappingURL=chunk-NCYV7ODC.js.map
